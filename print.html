<!DOCTYPE HTML>
<html lang="cs" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Úvod do programování</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        <style>
.xterm {
  margin-top: 10px;
}
.content {
  overflow-y: visible !important;
}
video {
    max-width: 100%;
}
</style>
<script src="https://kelvin.cs.vsb.cz/upr/animations.js"></script>


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/css/tufte.css">
        
        <link rel="stylesheet" href="src/wasm/xterm.min.css">
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "rust" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="uvod/uvod.html"><strong aria-hidden="true">1.</strong> Úvod</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="uvod/programovani.html"><strong aria-hidden="true">1.1.</strong> Programování</a></li><li class="chapter-item "><a href="uvod/programovaci_jazyky.html"><strong aria-hidden="true">1.2.</strong> Programovací jazyky</a></li><li class="chapter-item "><a href="uvod/jazyk_c.html"><strong aria-hidden="true">1.3.</strong> Jazyk C</a></li><li class="chapter-item "><a href="uvod/pamet.html"><strong aria-hidden="true">1.4.</strong> Paměť</a></li></ol></li><li class="chapter-item "><a href="prostredi/nastaveni_prostredi.html"><strong aria-hidden="true">2.</strong> Nastavení prostředí</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="prostredi/linux.html"><strong aria-hidden="true">2.1.</strong> Linux</a></li><li class="chapter-item "><a href="prostredi/editor.html"><strong aria-hidden="true">2.2.</strong> Editor</a></li><li class="chapter-item "><a href="prostredi/preklad_programu.html"><strong aria-hidden="true">2.3.</strong> Překlad</a></li><li class="chapter-item "><a href="prostredi/ladeni.html"><strong aria-hidden="true">2.4.</strong> Ladění</a></li></ol></li><li class="chapter-item "><a href="c/programovani.html"><strong aria-hidden="true">3.</strong> Programování v C</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/syntaxe.html"><strong aria-hidden="true">3.1.</strong> Syntaxe</a></li><li class="chapter-item "><a href="c/prikazy_vyrazy.html"><strong aria-hidden="true">3.2.</strong> Příkazy a výrazy</a></li><li class="chapter-item "><a href="c/promenne/promenne.html"><strong aria-hidden="true">3.3.</strong> Proměnné</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/promenne/globalni_promenne.html"><strong aria-hidden="true">3.3.1.</strong> Globální proměnné</a></li><li class="chapter-item "><a href="c/promenne/konstanty.html"><strong aria-hidden="true">3.3.2.</strong> Konstanty</a></li><li class="chapter-item "><a href="c/promenne/slozeny_zapis.html"><strong aria-hidden="true">3.3.3.</strong> Složený zápis</a></li><li class="chapter-item "><a href="c/promenne/pojmenovavani.html"><strong aria-hidden="true">3.3.4.</strong> Pojmenovávání proměnných</a></li></ol></li><li class="chapter-item "><a href="c/datove_typy/datove_typy.html"><strong aria-hidden="true">3.4.</strong> Datové typy</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/datove_typy/celociselne_typy.html"><strong aria-hidden="true">3.4.1.</strong> Celočíselné typy</a></li><li class="chapter-item "><a href="c/datove_typy/desetinne_typy.html"><strong aria-hidden="true">3.4.2.</strong> Desetinné číselné typy</a></li><li class="chapter-item "><a href="c/datove_typy/pravdivostni_typy.html"><strong aria-hidden="true">3.4.3.</strong> Pravdivostní typy</a></li></ol></li><li class="chapter-item "><a href="c/rizeni_toku/rizeni_toku.html"><strong aria-hidden="true">3.5.</strong> Řízení toku</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/rizeni_toku/podminky.html"><strong aria-hidden="true">3.5.1.</strong> Podmínky</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/rizeni_toku/switch.html"><strong aria-hidden="true">3.5.1.1.</strong> Příkaz switch</a></li></ol></li><li class="chapter-item "><a href="c/rizeni_toku/cykly.html"><strong aria-hidden="true">3.5.2.</strong> Cykly</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/rizeni_toku/while.html"><strong aria-hidden="true">3.5.2.1.</strong> Cyklus while</a></li><li class="chapter-item "><a href="c/rizeni_toku/for.html"><strong aria-hidden="true">3.5.2.2.</strong> Cyklus for</a></li></ol></li></ol></li><li class="chapter-item "><a href="c/funkce/funkce.html"><strong aria-hidden="true">3.6.</strong> Funkce</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/funkce/rekurze.html"><strong aria-hidden="true">3.6.1.</strong> Rekurze</a></li><li class="chapter-item "><a href="c/funkce/stdlib.html"><strong aria-hidden="true">3.6.2.</strong> Funkce standardní knihovny</a></li></ol></li><li class="chapter-item "><a href="c/preprocesor/preprocesor.html"><strong aria-hidden="true">3.7.</strong> Preprocesor</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/preprocesor/vkladani_souboru.html"><strong aria-hidden="true">3.7.1.</strong> Vkládání souborů</a></li><li class="chapter-item "><a href="c/preprocesor/makra.html"><strong aria-hidden="true">3.7.2.</strong> Makra</a></li></ol></li><li class="chapter-item "><a href="c/prace_s_pameti/prace_s_pameti.html"><strong aria-hidden="true">3.8.</strong> Práce s pamětí</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/prace_s_pameti/automaticka_pamet.html"><strong aria-hidden="true">3.8.1.</strong> Automatická paměť</a></li><li class="chapter-item "><a href="c/prace_s_pameti/ukazatele.html"><strong aria-hidden="true">3.8.2.</strong> Ukazatele</a></li><li class="chapter-item "><a href="c/prace_s_pameti/dynamicka_pamet.html"><strong aria-hidden="true">3.8.3.</strong> Dynamická paměť</a></li><li class="chapter-item "><a href="c/prace_s_pameti/globalni_pamet.html"><strong aria-hidden="true">3.8.4.</strong> Globální paměť</a></li></ol></li><li class="chapter-item "><a href="c/pole/pole.html"><strong aria-hidden="true">3.9.</strong> Pole</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/pole/staticke_pole.html"><strong aria-hidden="true">3.9.1.</strong> Statické pole</a></li><li class="chapter-item "><a href="c/pole/dynamicke_pole.html"><strong aria-hidden="true">3.9.2.</strong> Dynamické pole</a></li><li class="chapter-item "><a href="c/pole/vicerozmerne_pole.html"><strong aria-hidden="true">3.9.3.</strong> Vícerozměrné pole</a></li></ol></li><li class="chapter-item "><a href="c/text/text.html"><strong aria-hidden="true">3.10.</strong> Text</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/text/znaky.html"><strong aria-hidden="true">3.10.1.</strong> Znaky</a></li><li class="chapter-item "><a href="c/text/retezce.html"><strong aria-hidden="true">3.10.2.</strong> Řetězce</a></li></ol></li><li class="chapter-item "><a href="c/struktury/struktury.html"><strong aria-hidden="true">3.11.</strong> Struktury</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/struktury/struktury_funkce.html"><strong aria-hidden="true">3.11.1.</strong> Struktury a funkce</a></li></ol></li><li class="chapter-item "><a href="c/soubory.html"><strong aria-hidden="true">3.12.</strong> Soubory</a></li><li class="chapter-item "><a href="c/modularizace/modularizace.html"><strong aria-hidden="true">3.13.</strong> Modularizace</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/modularizace/knihovny.html"><strong aria-hidden="true">3.13.1.</strong> Knihovny</a></li></ol></li><li class="chapter-item "><a href="c/aplikovane_ulohy/ulohy.html"><strong aria-hidden="true">3.14.</strong> Aplikované úlohy</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="c/aplikovane_ulohy/tga.html"><strong aria-hidden="true">3.14.1.</strong> TGA</a></li><li class="chapter-item "><a href="c/aplikovane_ulohy/sdl.html"><strong aria-hidden="true">3.14.2.</strong> SDL</a></li></ol></li><li class="chapter-item "><a href="c/co_dal.html"><strong aria-hidden="true">3.15.</strong> Co dál?</a></li></ol></li><li class="chapter-item "><a href="ruzne/ruzne.html"><strong aria-hidden="true">4.</strong> Různé</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ruzne/rozklad_problemu.html"><strong aria-hidden="true">4.1.</strong> Rozklad problému</a></li><li class="chapter-item "><a href="ruzne/nahodna_cisla.html"><strong aria-hidden="true">4.2.</strong> Generování náhodných čísel</a></li><li class="chapter-item "><a href="ruzne/funkce_main.html"><strong aria-hidden="true">4.3.</strong> Funkce main</a></li></ol></li><li class="chapter-item "><a href="ulohy/ulohy.html"><strong aria-hidden="true">5.</strong> Úlohy</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ulohy/zaklady.html"><strong aria-hidden="true">5.1.</strong> Základy</a></li><li class="chapter-item "><a href="ulohy/ukazatele.html"><strong aria-hidden="true">5.2.</strong> Ukazatele</a></li><li class="chapter-item "><a href="ulohy/pole.html"><strong aria-hidden="true">5.3.</strong> Pole</a></li><li class="chapter-item "><a href="ulohy/dvourozmerne_pole.html"><strong aria-hidden="true">5.4.</strong> Dvourozměrné pole</a></li><li class="chapter-item "><a href="ulohy/retezce.html"><strong aria-hidden="true">5.5.</strong> Řetězce</a></li><li class="chapter-item "><a href="ulohy/ruzne.html"><strong aria-hidden="true">5.6.</strong> Různé</a></li></ol></li><li class="chapter-item "><a href="caste_chyby/caste_chyby.html"><strong aria-hidden="true">6.</strong> Časté chyby</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="caste_chyby/pametove_chyby.html"><strong aria-hidden="true">6.1.</strong> Paměťové chyby</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Úvod do programování</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/mrlvsb/upr-skripta" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#Úvod" id="Úvod">Úvod</a></h1>
<p>Tento text vznikl pro potřeby výuky předmětu <a href="https://github.com/geordi/upr-course">Úvod do programování</a> na FEI VŠB-TUO.
Slouží k získání přehledu o základních konceptech programovacího jazyka C.
Není však plnohodnotnou náhradou za poslechy přednášek a návštěvy cvičení a programovat vás (stejně
jako žádný jiný text) nenaučí, toho lze dosáhnout pouze opakovaným zkoušením a řešením různých úloh.
Studentům tedy silně doporučujeme, aby přednášky a cvičení navštěvovali a hlavně aby se věnovali programování
doma, alespoň několik hodin týdně.</p>
<p>V tomto textu naleznete stručný úvod o programování, překladu a ladění programů, nastavení prostředí
k editaci zdrojového kódu, a zejména popis základních konstrukcí jazyka <em>C</em> (proměnné, funkce, podmínky,
cykly, struktury, pole, ukazatele atd.) spolu se sadou úloh k procvičení jednotlivých témat. Pomocí
ikony <i class="fa fa-search"></i> vlevo nahoře můžete v textu rychle vyhledávat, pokud potřebujete
najít informace o konkrétním tématu.</p>
<p>Několik poznámek k textu:</p>
<ul>
<li>Tento text neslouží jako kompletní průvodce jazyka C. Pro takovýto účel lze doporučit některý
knižní titul, např. Učebnice jazyka <em>C</em> od Pavla Herouta nebo přímo standard jazyka <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">C99</a>.</li>
<li>Jelikož je předmět UPR zaměřen na vývoj v operačním systému Linux, tak ukázky kódu a příkazů v terminálu
předpokládají použití tohoto operačního systému (konkrétně distribuce <code>Ubuntu</code>).</li>
<li>Tento text je psán česky, nicméně primárním jazykem programování (celosvětově) je angličtina. Přeložené pojmy,
které mají zavedené anglické názvy, budou v tomto textu uvedeny v závorce <em>kurzívou</em>. Zdrojové kódy
silně doporučujeme psát v angličtině.</li>
<li>V tomto textu najdete různé ukázky <em>C</em> kódu. Některé z nich můžete sami upravovat a dokonce
i spustit rovnou v prohlížeči pomocí ikony <i class="fa fa-play"></i> v pravém horním rohu kódu.</li>
<li>Pokud v textu najdete gramatickou či faktickou chybu nebo budete mít jakoukoliv zpětnou vazbu
k obsahu či formě textu, dejte nám prosím vědět na <a href="mailto:jakub.beranek@vsb.cz?subject=UPR%20skripta%20-%20chyba">tento e-mail</a>
nebo vytvořte issue na <a href="https://github.com/mrlvsb/upr-skripta/issues/new">GitHubu</a>.</li>
</ul>
<p>Autory textu jsou <a href="https://github.com/geordi">Jan Gaura</a>, <a href="https://github.com/trnila">Dan Trnka</a> a
<a href="https://github.com/kobzol">Kuba Beránek</a>.</p>
<h1><a class="header" href="#programování" id="programování">Programování</a></h1>
<p>Programování je proces tvorby programu, tj. sady příkazů pro počítač, který slouží k vyřešení
nějakého konkrétního <strong>problému</strong>. Problémem se zde myslí nějaká úloha, kterou chceme vyřešit.
Takovéto úlohy obsahují nějaký (počítačem zpracovatelný) vstup, například:</p>
<ul>
<li>pohyb myši</li>
<li>stisk klávesy</li>
<li>zvuk z mikrofonu</li>
<li>textový soubor na disku</li>
</ul>
<p>a k nim určený výstup, například:</p>
<ul>
<li>vykreslení obrazce či textu na monitoru</li>
<li>zapsání dat do souboru na disku</li>
<li>odeslání informací přes síť</li>
</ul>
<p>Aby počítačový program korektně řešil nějakou úlohu, tak musí na všechny validní vstupy vrátit
správný výstup. Pokud vstup neodpovídá zadání, tak by měl program vrátit rozumnou chybovou hlášku
(a ne spadnout anebo ještě hůře pracovat s nevalidními daty). Postup pro řešení nějaké úlohy daný
jasně definovanými kroky se nazývá <strong>algoritmus</strong>. Zápisu (algoritmu) v nějakém konkrétním programovacím
jazyce se pak říká <strong>implementace</strong>.</p>
<p>Zde je příklad úloh, které se během semestru naučíte vyřešit pomocí jazyka C:</p>
<p><code>Spočítej průměr seznamu čísel.</code></p>
<p>nebo</p>
<p><code>Načti obrázek z disku, změň jeho velikost a ulož ho do jiného souboru.</code></p>
<p>Řešením podobných úloh si osvojíte základy programování a budete poté moct řešit zajímavější úlohy,
jako je například tvorba počítačové hry nebo aplikace komunikující přes internet.</p>
<h1><a class="header" href="#programovací-jazyky" id="programovací-jazyky">Programovací jazyky</a></h1>
<p>Z pohledu počítače je program sekvence příkazů (nazývaných <strong>instrukce</strong>), které může počítač vykonat
k vyřešení nějakého problému. Abychom mohli počítači říct, co má vykonávat, potřebujeme mu příkazy
zadat ve formě, které bude rozumět. Ač se to možná nezdá, tak počítače umí vykonávat pouze velmi
jednoduché příkazy. V podstatě umí pouze provádět aritmetické a logické operace (sečti/odečti/vynásob/vyděl)
s čísly a manipulovat (ukládat, kopírovat, přesouvat) s těmito čísly v paměti.
Veškeré složitější úkoly, jako třeba vykreslení obrázku na obrazovku, zapsání textu do dokumentu
nebo simulace světa v počítačové hře je výsledkem kombinací tisíců či milionů takovýchto jednoduchých
instrukcí.</p>
<p>Zde je ukázka jednoduchého programu, který zdvojnásobí číslo pomocí příkazů <code>MOV</code> a <code>ADD</code>: </p>
<pre><code class="language-x86asm">MOV EAX, 8
ADD EAX, EAX
</code></pre>
<p>Pokud bychom programy psali pomocí těchto jednoduchých příkazů, tak by bylo složité se v nich vyznat,
obzvláště, pokud by obsahovaly stovky, tisíce nebo dokonce miliony takovýchto příkazů.
Ideálně bychom chtěli programy zapisovat v přirozeném jazyce (<code>Vykresli čtverec na obrazovku</code>,
<code>Zapiš text do dokumentu</code>), nicméně tomu počítače nerozumí a je velmi náročné
jej převést na správnou sekvenci příkazů pro počítač, protože jazyky, které používáme,
jsou často nejednoznačné a nemají jednotnou strukturu.</p>
<p>Jako kompromis tak vznikly <strong>programovací jazyky</strong>, které umožňují zápis programů ve formě, která je
lidem srozumitelná, ale zároveň ji lze relativně jednoduše převést na příkazy, které je schopen počítač
provést. Převodu programu zapsaného v programovacím jazyce na počítačové instrukce se říká <strong>překlad</strong>
(<em>compilation</em>) a programy, které tento překlad provádějí, se nazývají <strong>překladače</strong> (<em>compilers</em>).
Později si ukážeme, jak takovýto překladač použít k překladu kódu.</p>
<p>Zde je ukázka programu v jazyce C:</p>
<pre><code class="language-c">while (is_key_pressed(SPACE)) {
    move_up(character);
}
</code></pre>
<p>I někdo, kdo se s jazykem <em>C</em> nikdy nesetkal, může z tohoto programu zhruba odvodit, co asi dělá,
pokud ho přečte jako větu v angličtině. Tento program však může být převeden na stovky až tisíce
počítačových instrukcí a z takového množství příkazů už by bylo složité odvodit, k čemu je program
určen.</p>
<h1><a class="header" href="#jazyk-c" id="jazyk-c">Jazyk C</a></h1>
<p>Existuje nespočet programovacích jazyků, například Python, Java, C#, PHP či Javascript. Každý z nich
má své výhody a nevýhody a záleží na konkrétním problému, který je třeba vyřešit, pro zvolení
vhodného programovacího jazyka.</p>
<p>V tomto kurzu se budeme zabývat pouze programovacím jazykem <strong>C</strong>. Tento jazyk vytvořili
Dennis Ritchie a Ken Thompson v laboratořích firmy Bell v roce 1972, tedy již před
téměř 50 lety, a za tu dobu nedočkal mnoha výrazných změn.</p>
<p>I když pro něj v dnešní době asi nenaleznete mnoho pracovních nabídek a není primární
volbou pro tvorbu webových či mobilních aplikací, vyplatí se mu rozumět a umět ho používat, a to
hned z několika důvodů:</p>
<ul>
<li>Jazyk <em>C</em> lze použít na téměř všech existujících platformách a je tak
velmi univerzálním jazykem. Téměř veškerý existující software obsahuje kusy kódu v jazyce C. Operační systémy (Linux,
OS X, Windows, Android, iOS), prohlížeče (Chrome, Firefox, Edge), multimediální programy (Photoshop,
Powerpoint, Word, BitTorrent), hry (World of Warcraft, Quake, Doom, Call of Duty, League of Legends,
DOTA 2, Fortnite), vestavěná zařízení (mikročipy, pračky, řídící jednotky vesmírných letadel nebo aut).
Všechny tyto věci jsou buď z části anebo zcela poháněné jazykem C.</li>
<li>Je to jednoduchý jazyk, který neobsahuje velké množství funkcionalit, které lze naleznout ve většině
modernějších jazyků. Díky tomu se dá naučit za jeden semestr.</li>
<li>Jeho úroveň abstrakce není o mnoho výše než základní počítačové instrukce. Při výuce <em>C</em> tak lze zároveň
pochopit, jak funguje počítač a operační systém. Díky tomu lze také při správném zacházení psát velmi
efektivní programy (to ale nicméně není obsahem tohoto kurzu). </li>
<li><strong>Syntaxe</strong> (způsob zápisu) jazyka <em>C</em> ovlivnila velké množství jazyků, které vznikly po něm. Jakmile se
ji naučíte, tak budete schopni rozumět syntaxi většiny současných nejpoužívanějších jazyků (C++, C#,
Java, Kotlin, Javascript, PHP, Rust, ...). </li>
</ul>
<p>Jazyk <em>C</em> má samozřejmě také řadu nevýhod. Vzhledem k jeho stáří a omezené sadě funkcionalit je často
značně pracnější a zdlouhavější pomocí něho dosáhnout stejného výsledku než u modernějších programovacích
jazyků. Nevede také programátory za ručičku – při psaní programu v jazyce <em>C</em> je velmi jednoduché udělat
chybu, která může způsobit v lepším případě pád programu, v horším případě může běžící program poškodit
tak, že začne vydávat chybný výstup nebo se začně chovat nepředvídatelně.</p>
<p>Tyto chyby se můžou projevit jen někdy, nebo jenom na určité kombinaci hardwaru či operačního systému,
a programátor na ně není často nijak upozorněn a musí je najít ručně zkoumáním
zdrojového kódu. Podobný typ chyb je také nejčastějším zdrojem bezpečnostních děr ve všech možných softwarech,
které (jak už víme) téměř vždy obsahují alespoň část kódu napsaného v &quot;Céčku&quot;.</p>
<p>Zde je vybraný seznam populárních programů napsaných v jazyce C, které jsou <strong>open-source</strong>, takže
si jejich zdrojový kód můžete prohlédnout a v případě potřeby i modifikovat:</p>
<ul>
<li><a href="https://github.com/torvalds/linux">Linux</a> (operační systém)</li>
<li><a href="https://github.com/id-Software/Quake-III-Arena">Quake III</a> (počítačová hra)</li>
<li><a href="https://github.com/git/git">git</a> (verzovací systém)</li>
<li><a href="https://github.com/php/php-src">PHP</a> (překladač/interpret jazyka PHP)</li>
<li><a href="https://github.com/obsproject/obs-studio">OBS Studio</a> (streamovací software)</li>
</ul>
<h1><a class="header" href="#paměť" id="paměť">Paměť</a></h1>
<p>Počítače si potřebují ukládat (mezi)výsledky výpočtů do paměti, aby je později mohly opět
načíst a pracovat s nimi. Je mnoho typů paměti, s kterými lze pracovat, nejběžněji se setkáme
s tzv. operační pamětí (<strong>RAM</strong>). RAM znamená Random-access Memory, tedy paměť s náhodným přístupem.
To znamená, že počítač může do paměti šahat v libovolném pořadí a na libovolném místě, kde je to potřeba.</p>
<h3><a class="header" href="#reprezentace-hodnot-v-paměti" id="reprezentace-hodnot-v-paměti">Reprezentace hodnot v paměti</a></h3>
<p>Počítačová paměť uchovává informace v buňkách, které obsahují jedno číslo, které může obsahovat
256 různých hodnot. To vychází z toho, že informace je reprezentována <strong>bity</strong>, jednotkou informací,
která může nabývat pouze dvě hodnoty - pravda (<em>true</em>) nebo nepravda (<em>false</em>). Každá buňka
paměti obsahuje jeden <strong>byte</strong>, neboli 8 bitů.</p>
<p>Pracuje se zde s dvojkovou (binární) soustavou, pokud tedy máme k dispozici <em>n</em> bitů, tak pomocí nich
můžeme reprezentovat \( 2^n \) hodnot. Např. s dvěma bity můžeme reprezentovat 4 různé hodnoty
(00, 01, 10, 11). Více o binární soustavě a bytech se dozvíte v předmětu
<a href="https://edison.sso.vsb.cz/cz.vsb.edison.edu.study.prepare.web/SubjectVersion.faces?version=440-2104/01&amp;subjectBlockAssignmentId=375761&amp;studyFormId=2&amp;studyPlanId=22001&amp;locale=cs&amp;back=true">Základy číslicových systémů (ZDS)</a>.</p>
<p>I když paměť vždy obsahuje čísla v dvojkové soustavě, je důležité si uvědomit, že význam těmto číslům
přiřazujeme my, tedy programátoři a uživatelé počítače. Pokud je v paměti číslo <strong>65</strong>, tak může
reprezentovat například:</p>
<ul>
<li>počet získaných bodů studenta (interpretujeme jej jako celé nezáporné číslo)</li>
<li>písmeno <code>A</code> v nějakém dokumentu (interpretujeme jej jako znak v kódování <a href="https://www.asciitable.com/">ASCII</a>)</li>
<li>tmavě šedý pixel (interpretujeme jej jako barvu)</li>
</ul>
<p>Hodnotu <strong>255</strong> uloženou v <em>bytu</em> paměti můžeme například vnímat jako celé nezáporné číslo
(<em>unsigned integer</em>) <strong>255</strong>, anebo jako celé číslo se znaménkem (<em>signed integer</em>) <strong>-1</strong> v
<a href="https://cs.wikipedia.org/wiki/Dvojkov%C3%BD_dopln%C4%9Bk">dvojkovém doplňku</a>.</p>
<p>Čísla v paměti sama o sobě nemají žádný význam, záleží pouze na tom, jak je my, a obzvláště naše programy,
interpretují a jaké operace nad nimi provádějí.</p>
<h3><a class="header" href="#adresování-paměti" id="adresování-paměti">Adresování paměti</a></h3>
<p>Abychom se mohli odkazovat na hodnoty v paměti, tak musíme mít možnost rozlišit jednotlivé buňky od sebe.
Toho dosáhneme pomocí <strong>adresy</strong>. Paměť je adresována tak, že každá paměťová buňka (každý <em>byte</em>)
má číselnou adresu od 0 do velikosti paměti (nevčetně). Velmi zjednodušeně řečeno, pokud máte RAM
paměť o velikosti 8 GiB (8589934592 &quot;bajtů&quot;), tak můžete adresovat buňky od 0 do 8589934591<sup class='margin-toggle sidenote-number'>1</sup>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Programy běžně nemají přístup k celé paměti počítače (mimo jiné z bezpečnostních důvodů).
Váš operační systém používá tzv. <strong>virtuální paměť</strong>, která každému běžícímu programu přiděluje
určité rozsahy paměti, s kterými může pracovat. Více se dozvíte v předmětu
<a href="http://poli.cs.vsb.cz/edu/osy/">Operační systémy</a>. </p>
</span>
<p>Pokud byste programovali počítač přímo pomocí instrukcí, tak mu můžete dát například instrukci
<code>Nastav byte na adrese 58 na hodnotu 5</code> nebo <code>Přečti 4 byty začínající na adrese 1028</code>.
Při programování v <em>C</em> ovšem často budou adresy skryté na pozadí a bude se o ně starat překladač,
my se budeme na konkrétní úsek paměti obvykle odkazovat jménem, které mu přiřadíme.</p>
<h1><a class="header" href="#nastavení-prostředí" id="nastavení-prostředí">Nastavení prostředí</a></h1>
<p>Abyste mohli programovat v C, musíte si nainstalovat, nakonfigurovat a naučit se používat
sadu programů. V této kapitole je stručný popis toho, jak si nastavit
<a href="prostredi/linux.html">operační systém Linux</a>, <a href="prostredi/editor.html">textový editor</a>
k psaní programů, <a href="prostredi/preklad_programu.html">překladač</a> pro překlad z jazyka <em>C</em> do spustitelného souboru
a také jak <a href="prostredi/ladeni.html">řešit chyby</a> při psaní programů.</p>
<h1><a class="header" href="#linux" id="linux">Linux</a></h1>
<p>Jak už bylo zmíněno v <a href="prostredi/../uvod/uvod.html">úvodu</a>, v UPR budeme psát a spouštět programy v operačním
systém <a href="https://en.wikipedia.org/wiki/Linux">Linux</a>. Je tak nutné, abyste si na svém počítači
tento operační systém zprovoznili.</p>
<p>Pokud používáte operační systém OS X, tak teoreticky Linux instalovat nemusíte, stačí si nastavit
překladač <a href="https://www.cyberciti.biz/faq/howto-apple-mac-os-x-install-gcc-compiler/"><code>gcc</code></a>.</p>
<p>Pokud používáte operační systém Windows, tak pro použití Linuxu můžete využít jeden z následujících
tří možností.</p>
<h2><a class="header" href="#windows-subsystem-for-linux-doporučeno" id="windows-subsystem-for-linux-doporučeno">Windows Subsystem for Linux (doporučeno)</a></h2>
<p>WSL je systém, který umožňuje nainstalovat Linux pod operačním systémem Windows. Jakmile jej
nainstalujete, budete mít k dispozici Linuxový terminál (<code>bash</code>) a budete moct používat překladač
<a href="prostredi/preklad_programu.html">gcc</a> a editor <a href="prostredi/editor.html">Visual Studio Code</a>. Výhoda tohoto řešení je, že
pro použití Linuxu nemusíte restartovat počítač ani zapínat virtuální stroj, Linux je v podstatě
jenom &quot;další aplikace&quot; pod Windows.</p>
<p>Návod pro zprovoznění WSL spolu s prostředím pro vývoj v jazyce <em>C</em> naleznete
<a href="https://code.visualstudio.com/docs/cpp/config-wsl">zde</a>. Při instalaci WSL používejte distribuci
<code>Ubuntu 20.04</code>.</p>
<h2><a class="header" href="#virtualizovaný-linux" id="virtualizovaný-linux">Virtualizovaný Linux</a></h2>
<p>Linux můžete také používat ve virtualizované podobě pomocí
<a href="https://cs.wikipedia.org/wiki/Virtu%C3%A1ln%C3%AD_stroj">virtuálního stroje</a>. Připravili jsme pro
vás tzv. obraz virtuálního stroje, který obsahuje již nastavený Linux, konkrétně <code>Ubuntu 20.04</code>,
se vším potřebným pro předmět UPR.</p>
<p>Abyste jej mohli použít, tak si nejprve musíte nainstalovat virtualizační program
<a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a>. Poté si
<a href="http://mrl.cs.vsb.cz/data/upr/UPR.ova">předpřipravený obraz</a> stáhněte, otevřete ho ve VirtualBoxu
a potvrďte import s výchozím nastavením.</p>
<p>Virtuální počítač poté bude možné spustit z programu VirtualBox. Uživatelské jméno i heslo je
<code>student</code>.</p>
<h2><a class="header" href="#nativní-instalace-linuxu" id="nativní-instalace-linuxu">Nativní instalace Linuxu</a></h2>
<p>Nejspolehlivější variantou použití Linuxu je nainstalovat si ho přímo &quot;na železo&quot;, tj. bez
virtualizace. Můžete jej například nastavit v režimu
<a href="https://www.tecmint.com/install-ubuntu-alongside-with-windows-dual-boot/">dual boot</a>, kdy se při
startu počítače můžete rozhodnout, zdali se nabootuje do Windows (či jiného operačního systému)
nebo do Linuxu. Pokud jste s Linuxem nikdy nepracovali, tak doporučujeme použít Linuxovou
<a href="https://itsfoss.com/install-ubuntu/">distribuci Ubuntu</a> ve verzi <code>20.04</code>.</p>
<h1><a class="header" href="#vývojové-prostředí" id="vývojové-prostředí">Vývojové prostředí</a></h1>
<p>Abychom mohli přeložit a spustit nějaký program, musíme ho obvykle nejprve zapsat do
jednoho nebo více souborů ve formě tzv. <strong>zdrojového kódu</strong> (<em>source code</em>). K usnadnění tohoto procesu
existují <strong>textové editory</strong> a <strong>vývojová prostředí</strong> jako například <code>MS Visual Studio</code>, <code>QtCreator</code>, <code>JetBrains CLion</code>,
<code>CodeBlocks</code>, <code>Visual Studio Code</code>, <code>vim</code>, <code>emacs</code> apod. Tyto programy usnadňují psaní kódu pomocí zvýrazňování
syntaxe, automatizace překladu, spouštění a testování programů a také správy projektů.</p>
<p>Na cvičeních UPR budeme používat editor <code>Visual Studio Code</code>, který je
<a href="https://code.visualstudio.com/">dostupný zdarma</a>. Níže je stručný návod k jeho použití. Při
programování se hodí detailně znát a efektivně využívat editor, který používáte, ale pro začátek
nám budou stačit naprosté základy.</p>
<h2><a class="header" href="#instalace-potřebných-rozšíření-pomocí-terminálu" id="instalace-potřebných-rozšíření-pomocí-terminálu">Instalace potřebných rozšíření (pomocí terminálu)</a></h2>
<p>VSCode podporuje programovací jazyky pomocí rozšíření, po první instalaci VSCode
tak nejprve musíme nainstalovat potřebná rozšíření pro jazyk C. V terminálu spusťte tyto příkazy:</p>
<pre><code class="language-bash">$ code --install-extension ms-vscode.cpptools
</code></pre>
<blockquote>
<p>Návod pro práci s terminálem na Linuxu můžete najít např. <a href="https://wiki.ubuntu.cz/syst%C3%A9m/p%C5%99%C3%ADkazov%C3%A1_%C5%99%C3%A1dka/termin%C3%A1l">zde</a>.
Tahák pro příkazy terminálu najdete <a href="https://github.com/geordi/upr-course/blob/master/assets/cheatsheets/linux.pdf">zde</a>.</p>
</blockquote>
<h2><a class="header" href="#instalace-potřebných-rozšíření-pomocí-uživatelského-rozhraní" id="instalace-potřebných-rozšíření-pomocí-uživatelského-rozhraní">Instalace potřebných rozšíření (pomocí uživatelského rozhraní)</a></h2>
<ol>
<li>Otevřete obrazovku rozšíření (<code>Ctrl+Shift+X</code> nebo spusťte akci <code>Install Extensions</code>)</li>
<li>Vyhledejte rozšíření C/C++ a nainstalujte ho</li>
</ol>
<h2><a class="header" href="#ukázka-nastavení-projektu" id="ukázka-nastavení-projektu">Ukázka nastavení projektu</a></h2>
<p>Jako vzorový projekt můžete použít <a href="https://github.com/geordi/upr-course/tree/master/faq/vscode-template-project">tuto</a>
šablonu.</p>
<p><img src="prostredi/../static/video/vsc_first_run.gif" alt="Nastavení VSCode" /></p>
<h2><a class="header" href="#užitečné-zkratky" id="užitečné-zkratky">Užitečné zkratky</a></h2>
<ul>
<li>Spustit program - <code>F5</code></li>
<li>Naformátovat kód - <code>Ctrl + Shift + I</code></li>
<li>Zobrazit vyhledávač akcí - <code>Ctrl + Shift + P</code></li>
</ul>
<h1><a class="header" href="#překlad-programu" id="překlad-programu">Překlad programu</a></h1>
<p>Pro překlad programu z jazyka <em>C</em> do <strong>spustitelného</strong> (<em>executable</em>) souboru
budeme používat jiný program, kterému se říká překladač.
Překladačů jazyka <em>C</em> existuje celá řada, my budeme využívat asi nejpoužívanější překladač pro
Linuxové systémy s názvem <a href="https://gcc.gnu.org/"><strong>GCC</strong></a> (GNU Compiler Collection). </p>
<p>Překladač <code>gcc</code>, spolu s dalšími potřebnými nástroji na Ubuntu můžete nainstalovat následujícím
příkazem:</p>
<pre><code class="language-bash">sudo apt install build-essential
</code></pre>
<h2><a class="header" href="#překlad-prvního-programu" id="překlad-prvního-programu">Překlad prvního programu</a></h2>
<p>Ještě než si ukážeme, jak vlastně programovací jazyk <em>C</em> funguje, tak zkusíme přeložit velmi jednoduchý
C program do spustitelného souboru a spustit jej.
Vytvořte soubor s názvem <code>main.c</code> a nakopírujte do něj následující <em>C</em> kód (později si vysvětlíme,
jak tento kód funguje):</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Hello world!\n&quot;);
    return 0;
}
</code></pre>
<blockquote>
<p>Tento program se nazývá <code>Hello world</code>, jelikož tento text vypíše na obrazovku.
Podobný jednoduchý program je obvykle tím prvním, co programátor v nějakém novém programovacím
jazyce vytvoří.</p>
</blockquote>
<p>Nyní otevřete terminál (<code>Ctrl + Alt + T</code> v Ubuntu) ve složce s tímto souborem, spusťte program
<code>gcc</code> a předejte mu cestu k tomuto souboru:</p>
<pre><code class="language-bash">$ gcc main.c -o program
</code></pre>
<p>Tímto příkazem řeknete &quot;Gécécéčku&quot;, aby přeložil zdrojový soubor <code>main.c</code> a uložil výsledný spustitelný
soubor do souboru <code>program</code>. Pokud byste přepínač <code>-o &lt;nazev souboru&gt;</code> nepoužili, tak se vytvoří spustitelný
soubor s názvem <code>a.out</code>. </p>
<blockquote>
<p>Na Windowsu spustitelné soubory mají obvykle příponu <code>.exe</code>, na Linuxu to však není běžnou praxí
a spustitelné soubory typicky žádnou příponu nemají.</p>
</blockquote>
<p>Pokud chcete nyní program spustit, stačí v terminálu zadat (relativní) cestu k danému spustitelnému souboru.</p>
<pre><code class="language-bash">$ ./program
Hello world!
</code></pre>
<p>Program by měl na výstup vytisknout text <code>Hello world!</code>.</p>
<details>
<summary>Tipy pro práci s příkazovou řádkou</summary>
<ul>
<li>Obvykle budete chtít po změně v programu provést překlad a pak program spustit. Abyste to provedli
v jednom terminálovém příkazu, můžete tyto dva příkazy spojit pomocí <code>&amp;&amp;</code>:
<pre><code class="language-bash">$ gcc main.c -o main &amp;&amp; ./main
</code></pre>
Pokud překlad proběhne úspěšně, tak operátor <code>&amp;&amp;</code> zajistí spuštění následujícího příkazu.</li>
<li>Pokud nechcete příkazy v terminálu psát neustále dokola, šipkou nahoru (↑) můžete vyvolat nedávno
spuštěné příkazy v terminálu.</li>
</ul>
</details>
<p>Pro představu je k dispozici ješte shrnující video:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Hu7l9NpQ3g8" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h3><a class="header" href="#jak-překlad-probíhá" id="jak-překlad-probíhá">Jak překlad probíhá?</a></h3>
<p>Překlad programů probíhá ve dvou hlavních fázích: <strong>překlad</strong> (<em>translation</em>) a <strong>linkování</strong> (<em>linking</em>).
Dohromady se oboum těmto krokům také říká <strong>kompilace</strong> (<em>compilation</em>).</p>
<p>Při překladu překladač vezme každý <em>C</em> zdrojový soubor, který mu předložíme, a samostatně jej přeloží
do tzv. <strong>objektového souboru</strong> (<em>object file</em>). Takovýto soubor obsahuje již přeložené instrukce pro
procesor, ale není sám o sobě spustitelný, tj. nejedná se o program, ale pouze o přeložený binární kód.</p>
<p>Jakmile jsou všechny zdrojové soubory přeloženy do objektových souborů, tak přichází na řadu další
program, tzv. <strong>linker</strong>, který tyto objektové soubory spojí dohromady,
<a href="https://cs.wikipedia.org/wiki/Linker#Funkce_linkeru">propojí</a> je dle potřeby, případně k nim připojí
externí <a href="prostredi/../c/knihovny.html">knihovny</a> a na konci vytvoří finální spustitelný soubor, který lze poté
spustit.</p>
<p>Když použijete program <code>gcc</code> způsobem, jaký jsme si ukázali výše, tak se na pozadí spustí překladač
a poté i linker a oba dva tyto kroky se tak provedou automaticky. Je ale možné provést je i separátně:</p>
<pre><code class="language-bash">$ gcc -c main.c      # vytvoří objektový soubor main.o
$ gcc main.o -o main # slinkování souboru main.o 
</code></pre>
<h1><a class="header" href="#ladění-programů" id="ladění-programů">Ladění programů</a></h1>
<p>Tato sekce slouží k řešení často se vyskytujících problémů při programování v C. Pokud váš program
padá při běhu nebo se nechová tak, jak má, tak v něm nejspíše máte nějakou chybu (tzv. <strong>bug</strong>).
Proces hledání chyby, která způsobuje pád nebo špatné chování programu se pak nazývá <strong>ladění</strong> (<em>debugging</em>).</p>
<h3><a class="header" href="#chyby-při-překladu-programu" id="chyby-při-překladu-programu">Chyby při překladu programu</a></h3>
<p>Pokud váš program nelze přeložit a překladač vypisuje nějakou chybovou hlášku, tak máte v zápisu programu
nějakou chybu, obvykle v syntaxi, tedy zápisu kódu. Je dobré si danou chybovou hlášku pořádně přečíst,
obvykle se odkazuje na relativně přesné místo, kde máte kód špatně, a někdy dokonce i nabízí řešení,
jak problém vyřešit.</p>
<p>Při překladu můžete dostat například následující chybovou hlášku:</p>
<pre><code class="language-bash">main.c: In function ‘main’:
main.c:2:2: error: ‘a’ undeclared (first use in this function)
    2 |  a = 0;
</code></pre>
<p>Tato konkrétní chyba byla způsobena tím, že byla použitá proměnná bez její předchozí deklarace. Pokud
chybě nerozumíte, zkuste ji nejprve vygooglit, ideálně pouze část, která není konkrétně závislá na
podobě vašeho projektu. Nemá cenu googlit <code>main.c:2:2</code>, protože tento text je závislý na tom, jak jste
si pojmenovali své soubory, ostatní programátoři nejspíše mají jiné názvy souborů. V případě této chyby
by tedy bylo lepší googlit text <code>error: undeclared (first use in this function)</code>.</p>
<p>Může se stát, že překladač vypíše více chybových hlášek zároveň, i když chyba
v programu je pouze jedna. Zkuste scrollovat výstupem hlášek nahoru, abyste zjistili, která chyba
byla vypsána jako první, zbytek výpisu může být &quot;planý poplach&quot;.</p>
<p>Pokud se vám nedaří chybu vygooglit, tak kontaktujte svého cvičícího.</p>
<p>Při překladu můžete použít dodatečné přepínače, při jejichž použití vydá překladač více varování o
možných problémových místech ve vašem kódu:</p>
<pre><code class="language-bash">$ gcc -Wall -Wextra -pedantic main.c -o program
</code></pre>
<h3><a class="header" href="#chyby-při-běhu-programu" id="chyby-při-běhu-programu">Chyby při běhu programu</a></h3>
<p>Pokud váš program padá při běhu, můžete zkusit následující způsoby ladění:</p>
<h4><a class="header" href="#address-sanitizer" id="address-sanitizer">Address sanitizer</a></h4>
<p>Tento nástroj modifikuje váš program tak, aby dokázal detekovat značné množství chyb při jeho běhu,
a pokud nějakou chybu najde, tak váš program okamžitě ukončí a popíše, k jakému problému došlo. </p>
<pre><code class="language-bash">$ gcc -g -fsanitize=address main.c -o program
</code></pre>
<p>Jakmile takto přeložený program spustíte a dojde k nějaké chybě, tak bude její popis vypsán na výstup.</p>
<p>Pokud se chyba opraví těsně po svém vzniku, je to mnohem jednodušší, než když se chyba projeví až
později v úplně jiné části kódu. <strong>Doporučujeme tak vždy používat Address Sanitizer při vývoji programů v C</strong>.
Ušetříte si tak spoustu času a námahy při ladění chyb.</p>
<h4><a class="header" href="#logování" id="logování">Logování</a></h4>
<p>Jedním z nejjednodušších způsobů, jak se dozvědět, co se v programu děje, je jednoduše tisknout
hodnoty zajímavých proměnných na výstup programu. Pokud přidáte takovýto výstup na různá místa v kódu,
můžete pak podle výstupu zpětně rekonstruovat, co se při běhu programu dělo.</p>
<h4><a class="header" href="#krokování" id="krokování">Krokování</a></h4>
<p>Pro interaktivnější zkoumání chování programů je možné je tzv. <strong>krokovat</strong>. K tomu je potřeba nástroj,
který umí program pozastavit při jeho běhu a zobrazit uživateli, co se v něm děje. Takovéto nástroje se nazývají
<strong>debuggery</strong>. Při krokování se program zastaví na určitém místě (řádku) v kódu, a programátor pak může
zkoumat hodnoty proměnných a spouštět program řádek po řádku.</p>
<p>Pro vás je nejjednodušší použít krokování integrované ve VSCode:</p>
<ul>
<li>Klikněte na sloupeček vlevo od čísla řádku, na kterém chcete, aby se program zastavil.
Objeví se tam červené kolečko (tzv. <strong>breakpoint</strong>).</li>
<li>Spusťte program s laděním (<code>F5</code>). Program by se na řádku s breakpointem měl zastavit.</li>
<li>Ve sloupci <code>Variables</code> v levé části VSCode můžete prozkoumat hodnoty proměnných.</li>
<li>Pomocí příkazu <code>Step Over</code> (<code>F10</code>) program vykoná následující řádek a poté se opět zastaví. Pokud
nechcete přeskakovat volání funkcí, použijte <code>Step Into</code> (<code>F11</code>).</li>
</ul>
<p><video src="../static/video/debugging.webm" controls></video></p>
<blockquote>
<p>VSCode používá pro ladění vašeho programu debugger <code>gdb</code>. Pokud ho chcete použít manuálně, návod
můžete najít například <a href="https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu-pouziti-gdb-a-jeho-nadstaveb/">zde</a>.</p>
</blockquote>
<h1><a class="header" href="#programování-v-c" id="programování-v-c">Programování v <em>C</em></a></h1>
<p>V této kapitole naleznete popis základních konstrukcí jazyka <em>C</em>, které jsou základními
stavebními kameny pro tvorbu programů. Ke každému tématu je k dispozici také úloh. Pokud úlohy
zvládnete vypracovat, tak budete mít jistotu, že jste dané téma pochopili a můžete se posunout dále.
Pokud nezvládnete úlohy splnit, tak můžete mít s dalšími koncepty problém. Pokud nebudete stíhat,
tak kontaktujte svého cvičícího.</p>
<p>Před přečtením této kapitoly si přečtěte sekci o <a href="c/../uvod/pamet.html">paměti</a>.</p>
<p>Zde je přibližný seznam témat, které si během semestru ukážeme. Pořadí témat probíraných na cvičení
a přednáškách se může od tohoto seznamu lišit, tento text je určen spíše jako &quot;kuchařka&quot;, ve které
se můžete k jednotlivým tématům vracet, abyste si je připomněli. Text je nicméně psaný tak, aby se
dal zhruba číst v uvedeném pořadí bez toho, aby používal pojmy, které zatím nebyly vysvětleny.</p>
<p>Základní témata:</p>
<ul>
<li><a href="c/syntaxe.html">Úvod</a> - základní syntaxe a komentáře</li>
<li><a href="c/prikazy_vyrazy.html">Příkazy a výrazy</a> - jak provádět výpočty</li>
<li><a href="c/promenne/promenne.html">Proměnné</a> - jak něco uložit a načíst z paměti paměti</li>
<li><a href="c/datove_typy/datove_typy.html">Datové typy</a> - jak pracovat s daty v paměti</li>
<li><a href="c/rizeni_toku/rizeni_toku.html">Řízení toku</a> - jak se rozhodovat a provádět akce opakovaně</li>
<li><a href="c/funkce/funkce.html">Funkce</a> - jak opakovaně využít a parametrizovat opakující se kód</li>
<li><a href="c/prace_s_pameti/ukazatele.html">Ukazatele</a> - jak sdílet data v paměti a pracovat s adresami</li>
<li><a href="c/pole/pole.html">Pole</a> - jak jednotně pracovat s velkým množstvím dat</li>
<li><a href="c/text/text.html">Text</a> - jak v programech reprezentovat text</li>
<li><a href="c/struktury/struktury.html">Struktury</a> - jak seskupit data do logicky souvisejících celků</li>
<li><a href="c/soubory.html">Soubory</a> - jak číst a zapisovat soubory</li>
<li><a href="c/modularizace/modularizace.html">Modularizace</a> - jak rozdělit program do více zdrojových souborů</li>
<li><a href="c/modularizace/knihovny.html">Knihovny</a> - jak využít existující kód od jiných programátorů</li>
</ul>
<p>Všechny tyto koncepty jsou velmi univerzální a v tzv. <a href="https://cs.wikipedia.org/wiki/Imperativn%C3%AD_programov%C3%A1n%C3%AD">imperativních</a>
programovacích jazycích jsou v podstatě všudypřítomné. Jakmile se je jednou naučíte, tak je budete
moct využívat téměř v libovolném populárním programovacím jazyku (Java, C#, Kotlin, Python, PHP,
Javascript, Rust, C++ atd.). </p>
<p>Navazující témata:</p>
<ul>
<li><a href="c/aplikovane_ulohy/tga.html">TGA</a> - jednoduchý formát pro reprezentaci obrázků na disku</li>
<li><a href="c/aplikovane_ulohy/sdl.html">SDL</a> - knihovna pro tvorbu grafických aplikací a her</li>
</ul>
<h1><a class="header" href="#základy-syntaxe" id="základy-syntaxe">Základy syntaxe</a></h1>
<p>C je (programovací) jazyk a jako každý jazyk má svá pravidla, které je nutno dodržovat.
Například v češtině musíme dodržovat určitá pravidla a zvyklosti, abychom byli schopni výsledný
text pochopit. Věty <code>jsme, M y máma, táta a</code> nebo <code>.o dku  d! ty z, jsi</code> nedávají smysl,
protože obsahují interpunkční znaménka na špatných místech, větné členy jsou ve špatném pořadí
a některá slova obsahují mezery na místech, kam nepatří. Stejně tak v jazyce <em>C</em> můžete velmi jednoduše
napsat program, kterému <a href="c/../prostredi/preklad_programu.html">překladač</a> nebude rozumět a překlad poté skončí se
syntaktickou chybou (<em>syntax error</em>). Na syntax <em>C</em> si musíte postupně zvyknout, poté už podobné chyby
budete schopni snadno vyřešit.</p>
<p>Zde je asi nejkratší možný program v jazyce C:</p>
<pre><code class="language-c">int main() {
    return 0;
}
</code></pre>
<p>V programu výše je pouze <a href="c/funkce/funkce.html">funkce</a> s názvem <code>main</code>. Funkce si popíšeme později, prozatím
budeme psát kód vždy do funkce <code>main</code> (před <code>return 0;</code>). Jednotlivé prvky programu si postupně vysvětlíme
v následujících sekcích, prozatím si však všimněte, že <strong>bílé znaky</strong> (<em>whitespace</em>)<sup class='margin-toggle sidenote-number'>1</sup> jsou obvykle
překladačem ignorovány. Například</p>
<span class='sidenote'><p><sup class='number'>1</sup><a href="https://cs.wikipedia.org/wiki/B%C3%ADl%C3%BD_znak">Bílé znaky</a> jsou (neviditelné) znaky,
které reprezentují mezery v textu, tj. odřádkování, mezerník, tabulátor atd.</p>
</span>
<pre><code class="language-c">int 


main()                 {
    
    
    return         0;
}

</code></pre>
<p>reprezentuje úplně stejný program. Nicméně asi sami uznáte, že pokud bychom s bílými znaky nakládali
takto nerozvážně, tak by zdrojový kód byl pro lidi špatně čitelný. Proto doporučujeme formátování provádět
automaticky ve <a href="c/../prostredi/editor.html">VSCode</a> pomocí zkratky <code>Ctrl + Shift + I</code>, ať nad ním nemusíte přemýšlet.</p>
<p>Bílé znaky nicméně nejsou ignorovány úplně na všech místech. Například v <a href="c/text/retezce.html">řetězcích</a>
jsou bílé znaky brány jako součást textu. Nemůžete také rozdělovat mezerami názvy (např. <code>in t</code> nebo
<code>ma in</code> z programu výše by způsobily chybu při překladu).</p>
<h3><a class="header" href="#komentáře" id="komentáře">Komentáře</a></h3>
<p>Abychom mohli v následujících sekcích popisovat kusy kódu, ukážeme si teď <strong>komentáře</strong>. Jedná se
o text ve zdrojovém kódu, který je určen pro programátory, ne pro překladač, který je zcela ignoruje.
Bez komentářů bychom nemohli do zdrojového kódu dodávat poznámky, protože překladač by jinak měl snahu
je interpretovat jako <em>C</em> kód. Komentáře v kódu obvykle poznáte snadno, protože je váš editor bude vykreslovat
jinou barvou než zbytek kódu.</p>
<p>V <em>C</em> existují dva typy komentářů:</p>
<ul>
<li>Řádkové komentáře - pokud do kódu napíšete <code>//</code>, tak vše za těmito lomítky až do konce řádku se 
bude brát jako komentář.
<pre><code class="language-c">// komentář 1
int main() {
    // komentář 2
    return 0; // komentář 3
}
</code></pre>
</li>
<li>Blokové komenáře - pokud do kódu napíšete <code>/*</code>, tak bude jako komentář označen všechen následující
text, dokud nedojde k ukončení komentáře pomocí <code>*/</code>.
<pre><code class="language-c">int main() {
    /* zde je komentář
zde taky
a tady taky */
    return 0;
}
</code></pre>
</li>
</ul>
<p>Ze začátku je asi jednodušší používat řádkové komentáře, ve VSCode můžete použít klávesovou zkratku
<code>Ctrl + /</code> pro zakomentování/odkomentování řádku kódu. Pokud vám přijde nějaký kus kódu komplikovaný,
tak si k němu zkuste dopsat komentář, který vysvětlí, co má daný kód dělat. Porozumíte tak kódu snáž,
až se k němu např. za měsíc vrátíte.</p>
<h3><a class="header" href="#klíčová-slova" id="klíčová-slova">Klíčová slova</a></h3>
<p><strong>Klíčová slova</strong> (<em>keywords</em>) jsou vestavěné názvy, kterým překladač přiřazuje speciální
význam. V textovém editoru je typicky poznáte tak, že budou zabarvená jinou barvou. Například v
tomto kódu jsou <code>int</code> a <code>return</code> klíčová slova:</p>
<pre><code class="language-c">int main() {
    return 0;
}
</code></pre>
<p>Během semestru se postupně naučíte, k čemu se jednotlivá klíčová slova používají. Jejich kompletní
seznam můžete najít například <a href="https://www.programiz.com/c-programming/list-all-keywords-c-language">zde</a>.</p>
<h3><a class="header" href="#speciální-znaky" id="speciální-znaky">Speciální znaky</a></h3>
<p>Při programování (jak už v <em>C</em>, tak i v jiných jazycích) budete používat spousty symbolů, které běžně
asi často nevyužíváte (například <code>[</code>, <code>]</code>, <code>{</code>, <code>}</code>, <code>&lt;</code>, <code>&gt;</code>, <code>=</code>, <code>%</code>, <code>#</code>, <code>&amp;</code>, <code>*</code>, <code>;</code>, <code>\</code>,
<code>&quot;</code>, <code>'</code>). Obzvláště pokud pro programování budete používat českou klávesnici, je dobré si ze začátku
najít nějaký tahák (např. <a href="https://github.com/geordi/upr-course/blob/master/assets/cheatsheets/keyboard-cs.pdf">tento</a>),
abyste nemuseli pokaždé zdlouhavě vzpomínat, na které klávese se daný znak nachází. </p>
<h3><a class="header" href="#formátování-kódu" id="formátování-kódu">Formátování kódu</a></h3>
<p>Už víme, že překladač ignoruje bílé znaky a celkové formátování kódu. Nicméně programátorům obvykle
velmi záleží na tom, jaké má kód odsazení, zarovnání, závorkování atd. Existuje mnoho
<a href="https://en.wikipedia.org/wiki/Indentation_style">stylů</a>, pomocí kterých můžete kód formátovat.
Například programátoři se dokážou běžně pohádat o tom, zda složené závorky na začátku bloku psát na
stejném:</p>
<pre><code class="language-c">if (...) {

}
while (...) {

}
</code></pre>
<p>nebo novém řádku:</p>
<pre><code class="language-c">if (...)
{
}
while (...)
{
}
</code></pre>
<p>Jaký styl formátování použijete, je na vás, nicméně obecně platným pravidlem je, že byste se měli
držet ve svých programech jednotného stylu a nemíchat více stylů dohromady.</p>
<h1><a class="header" href="#vykonávání-programů" id="vykonávání-programů">Vykonávání programů</a></h1>
<p>Jak už víme, programy jsou <a href="c/../uvod/programovaci_jazyky.html">sekvence příkazů</a> pro počítač, který je provádí
instrukci po instrukci (resp. řádek po řádku). Jakmile počítač vykoná jeden řádek vašeho programu, tak skočí
na řádek níže, dokud nedojde na konec programu. Aby počítač věděl, kterou instrukci má provést
jako první, tak mu musíme říct, kde má začít. K tomu přesně slouží <a href="c/funkce/funkce.html">funkce</a> (pojmenovaný
blok kódu) se speciálním názvem <code>main</code>:</p>
<pre><code class="language-c">int main() {
    // ZDE
    return 0;
}
</code></pre>
<p>Výše zmíněný program se po <a href="c/../prostredi/preklad_programu.html">překladu</a> a spuštění začne vykonávat na prvním řádku
funkce <code>main</code>, a jakmile provede všechny řádky, tak program skončí. Tento program je
v podstatě prázdný, takže se pouze zapne a vypne. Prozatím budeme veškerý kód psát dovnitř funkce
<code>main</code>, mezi složené závorky (<code>{</code>, <code>}</code>) a před řádek <code>return 0;</code> (tedy na místo komentáře <code>ZDE</code>).
<a href="c/../ruzne/funkce_main.html">Později</a> si vysvětlíme, jak tato funkce funguje, prozatím to berte tak,
že v programu vždy musí funkce <code>main</code> být, aby počítač věděl, odkud začít vykonávání kódu. </p>
<h1><a class="header" href="#příkazy" id="příkazy">Příkazy</a></h1>
<p>Programy v <em>C</em> se skládají z <strong>příkazů</strong> (<em>statements</em>). Příkaz říká počítači, co má provést, na
mnohem vyšší úrovni než <a href="c/../uvod/programovaci_jazyky.html">instrukce</a> - jeden C příkaz může být přeložen
překladačem na desítky instrukcí pro procesor. Existuje mnoho různých typů příkazů, které naleznete
v následujících sekcích.</p>
<h1><a class="header" href="#výrazy" id="výrazy">Výrazy</a></h1>
<p>Jak už vyplává z jeho názvu, nejpřirozenější a hlavní funkcí počítače je něco počítat. Jedním ze
základních konstrukcí jazyka <em>C</em> (i jiných programovacích jazyků) tak je možnost počítat různé hodnoty.
Něco, co se dá vypočítat (tak, aby výsledkem byla nějaká hodnota), se nazývá <strong>výraz</strong> (<em>expression</em>).
Příkladem asi nejjednoduššího výrazu je číslo, např. <code>5</code>. Takovýto výraz již není nutné dále vyhodnocovat,
jeho hodnota je prostě <code>5</code>.</p>
<p>V <em>C</em> můžeme s výrazy provádět různé operace pomocí <strong>operátorů</strong>. Můžeme například použít operátor <code>+</code>
s dvěma výrazy, čímž vznikne složitější výraz: <code>5 + 5</code>, který se v programu vyhodnotí na hodnotu <code>10</code>.</p>
<h3><a class="header" href="#výpis-výrazů" id="výpis-výrazů">Výpis výrazů</a></h3>
<p>Abyste si ze začátku mohli jednoduše zobrazit hodnoty výrazů, tak si ukážeme kód, pomocí kterého
můžete vypsat text na výstup programu (do terminálu). K výpisu můžete použít příkaz</p>
<pre><code class="language-c">printf(&quot;&lt;text&gt;&quot;);
</code></pre>
<p>Text, který vložíte mezi uvozovky (<code>&quot;</code>) se vypíše na výstup programu<sup class='margin-toggle sidenote-number'>2</sup>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Tento kód můžete modifikovat i spustit přímo v prohlížeči. Stačí kliknout na ikonu
<i class="fa fa-play"></i> vpravo nahoře nebo stisknout <code>Ctrl+Enter</code>.</p>
</span>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Hello world!\n&quot;);
    return 0;
}
</code></pre>
<p>Abyste <code>printf</code> mohli použít, musíte na začátek programu vložit řádek <code>#include &lt;stdio.h&gt;</code>.
Tento řádek i <code>printf</code> zatím berte jako &quot;black box&quot;, <a href="c/preprocesor/vkladani_souboru.html">později</a> si
vysvětlíme, jak přesně fungují.</p>
<p>V zadaném textu můžete používat určité speciální znaky. Například sekvence znaků <code>\n</code> způsobí, že
na výstupu dojde k <strong>odřádkování</strong> (<em>newline</em>), po kterém se text začne vypisovat na dalším řádku:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Prvni radek\nDruhy radek&quot;);
    return 0;
}
</code></pre>
<p>Abyste mohli tisknout hodnoty výrazů, můžete použít <strong>zástupné znaky</strong> (<em>placeholders</em>). Pokud chcete
vypsat <em>číselnou</em> hodnotu na výstup programu, stačí v textu použít zástupný znak <code>%d</code>, za uvozovky
přidat čárku a doplnit výraz na místo určené komentářem:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;Cislo: %d\n&quot;, /* Hodnota tohoto výrazu se vypíše na výstup */ 1);
    return 0;
}
</code></pre>
<p>Když chcete vypsat například výsledek vyhodnocení výrazu <code>10 + 5</code>, tak stačí napsat:
<code>printf(&quot;%d\n&quot;, 10 + 5);</code> a na výstup programu by se měl vypsat text <code>15</code>.</p>
<p>Pokud chcete vytisknout více hodnot, tak prostě řádek s <code>printf(...);</code> zkopírujte a na uvedené místo
vložte jiný výraz. Počítač provádí programy řádek po řádku, odshora dolů. Uhodnete, co se vypíše
na výstup po přeložení a spuštění následujícího programu?</p>
<pre><code class="language-c editable readonly">#include &lt;stdio.h&gt;

int main() {
    printf(&quot;%d\n&quot;, 1);
    printf(&quot;%d\n&quot;, /* tady vložte výraz */);
    return 0;
}
</code></pre>
<p><strong>Cvičení</strong>: Zkuste si na místo komentáře doplnit několik výrazů (např. <code>5 + 8</code>, <code>8 * 3</code>, <code>12 * (2 + 3)</code>),
přeložit program, spustit ho a podívat se, co vypíše na výstup, abyste si vyzkoušeli vyhodnocování
výrazů.</p>
<h3><a class="header" href="#datové-typy" id="datové-typy">Datové typy</a></h3>
<p>Každý výraz má svůj datový typ, který udává, jak je hodnota výrazu v programu interpretována a také
jaké operace má smysl nad výrazem dělat. Více o datových typech a operátorech se dozvíte v sekci
<a href="c/datove_typy/datove_typy.html">Datové typy</a>.</p>
<h3><a class="header" href="#vedlejší-efekty" id="vedlejší-efekty">Vedlejší efekty</a></h3>
<p>Pokud chcete pouze vypočítat výraz (&quot;jen tak&quot;), mimo nějaký příkaz, stačí za něj dát středník. Tím
ze samostatného výrazu uděláte příkaz:</p>
<pre><code class="language-c">1 + 1; // vypočte se `2`, výsledek se na nic nepoužije
</code></pre>
<p>Toto má smysl dělat pouze u výrazů, které mají nějaký <strong>vedlejší efekt</strong> (<em>side effect</em>), který
způsobí, že při provádění výrazu se v programu něco změní. Jinak by výraz sám o sobě byl vypočten,
ale nic dalšího by se nestalo. O výrazech, které umí produkovat vedlejší efekty, se dozvíte později.</p>
<h4><a class="header" href="#příkazy-vs-výrazy" id="příkazy-vs-výrazy">Příkazy vs výrazy</a></h4>
<p>Jakmile se budete postupně učit o jednotlivých konstrukcích jazyka C, je důležité uvědomit si, jaký
je rozdíl mezi výrazem (něco, co se dá vypočítat) a příkazem, pomocí kterého počítači říkáme, aby
něco (s nějakým výrazem) udělal (například vypsal ho na výstup, zapsal do paměti atd.).</p>
<h1><a class="header" href="#proměnné" id="proměnné">Proměnné</a></h1>
<p>Aby programy mohly řešit nějaký úkol, tak si téměř vždy musí umět něco zapamatovat. K tomu
slouží tzv. <strong>proměnné</strong> (<em>variables</em>). Proměnné nám umožňují pracovat s pamětí intuitivním způsobem -
část paměti si pojmenujeme nějakým jménem a dále se na ni tímto jménem odkazujeme. Proměnné můžou
uchovávat libovolnou hodnotu a také ji v průběhu programu měnit. Příklady použití
proměnných:</p>
<ul>
<li>Ve webové aplikaci si číselná proměnná pamatuje počet návštěvníků. Při zobrazení stránky
se hodnota proměnná zvýší o 1.</li>
<li>Ve hře si číselná proměnná pamatuje počet životů hráčovy postavy. Pokud dojde k zásahu postavy
nepřítelem, tak se počet životů sníží o zranění (<em>damage</em>) nepřítelovy zbraně. Pokud hráč sebere lékárníčku,
tak se počet jeho životů opět zvýší.</li>
<li>V terminálu si proměnná reprezentující znaky pamatuje text, který byl zadán na klávesnici.</li>
</ul>
<p>Proměnné jsou jedním z nejzákladnějších a nejčastějších stavebních kamenů většiny programů, během
semestru se s nimi budeme setkávat neustále. Není tak náhodou, že jedním z nejzákladnějších příkazů
v <em>C</em> je právě vytvoření proměnné. Tím řekneme počítači, aby vyčlenil (tzv. <strong>naalokoval</strong>) místo v paměti,
které si v programu nějak pojmenujeme a dále se na něho pomocí jeho jména můžeme odkazovat<sup class='margin-toggle sidenote-number'>1</sup>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>O tom, jak přesně tato alokace paměti probíhá, se dozvíte později v sekci o
<a href="c/promenne/../prace_s_pameti/ukazatele.html">ukazatelích</a>.</p>
</span>
<h3><a class="header" href="#definice-a-platnost" id="definice-a-platnost">Definice a platnost</a></h3>
<p>Takto vypadá <strong>definice</strong> (vytvoření) jednoduché proměnné s názvem <code>age</code>:</p>
<pre><code class="language-c">int age;
</code></pre>
<p>Jakmile proměnnou nadefinujeme, tak z ní můžeme buď číst anebo zapisovat paměť, kterou tato proměnná
reprezentuje, pomocí jejího názvu (zde <code>age</code>).</p>
<p>Proměnná je platná (lze ji používat) vždy od místa definice do konce <strong>bloku</strong>, ve kterém byla
nadefinována. Bloky jsou kusy kódu ohraničené složenými závorkami (<code>{</code> a <code>}</code>):</p>
<pre><code class="language-c">int main() {
    int a;

    {
        // zde je platné pouze `a`
        int b;
        // zde je platné `a` i `b`
    } // zde končí platnost proměnné `b`

    // zde je platné pouze `a`

    return 0;
} // zde končí platnost proměnné `a`
</code></pre>
<p>Oblast, ve které je proměnná validní, se nazývá (variable) <em>scope</em>.</p>
<h3><a class="header" href="#datový-typ" id="datový-typ">Datový typ</a></h3>
<p><code>int</code> před názvem proměnné udává její datový typ, o kterém pojednává <a href="c/promenne/../datove_typy/datove_typy.html">následující sekce</a>.
Prozatím si řekněme, že <code>int</code> je zkratka pro <code>integer</code>, tedy celé číslo. Tím říkáme programu, že má
tuto proměnnou (resp. paměť, kterou proměnná reprezentuje) interpretovat jako celé číslo se znaménkem.</p>
<h3><a class="header" href="#inicializace" id="inicializace">Inicializace</a></h3>
<p>Do proměnné bychom měli při jejím vytvoření rovnou uložit nějaký <em>výraz</em>, který musí být stejného
datového typu jako je typ proměnné:</p>
<pre><code class="language-c">int points_a = 10;
int points_b = 10 + 15;
</code></pre>
<p>Obecná syntaxe pro definici proměnné je</p>
<p><code>&lt;datový typ&gt; &lt;název&gt;;</code></p>
<p>popřípadě</p>
<p><code>&lt;datový typ&gt; &lt;název&gt; = &lt;výraz&gt;;</code></p>
<p>pokud použijeme inicializaci.</p>
<blockquote>
<p>Všimněte si, že na konci definice proměnné vždy musí následovat středník (<strong>;</strong>).
Opomenutí středníku na konci příkazu je velmi častá chyba, která často končí těžko srozumitelnými chybovými
hláškami při překladu. Dávejte si tak na středníky pozor, obzvláště ze začátku.</p>
</blockquote>
<h4><a class="header" href="#vždy-inicializujte-proměnné" id="vždy-inicializujte-proměnné">Vždy inicializujte proměnné!</a></h4>
<p>Je opravdu důležité do proměnné vždy při její definici přiřadit nějakou úvodní hodnotu. Pokud to
neuděláme, tak její hodnota bude <strong>nedefinovaná</strong> (<em>undefined</em>), což v praxi znamená, že může být
jakákoliv a při každém spuštění programu se může lišit. Čtení hodnoty takovéto nedefinované proměnné
způsobuje <strong>nedefinované chování</strong> (<em>undefined behaviour</em>)<sup class='margin-toggle sidenote-number'>2</sup> programu. Pokud k tomu dojde, tak si překladač
s vaším programem může udělat, co se mu zachce, a váš program se poté může chovat nepředvídatelně.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Situace, které můžou způsobit nedefinované chování, budou dále v textu označené pomocí ikony
💣.</p>
</span>
<p><strong>Proto vždy dávejte proměnným iniciální hodnotu!</strong></p>
<h3><a class="header" href="#Čtení" id="Čtení">Čtení</a></h3>
<p>Pokud v programu použijeme název platné proměnné, tak dojde k načtení její hodnoty.
Pokud použijeme název proměnné v programu na místě, kde je očekáván výraz, tak se vyhodnotí jako
současná hodnota proměnné:</p>
<pre><code class="language-c">int main() {
    int a = 5;
    int b = a;  // hodnota `b` je 5
    int c = b + a + 1;  // hodnota `c` je 11
}
</code></pre>
<p>Kdekoliv tak můžete použít výraz, můžete použít i proměnnou (pokud sedí datové typy). Pro výpis hodnot
proměnných na výstup programu můžete <code>printf</code>. Hodnoty proměnných můžete zkoumat také krokováním
pomocí <a href="c/promenne/../../prostredi/ladeni.html#krokov%C3%A1n%C3%AD">debuggeru</a>.</p>
<h3><a class="header" href="#zápis" id="zápis">Zápis</a></h3>
<p>Pokud by proměnná měla pouze svou původní hodnotu, tak by nebyla moc užitečná. Hodnoty proměnných
naštěstí jde měnit. Můžeme k tomu použít další typ <em>C</em> výrazu přiřazení (<strong>assignment</strong>):</p>
<pre><code class="language-c">int main() {
    int a = 5;  // hodnota `a` je 5
    a = 8;      // hodnota `a` je 8
}
</code></pre>
<p>Obecná syntaxe pro přiřazení do proměnné je</p>
<p><code>&lt;název proměnné&gt; = &lt;výraz&gt;</code></p>
<p>Opět musí platit, že výraz musí být stejného typu<sup class='margin-toggle sidenote-number'>3</sup>, jako je proměnná, do které přiřazujeme. Na konci
řádku také nesmí chybět středník. Přiřazení je příklad výrazu, který má vedlejší efekt, proto se
obvykle používá jako samostatný příkaz (tj. dává se za něj středník).</p>
<span class='sidenote'><p><sup class='number'>3</sup><em>C</em> umožňuje automatické (tzv. <strong>implicitní</strong>) konverze mezi některými datovými typy, takže typ výrazu
nemusí být nutně vždy stejný. Tyto konverze se nicméně často chovají neintuitivně a překladač vás před nimi
obvykle nijak nevaruje, i když vrátí výsledek, který nedává smysl. Snažte se tak ze začátku opravdu vždy
používat odpovídající typy. Více se dozvíte v sekci o <a href="c/promenne/../datove_typy/datove_typy.html">datových typech</a>. </p>
</span>
<p>Jak přiřazení funguje? Počítač se podívá, na jaké adrese v paměti daná proměnná leží, a zapíše do
paměti hodnotu výrazu, který do proměnné zapisujeme, čímž změní její hodnotu v paměti. Z toho vyplývá,
že dává smysl zapisovat hodnoty pouze do něčeho, co má adresu v paměti (prozatím známe pouze proměnné,
později si ukážeme další věci, do kterých lze zapisovat). Například příkaz <code>5 = 8;</code> nedává smysl. <code>5</code>
je výraz, číselná hodnota, která nemá žádnou adresu v paměti, nemůžeme tak do ní nic zapsat. Stejně tak
nedává moc smysl říct <code>Číslo 5 odteď bude mít hodnotu 8</code>.</p>
<p>Zatím známe pouze proměnné, později si však ukážeme <a href="c/promenne/../prace_s_pameti/ukazatele.html">další možnosti</a>, jak vytvořit
&quot;něco, co má adresu v paměti&quot;, a co tak půjde použít na levé straně operátoru zápisu <code>=</code>.</p>
<p><strong>Cvičení</strong>: Zkuste napsat program, který vytvoří několik proměnných, přečte a změní jejich hodnoty
a pak je vypíše na výstup programu (k výpisu využijte <code>printf</code>, který jsme si již ukázali <a href="c/promenne/../prikazy_vyrazy.html#v%C3%BDpis-v%C3%BDraz%C5%AF">dříve</a>).</p>
<h3><a class="header" href="#definice-více-proměnných-najednou" id="definice-více-proměnných-najednou">Definice více proměnných najednou</a></h3>
<p>Pokud potřebujete vytvořit více proměnných stejného datového typu, můžete používat více názvů,
oddělených čárkou, za datovým typem proměnné. Takto například lze vytvořit tři celočíselné proměnné
s názvy <code>x</code>, <code>y</code> a <code>z</code>:</p>
<pre><code class="language-c">int x = 1, y = 2, z = 3;
</code></pre>
<h1><a class="header" href="#globální-proměnné" id="globální-proměnné">Globální proměnné</a></h1>
<p>Proměnné, které jsme si ukázali, byly vytvářeny uvnitř <a href="c/promenne/../funkce/funkce.html">funkcí</a> (tj. ne na nejvyšší
úrovni souboru). Takovéto proměnné se nazývají <strong>lokální proměnné</strong>. Pokud chceme, aby k nějaké
proměnné byl přístup odkudkoliv v programu, tak můžeme vytvořit proměnnou na úrovni souboru.
Takovéto proměnné se nazývají <strong>globální</strong>.</p>
<p>V rámci jednoho souboru lze globální proměnnou použít od místa, kde je definována, až po
konec souboru:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

// zde nelze použít proměnnou `globalni_promenna`

int globalni_promenna = 1;

int main() {
    globalni_promenna += 1;
    printf(&quot;%d\n&quot;, globalni_promenna);

    return 0;
}
</code></pre>
<h3><a class="header" href="#iniciální-hodnota" id="iniciální-hodnota">Iniciální hodnota</a></h3>
<p>Narozdíl od lokálních proměnných, globální proměnné se nainicializují na hodnotu <code>0</code><sup class='margin-toggle sidenote-number'>1</sup>, i když
jim žádnou úvodní hodnotu nedáte. I tak je ale dobrým zvykem úvodní hodnotu takovýmto proměnným dát,
aby šlo jasně vidět, že absence úvodní hodnoty není pouze nedopatřením ze strany programátora.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Je to zajištěno tím, že jsou uloženy v sekci spustitelného souboru nazývané
<a href="https://en.wikipedia.org/wiki/.bss"><code>.bss</code></a>. Po spuštění programu jsou tak automaticky vynulovány.</p>
</span>
<h3><a class="header" href="#nepoužívání-globálních-proměnných" id="nepoužívání-globálních-proměnných">(Ne)používání globálních proměnných</a></h3>
<p>Globální proměnné jsou zde zmíněny pro úplnost, nicméně doporučujeme je používat spíše zřídka,
obzvláště pokud půjde o globální proměnné, které půjde měnit (tj. pokud to nebudou
<a href="c/promenne/konstanty.html">konstanty</a>). Obecně řečeno, na čím více místech je proměnná dostupná, tím složitější
je přemýšlení nad tím, jak přesně s ní pracovat, proto je lepší používat proměnné lokální, pokud to
jde. </p>
<p>Když je proměnná globální, tak je k ní přístup v podstatě odkudkoliv v programu. To sice zní
neškodně, ba i užitečně, nicméně přináší to s sebou značné nevýhody, pokud lze proměnnou zároveň
měnit. Jakmile totiž lze proměnnou odkudkoliv změnit, snadno se vám může stát, že nějaký kus programu
vám bude hodnotu takovéto proměnné měnit &quot;pod rukama&quot;, a bude obtížné najít kód, který danou proměnnou
změnil (a také důvod, proč ji změnil).</p>
<blockquote>
<p>Globální proměnné také mohou způsobovat problémy, pokud ve vašem problému budete využívat více jader
procesoru. Tzv. paralelní programy nicméně nebudeme v tomto předmětu řešit, více se o nich dozvíte
například v předmětu <a href="http://poli.cs.vsb.cz/edu/apps/">Architektury počítačů a paralelních systémů</a>.</p>
</blockquote>
<h1><a class="header" href="#konstanty" id="konstanty">Konstanty</a></h1>
<p>V určitých případech můžeme chtít mít proměnné s konstantní hodnotou, které by se neměly v průběhu
programu měnit. Takové proměnné se nazývají <strong>konstanty</strong> (<em>constants</em>).</p>
<p>Abychom zamezili nechtěné změně hodnoty konstanty, můžeme datový typ proměnné označit
<a href="c/promenne/../syntaxe.html#kl%C3%AD%C4%8Dov%C3%A1-slova">klíčovým slovem</a> <code>const</code>, který umístíme před<sup class='margin-toggle sidenote-number'>1</sup> název datového typu.
Pokud bychom se snažili o změnu proměnné s takovýmto datovým typem, překladač nám to nedovolí.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Modifikátor <code>const</code> lze umístit i za datový typ. Někteří programátoři o umístění tohoto
modifikátoru vedou
<a href="https://mariusbancila.ro/blog/2018/11/23/join-the-east-const-revolution">vášnivé diskuze</a>. Důležité
hlavně je, abyste ve volbě umístění modifikátorů byli konzistentní a používali je na všech místech
stejně.</p>
</span>
<pre><code class="language-c editable mainbody">int main() {
    const int a = 5;
    a += 1; // chyba

    return 0;
}
</code></pre>
<p>Použití konstant může mít několik důvodů:</p>
<ul>
<li>
<p>V programech někdy opakovaně použiváme konstantní hodnoty, které mají pevně danou hodnotu. Při
čtení zdrojového kódu nemusí být jasné, co takového hodnoty znamenají (v takovém případě se hanlivě
označují jako &quot;magické konstanty&quot;). Abychom takového hodnoty pojmenovali, můžeme je uložit do
konstantní proměnné. Při čtení programu pak bude zřejmé, co reprezentují. Porovnejte variantu
s nepopsanými číselnými hodnotami:</p>
<pre><code class="language-c">float vypocti_cenu(float cena) {
    return cena * (1 + 0.21);
}
float vypocti_odvod(float celkova_cena, bool dph) {
    if (dph) {
        return celkova_cena * 0.21;
    } else {
        return 0;
    }
}
</code></pre>
<p>s variantou využívající pojmenované konstanty:</p>
<pre><code class="language-c">const float DPH = 0.21f;

float vypocti_cenu(float cena) {
    return cena * (1 + DPH);
}
float vypocti_odvod(float celkova_cena, bool dph) {
    if (dph) {
        return celkova_cena * DPH;
    } else {
        return 0;
    }
}
</code></pre>
<p>Druhá varianta kódu je jistě čitelnější.</p>
</li>
<li>
<p>V určitých případech, například u konstantních <a href="c/promenne/../text/retezce.html">řetězců</a>, jsou data uložena v oblasti
paměti, kterou nelze měnit. Pomocí <code>const</code> si můžeme pohlídat, že se takováto paměť opravdu nezmění.</p>
</li>
</ul>
<h1><a class="header" href="#složený-zápis" id="složený-zápis">Složený zápis</a></h1>
<p>Často potřebujeme hodnotu proměnné pouze trochu poupravit, a ne do ní vyloženě zapsat novou hodnotu.
Běžná je například operace zvýšení hodnoty proměnné o <code>1</code> (tzv. <strong>inkrementace</strong> proměnné).
K tomu můžeme použít tento příkaz:</p>
<pre><code class="language-c">count = count + 1; // zvýšení hodnoty proměnné `count` o 1
</code></pre>
<p>nicméně to je docela zdlouhavé. Proto <em>C</em> nabízí tzv. operátory <strong>složeného zápisu</strong> (<em>compound
assignment</em>). Tyto operátory jsou spojené z normálního operátoru (např. <code>+</code>) a operátoru <code>=</code>:
<code>+=</code>, <code>-=</code>, <code>*=</code>, atd. Složený zápis</p>
<pre><code class="language-c">&lt;proměnná&gt; &lt;operátor&gt;= &lt;výraz&gt;;
</code></pre>
<p>je ekvivalentní příkazu</p>
<pre><code class="language-c">&lt;proměnná&gt; = &lt;proměnná&gt; &lt;operátor&gt; &lt;výraz&gt;;
</code></pre>
<p>Například:</p>
<pre><code class="language-c">int count = 0;
count += 1;   // stejné jako count = count + 1;
count *= 3;   // stejné jako count = count * 3; 
</code></pre>
<p>Stejně jako <a href="c/promenne/promenne.html#z%C3%A1pis">zápis</a> je složený zápis příkladem výrazu s vedlejším efektem.</p>
<h3><a class="header" href="#inkrementace-a-dekrementace" id="inkrementace-a-dekrementace">Inkrementace a dekrementace</a></h3>
<p>Speciálním případem složeného zápisu je tzv. <strong>inkrementace</strong> (zvýšení hodnoty proměnné o jedničku)
a <strong>dekrementace</strong> (snížení hodnoty proměnné o jedničku). Tyto operace jsou tak časté, že <em>C</em> obsahuje
speciální &quot;zkratky&quot; pro jejich provedení. Aby to nebylo tak jednoduché, tak tyto zkratky
existují ve dvou variantách:</p>
<ul>
<li><em>Postfixová</em>: <code>&lt;proměnná&gt;++</code>. Tento výraz se vyhodnotí jako hodnota dané proměnné, a <strong>poté</strong> zvýší
hodnotu proměnné o jedničku. Zkuste uhodnout, co vypíše následující program:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;
    int b = a++;
    printf(&quot;%d\n&quot;, a);
    printf(&quot;%d\n&quot;, b);

    return 0;
}
</code></pre>
</li>
<li><em>Prefixová</em>: <code>++&lt;proměnná&gt;</code>. Tento výraz <strong>nejprve</strong> zvýší hodnotu proměnné, a až poté se vyhodnotí
jako (nová, již zvýšená) hodnota dané proměnné. Zkuste uhodnout, co vypíše následující program:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;
    int b = ++a;
    printf(&quot;%d\n&quot;, a);
    printf(&quot;%d\n&quot;, b);

    return 0;
}
</code></pre>
</li>
</ul>
<p>Dekrementace se chová totožně jako inkrementace, pouze s tím rozdílem, že snižuje hodnotu
proměnné o <code>1</code> a místo <code>++</code> používá <code>--</code>.</p>
<p>Inkrementace a dekrementace jsou příklady výrazů s vedlejším efektem.</p>
<blockquote>
<p>Tyto zkratky jsou sice užitečné, ale také můžou vyústit v překvapivé chování díky způsobu, kterým
jsou vyhodnocovány. Ze začátku je radši využívejte pouze v situacích, kdy budou použity jako příkaz,
který změní hodnotu proměnné (<code>i++;</code>). Jinak řečeno, raději se moc nespoléhejte na hodnotu, ve
kterou se inkrementace/dekrementace vyhodnotí.</p>
</blockquote>
<h1><a class="header" href="#pojmenovávání-proměnných" id="pojmenovávání-proměnných">Pojmenovávání proměnných</a></h1>
<p>V C existují určitá pravidla pro pojmenování proměnných:</p>
<ul>
<li>Proměnné se nesmí jmenovat stejně jako <a href="c/promenne/../syntaxe.html#kl%C3%AD%C4%8Dov%C3%A1-slova">klíčová slova</a>, jinak by
překladač neuměl rozlišit, co je název proměnné a co klíčové slovo (například u <code>int int;</code>).</li>
<li>Název proměnné může obsahovat pouze malá (<code>a-z</code>) a velká (<code>A-Z</code>) písmena anglické abecedy, číslice
(<code>0-9</code>) a podtržítko (<code>_</code>).</li>
<li>Název proměnné nesmí začínat číslicí, tj. <code>5x</code> není validní název proměnné.</li>
</ul>
<p>V programech je nutné neustálě přiřazovat něčemu název, což zdaleka není tak jednoduché, jak se
může na první pohled zdát. Kromě výše zmíněných pravidel je zároveň vhodné volit názvy tak, aby byly
přehledné pro vás (a ostatní programátory, kteří váš zdrojový kód budou číst). Názvy proměnných jako
<code>a</code> nebo <code>x</code> jsou nicneříkající a kód s podobnými názvy je pak složitější pochopit. Porovnejte
následující dva úseky kódu, které se liší pouze v použitých názvech proměnných:</p>
<pre><code class="language-c">int c = 1337;
int x = c - y;
int d = x * z;

// nebo

int zakladni_cena = 1337;
int zlevnena_cena = zakladni_cena - sleva;
int finalni_cena = zlevnena_cena * dph;
</code></pre>
<p>I když je druhá varianta delší, tak jde okamžitě poznat, co program počítá, narozdíl od první varianty.</p>
<h3><a class="header" href="#víceslovné-názvy" id="víceslovné-názvy">Víceslovné názvy</a></h3>
<p>Existuje několik zaběhlých stylistických způsobů pro zápis názvů v C, které obsahují více slov. Zde
je seznam nejpoužívanějších konvencí:</p>
<ul>
<li><code>Camel case</code>: <code>mujUcet</code>, <code>prvniKlikUzivatele</code></li>
<li><code>Pascal case</code>: <code>MujUcet</code>, <code>PrvniKlikUzivatele</code></li>
<li><code>Snake case</code>: <code>muj_ucet</code>, <code>prvni_klik_uzivatele</code></li>
<li><code>Screaming snake case</code>: <code>MUJ_UCET</code>, <code>PRVNI_KLIK_UZIVATELE</code></li>
</ul>
<p>Různé konstrukce C můžou využívat různé styly, například častá konvence je použití <code>snake_case</code>
pro názvy proměnných a <a href="c/promenne/../funkce/funkce.html">funkcí</a> a <code>PascalCase</code> pro názvy <a href="c/promenne/../struktury/struktury.html">struktur</a>.
Který styl budete používat záleží na vaší osobní preferenci, nicméně důležité je zejména držet se
jednotného stylu a nekombinovat různé styly (pro jednotlivé typy konstrukcí) v jednom programu.</p>
<h3><a class="header" href="#Čeština-nebo-angličtina" id="Čeština-nebo-angličtina">Čeština nebo angličtina?</a></h3>
<p>Pokud vám to přijde přehlednější, tak ze začátku můžete používat české názvy<sup class='margin-toggle sidenote-number'>1</sup> pro názvy proměnných
a dalších prvků. Může tak pro vás být snadnější odlišit, kterou část kódu jste vytvořili vy (ta bude
mít český název), a co je naopak vestavěná součást <em>C</em> (např. <code>int</code>). </p>
<span class='sidenote'><p><sup class='number'>1</sup>Bez diakritiky.</p>
</span>
<p>Nicméně, jak už bylo uvedeno v <a href="c/promenne/../../uvod/uvod.html">úvodu</a>, primárním jazykem programování je
angličtina. Pokud byste se někdy setkali s cizím kódem a museli ho pochopit či upravit, určitě oceníte,
když bude v angličtině, než kdyby byl například ve finštině. Stejně tak pokud budete sdílet svůj
kód online, můžete s ním oslovit mnohem širší skupinu programátorů, když bude v angličtině, než kdyby
byl v češtině.</p>
<p>Jakmile se tedy v programování trochu aklimatizujete, používejte ve všech svých programech raději
anglické názvy.</p>
<h1><a class="header" href="#datové-typy-1" id="datové-typy-1">Datové typy</a></h1>
<p><a href="c/datove_typy/../../uvod/pamet.html">Paměť</a> počítače pracuje s jednotlivými <em>byty</em>, nicméně pro lidi
je žádoucí používat popis dat v paměti na mnohem vyšší úrovni abstrakce, aby se nám o datech
jednoduššeji přemýšlelo. Pokud programujeme textový editor, chceme se bavit o znacích, odstavcích,
fontech či barvách, pokud programujeme počítačovou hru, chceme se bavit o zbraních, brnění, kouzlech
či pixelech.</p>
<p>Přesně k tomu slouží <strong>datové typy</strong>, které popisují, jak budeme interpretovat konkrétní hodnoty
daného typu v paměti, kolik bytů budou zabírat a jaké operace nad nimi budeme moct provádět. Jazyk C
obsahuje několik vestavěných datových typů, <a href="c/datove_typy/../struktury/struktury.html">později</a> si ukážeme, jak vytvořit
své vlastní.</p>
<h1><a class="header" href="#celočíselné-datové-typy" id="celočíselné-datové-typy">Celočíselné datové typy</a></h1>
<p>Asi nejpřirozenějším a nejpoužívanějším datovým typem ve většině programovacích jazyků jsou (celá)
čísla. Tyto číselné datové typy nám umožňují pracovat s celými čísly, které mají typicky jednotky
(1 - 8) bytů<sup class='margin-toggle sidenote-number'>1</sup>. Počet bytů udává, jak velký rozsah mohou hodnoty daného typu obsahovat. Například
číslo s 2 byty (16 bity) bez znaménka může obsahovat hodnoty 0 až 2<sup>16</sup>-1. Čím více bytů,
tím více zabere hodnota daného typu místa v paměti.</p>
<span class='sidenote'><p><sup class='number'>1</sup>I když 8 bytů (64 bitů) může znít jako málo, tak pomocí takového čísla můžeme vyjádřit 2<sup>64</sup>
(neboli <code>18 446 744 073 709 551 616</code>) různých hodnot, což pro naprostou většinu běžného použití čísel
bohatě stačí.</p>
</span>
<p>U celých číselných typů se rozlišuje, zda jsou <strong>signed</strong> (se znaménkem) nebo <strong>unsigned</strong> (bez
znaménka, nezáporné). Tato vlastnost udává, jaké hodnoty může typ nabývat
(tj. jestli mohou být i záporné nebo ne). Například číslem o velikosti jednoho bytu můžeme
reprezentovat 256 různých hodnot. Pokud budeme interpretovat toto číslo se znaménkem, tak může uchovávat
hodnoty -128 až 127. Pokud ho budeme interpretovat bez znaménka, tak může uchovávat hodnoty 0 až 255.</p>
<p>C obsahuje několik základních typů celočíselných proměnných, které se liší v tom, kolik mají bytů a
jestli jsou znaménkové nebo ne. Pokud před název typu napíšeme <code>signed</code>, bude se jednat o znaménkový
typ, pokud použijeme <code>unsigned</code>, tak použijeme typ bez znaménka. Většina typů je implicitně se
znaménkem, tj. <code>int</code> je to samé jako <code>signed int</code>. V následující tabulce je seznam nejčastějších
celočíselných typů<sup class='margin-toggle sidenote-number'>2</sup>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Počet bytů (a znaménkovost u typu <code>char</code>) záleží na kombinaci použitého hardwaru,
operačního systému a překladače. Zde jsou uvedeny hodnoty, se kterými se můžete
nejčastěji setkat na 64-bitovém x86 Linuxovém systému s překladačem GCC při použití
<a href="https://cs.wikipedia.org/wiki/Dvojkov%C3%BD_dopln%C4%9Bk">dvojkového doplňku</a>.</p>
</span><table><thead><tr><th>Název</th><th align="center">Počet bytů</th><th align="center">Rozsah hodnot</th><th align="center">Se znaménkem</th></tr></thead><tbody>
<tr><td><code>char</code> nebo<br /><code>signed char</code></td><td align="center">1</td><td align="center">[-128; 127]</td><td align="center"><i class="fa fa-check"></i></td></tr>
<tr><td><code>unsigned char</code></td><td align="center">1</td><td align="center">[0; 255]</td><td align="center"><i class="fa fa-times"></i></td></tr>
<tr><td><code>short</code> nebo<br /><code>signed short</code></td><td align="center">2</td><td align="center">[-32 768; 32 767]</td><td align="center"><i class="fa fa-check"></i></td></tr>
<tr><td><code>unsigned short</code></td><td align="center">2</td><td align="center">[0; 65 535]</td><td align="center"><i class="fa fa-times"></i></td></tr>
<tr><td><strong><code>int</code></strong> nebo<br /><code>signed int</code></td><td align="center">4</td><td align="center">[-2 147 483 648; 2 147 483 647]</td><td align="center"><i class="fa fa-check"></i></td></tr>
<tr><td><code>unsigned int</code></td><td align="center">4</td><td align="center">[0; 4 294 967 295]</td><td align="center"><i class="fa fa-times"></i></td></tr>
<tr><td><code>long</code> nebo<br /><code>signed long</code></td><td align="center">8</td><td align="center">[-9 223 372 036 854 775 808;<br />9 223 372 036 854 775 807]</td><td align="center"><i class="fa fa-check"></i></td></tr>
<tr><td><code>unsigned long</code></td><td align="center">8</td><td align="center">[0; 18 446 744 073 709 551 615]</td><td align="center"><i class="fa fa-times"></i></td></tr>
</tbody></table>
<p>Každý vestavěný datový typ (<code>char</code>, <code>short</code>, <code>int</code>) a modifikátor znaménkovosti (<code>signed</code>, <code>unsigned</code>)
je zároveň klíčovým slovem.</p>
<p>Pokud ze začátku nebudete vědět, který typ zvolit, tak pro základní aritmetické operace používejte
ze začátku typy se znaménkem s 4 byty, tedy <code>int</code>. Tento typ je také implicitně použit, když v programu
použijete číselný výraz, například výraz <code>1</code> má datový typ <code>int</code><sup class='margin-toggle sidenote-number'>3</sup>.</p>
<span class='sidenote'><p><sup class='number'>3</sup>Pouze pokud by výraz nešel reprezentovat typem <code>int</code>, použije se číselný typ s více byty.</p>
</span>
<blockquote>
<p>Typ <code>char</code> je speciální v tom, že zároveň běžně reprezentuje textové znaky v
<a href="https://www.asciitable.com/">ASCII</a> kódování. Více o reprezentaci textu v programech se dozvíte
v sekci o <a href="c/datove_typy/../text/retezce.html">řetězcích</a>.</p>
</blockquote>
<h3><a class="header" href="#operace-s-číselnými-typy" id="operace-s-číselnými-typy">Operace s číselnými typy</a></h3>
<p>C umožňuje provádět operace nad vestavěnými datovými typy pomocí tzv. <strong>operátorů</strong>. Při práci s
výrazy celočíselných typů lze provádět běžné aritmetické operace <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code> nebo <code>%</code> (zbytek
po dělení). Například <code>5 + 8</code> nebo <code>2 * 16</code> tak bude obvykle fungovat tak, jak byste očekávali. Je si
ale třeba dát pozor na několik zrádných věcí:</p>
<ul>
<li>Při dělení dvou celočíselných čísel pomocí operátoru <code>/</code> dochází k celočíselnému dělení, tj. například
výsledek výrazu <code>5 / 2</code> je <code>2</code>, a ne <code>2.5</code>. Pokud chcete provádět dělení desetinných čísel, musíte
použít <a href="c/datove_typy/celociselne_typy.html#Desetinn%C3%A9-%C4%8D%C3%ADseln%C3%A9-typy">odpovídající</a> datový typ. Zkuste si to:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
int main() {
    printf(&quot;%d\n&quot;, 5 / 2);
    return 0;
}
</code></pre>
</li>
<li>Jelikož mají čísla v počítači omezenou přesnost (typicky několik jednotek bytů), tak může při matematických
operacích dojít k tzv. <strong>přetečení</strong> (<em>overflow</em>). Například pokud vynásobíme jednobytové číslo <code>50</code>
desíti, tak bychom očekávali výsledek <code>500</code>, nicméně tak velké číslo nelze v jednom bytu reprezentovat.
Výsledkem místo toho bude <code>244</code> (<code>500 % 256</code>), pokud se jedná o číslo bez znaménka, nebo <code>-12</code>, pokud
jde o číslo se znaménkem. Podobné výsledky jsou silně neintuitivní, pokud tedy váš program vrácí zvláštní
číselný výsledek, zkontrolujte si, jestli neprovádíte operace, při kterých mohlo dojít k přetečení.</li>
<li>C provádí <a href="https://www.guru99.com/c-type-casting.html">implicitní konverze</a> mezi datovými typy,
které mohou změnit datový typ výrazů, které používáte, bez vašeho vědomí. Je tak (obzvláště ze začátku)
vhodné ujistit se, že provádíte operace mezi stejnými datovými typy.</li>
<li>Stejně jako v matematice, tak i v C záleží u operátorů na jejich prioritě a asociativitě.
Seznam všech operátorů spolu s jejich prioritiou naleznete <a href="https://en.cppreference.com/w/c/language/operator_precedence">zde</a>.
Například výsledek výrazu <code>1 + 2 * 3</code> je <code>7</code>, a ne <code>9</code>. Pokud budete chtít prioritu ovlivnit, můžete
výrazy <strong>uzávorkovat</strong>, abyste jim dali větší přednost: <code>(1 + 2) * 3</code> se vyhodnotí jako <code>9</code>.</li>
</ul>
<p>Kromě základních aritmetických operací C podporuje také <a href="https://cs.wikipedia.org/wiki/Bitov%C3%A1_operace">bitové operace</a>:</p>
<ul>
<li>AND: operátor <code>&amp;</code></li>
<li>OR: operátor <code>|</code></li>
<li>XOR: operátor <code>^</code></li>
</ul>
<h3><a class="header" href="#tabulka-aritmetických-operátorů" id="tabulka-aritmetických-operátorů">Tabulka aritmetických operátorů</a></h3>
<p>Zde je pro přehlednost tabulka se základními aritmetickými operátory.
Datový typ výsledku těchto operátorů záleží na datovém typu jejich parametrů.</p>
<table><thead><tr><th align="center">Operátor</th><th align="center">Popis</th><th align="center">Příklad</th></tr></thead><tbody>
<tr><td align="center"><code>+</code></td><td align="center">Sečtení</td><td align="center"><code>1 + 5</code></td></tr>
<tr><td align="center"><code>-</code></td><td align="center">Odečtení</td><td align="center"><code>2.3 - 4.8</code></td></tr>
<tr><td align="center"><code>*</code></td><td align="center">Násobení</td><td align="center"><code>3 * 8</code></td></tr>
<tr><td align="center"><code>/</code></td><td align="center">Dělení</td><td align="center"><code>4 / 2</code></td></tr>
<tr><td align="center"><code>%</code></td><td align="center">Zbytek po dělení (modulo)</td><td align="center"><code>5 % 2</code></td></tr>
<tr><td align="center"><code>&amp;</code></td><td align="center">Bitový součin</td><td align="center"><code>12 &amp; 4</code></td></tr>
<tr><td align="center"><code>|</code></td><td align="center">Bitový součet</td><td align="center"><code>12 | 4</code></td></tr>
<tr><td align="center"><code>^</code></td><td align="center">Bitový XOR</td><td align="center"><code>14 ^ 18</code></td></tr>
<tr><td align="center"><code>&lt;&lt;</code></td><td align="center">Bitový posun doprava</td><td align="center"><code>137 &lt;&lt; 2</code></td></tr>
<tr><td align="center"><code>&gt;&gt;</code></td><td align="center">Bitový posun doleva</td><td align="center"><code>140 &gt;&gt; 3</code></td></tr>
</tbody></table>
<p>O dalších typech operátorů se postupně dozvíte během semestru.
Plný seznam <em>C</em> operátorů naleznete <a href="https://en.cppreference.com/w/c/language/operator_precedence">zde</a>.</p>
<h3><a class="header" href="#explicitní-konverze" id="explicitní-konverze">Explicitní konverze</a></h3>
<p>Někdy potřebujete převést hodnoty mezi různými datovými typy. K tomu slouží <strong>operátor přetypování</strong>
(<em>cast operator</em>), který má syntaxi <code>(&lt;datový typ&gt;) &lt;výraz&gt;</code> a převede výraz na daný datový typ.
Například <code>(short) 1</code> převede výraz <code>1</code> z typu <code>int</code> na <code>short</code>. Je dobré si uvědomit, k čemu může
dojít při převodu mezi různými datovými typy:</p>
<ul>
<li>Pokud je cílový datový typ menší a převáděnou hodnotu v něm nelze reprezentovat, tak dojde k
oseknutí hodnoty. V důsledku způsobu reprezentace hodnot v počítači takováto operace odpovídá
zbytku po dělení:
<pre><code class="language-c">unsigned short a = 256;
(unsigned char) a // hodnota tohoto výrazu je 0 (256 % 256)
</code></pre>
</li>
<li>Pokud převádíte znaménkový typ na bezznaménkový a hodnota převáděného výrazu je záporná, tak nedojde
k intuitivnímu použití absolutní hodnoty<sup class='margin-toggle sidenote-number'>4</sup>. V důsledku způsobu reprezentace hodnot v počítači takováto
operace odpovídá přičtení dané hodnoty k maximální možné hodnotě cílového typu:
<pre><code class="language-c">signed char c = -50;
(unsigned char) c // hodnota tohoto výrazu je 206 (256 - 50)
</code></pre>
<span class='sidenote'><p><sup class='number'>4</sup>K tomu můžete použít například funkci <a href="http://www.cplusplus.com/reference/cstdlib/abs/">abs</a>.</p>
</span></li>
</ul>
<p>Pokud se chcete dozvědět více o tom, proč konverze mezi typy fungují tak, jak fungují, tak se podívejte
na to, jak funguje <a href="https://cs.wikipedia.org/wiki/Dvojkov%C3%BD_dopln%C4%9Bk">dvojkový doplněk</a>.</p>
<h3><a class="header" href="#hexadecimální-a-oktální-zápis-čísel" id="hexadecimální-a-oktální-zápis-čísel">Hexadecimální a oktální zápis čísel</a></h3>
<p>V <em>C</em> můžete zapisovat číselné hodnoty také pomocí oktální (osmičkové) či hexadecimální (šestnáctkové)
soustavy. Čísla začínající na <code>0</code> budou interpretována jako osmičková soustava, čísla začínající na
<code>0x</code> budou interpretována jako šestnáctková soustava:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 13;     // hodnota 13
    int b = 015;    // hodnota 13
    int c = 0xD;    // hodnota 13
    printf(&quot;%d\n&quot;, a);
    printf(&quot;%d\n&quot;, b);
    printf(&quot;%d\n&quot;, c);

    return 0;
}
</code></pre>
<h1><a class="header" href="#desetinné-číselné-typy" id="desetinné-číselné-typy">Desetinné číselné typy</a></h1>
<p>Pokud budete chtít provádět výpočty s desetinnými čísly, tak můžete využít datové typy s tzv.
<strong>plovoucí řádovou čárkou</strong> (<em>floating point numbers</em>). Hodnoty těchto datových typů umožňují udržovat
čísla sestávající se z celé a z desetinné části. Díky
tomu, jak jsou <a href="https://cs.wikipedia.org/wiki/Pohybliv%C3%A1_%C5%99%C3%A1dov%C3%A1_%C4%8D%C3%A1rka">navržena</a>,
tato čísla dokáží reprezentovat jak velmi malé, tak velmi velké hodnoty (za cenu přesnosti desetinné části).</p>
<p>V C jsou dva základní vestavěné datové typy pro práci s desetinnými čísly, liší se pouze velikostí
(a tedy i tím, jak přesně dokáží desetinná čísla reprezentovat). Oba dva typy jsou znaménkové:</p>
<table><thead><tr><th>Název</th><th align="center">Počet bytů</th><th align="center">Rozsah hodnot</th><th align="center">Přesnost</th><th align="center">Se znaménkem</th></tr></thead><tbody>
<tr><td><code>float</code></td><td align="center">4</td><td align="center">[-3.4e+38; 3.4e+38]</td><td align="center">~7 des. míst</td><td align="center"><i class="fa fa-check"></i></td></tr>
<tr><td><code>double</code></td><td align="center">8</td><td align="center">[-1.7e+308; 1.7e+308]</td><td align="center">~16 des. míst</td><td align="center"><i class="fa fa-check"></i></td></tr>
</tbody></table>
<p>Název <code>double</code> pochází z &quot;double precision&quot;, tedy dvojitá přesnost (typ <code>float</code> se také někdy označuje
pomocí &quot;single precision&quot;).</p>
<p>Pokud chcete v programu vytvořit výraz datového typu <code>double</code>, stačí napsat desetinné číslo (jako
desetinný oddělovač se používá tečka, ne čárka): <code>1O.5</code>, <code>-0.73</code>. Pokud chcete vytvořit výraz typu
<code>float</code>, tak za toto číslo ještě přidejte znak <code>f</code>: <code>10.5f</code>, <code>-0.73f</code>.</p>
<p>Pokud chcete vytisknout na výstup hodnotu datového typu <code>float</code> nebo <code>double</code>, můžete použít
<a href="c/datove_typy/../prikazy_vyrazy.html#v%C3%BDpis-v%C3%BDraz%C5%AF">zástupný znak</a> <code>%f</code>:</p>
<pre><code class="language-c">printf(&quot;Desetinne cislo: %f\n&quot;, 1.0);
</code></pre>
<h3><a class="header" href="#přesnost-desetinných-čísel" id="přesnost-desetinných-čísel">Přesnost desetinných čísel</a></h3>
<p>Je třeba si uvědomit, že desetinná čísla v počítači mají pouze konečnou přesnost a jsou reprezentována
v dvojkové soustavě:</p>
<ul>
<li>V počítači nelze reprezentovat iracionální čísla s nekonečnou přesností. Pokud tedy chcete do paměti
uložit například hodnotu <code>π</code>, budete ji muset zaokrouhlit.</li>
<li>Kvůli použití dvojkové soustavy některé desetinné hodnoty nelze vyjádřit přesně. Například číslo
\( \frac{1}{3} \) lze v desítkové soustavě vyjádřit zlomkem, ale v dvojkové soustavě toto číslo
má nekonečný desetinný rozvoj (<code>0.010101...</code>) a opět tedy nelze vyjádřit přesně:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
int main() {
    printf(&quot;%f\n&quot;, 1.0 / 3.0);
    return 0;
}
</code></pre>
</li>
</ul>
<h3><a class="header" href="#konverze-na-celé-číslo" id="konverze-na-celé-číslo">Konverze na celé číslo</a></h3>
<p>Pokud budete konvertovat desetinné číslo na celé číslo, tak dojde k &quot;useknutí&quot; desetinné části:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
int main() {
    printf(&quot;%d\n&quot;, (int) 1.6);
    printf(&quot;%d\n&quot;, (int) -1.6);
    return 0;
}
</code></pre>
<p>Toto chování odpovídá zaokrouhlení k nule, tj. kladná čísla se zaokrouhlí dolů a záporná čísla nahoru.</p>
<h1><a class="header" href="#pravdivostní-typy" id="pravdivostní-typy">Pravdivostní typy</a></h1>
<p>Posledním základním datovým typem, který si ukážeme, je pravdivostní typ
<strong><a href="https://cs.wikipedia.org/wiki/Boolean">Booleovské logiky</a></strong>. Hodnoty tohoto datového typu mají
pouze dvě možné varianty - <strong>pravda</strong> (<em>true</em>) nebo <strong>nepravda</strong> (<em>false</em>). Tento typ se hodí
zejména pro různé logické operace, například porovnávání hodnot (<code>Je a menší než b?</code> - <code>ano</code>/<code>ne</code>).</p>
<p>V C se Booleovský datový typ nazývá <code>_Bool</code>. Nicméně tento název je docela krkolomný, obvykle se proto
používá místo něho typ <code>bool</code>. Abyste ho mohli použít, tak na začátek programu musíte vložit řádek
<code>#include &lt;stdbool.h&gt;</code>. <a href="c/datove_typy/../preprocesor/vkladani_souboru.html">Později</a> si vysvětlíme, co tento řádek
dělá.</p>
<pre><code class="language-c editable mainbody">#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;

int main() {
    bool venku_je_hezky = true;
    bool upr_je_slozite = false;

    printf(&quot;%d\n&quot;, venku_je_hezky);
    printf(&quot;%d\n&quot;, upr_je_slozite);

    return 0;
}
</code></pre>
<p>Jak lze v ukázce výše vidět, <code>true</code> reprezentuje pravdivý Booleovský výraz a <code>false</code> nepravdivý
Booleovský výraz a <code>bool</code> hodnoty lze vytisknout na výstup stejným způsobem jako celočíselné hodnoty.<sup class='margin-toggle sidenote-number'>1</sup>
Hodnoty Booleovského typu obvykle zabírají v paměti jeden <em>byte</em>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Při výpisu dojde ke <a href="c/datove_typy/pravdivostni_typy.html#konverze">konverzi</a> <code>bool</code>u na celé číslo.</p>
</span>
<h3><a class="header" href="#logické-operace" id="logické-operace">Logické operace</a></h3>
<p>V (Booleovské) logice existují tři základní operátory:</p>
<ul>
<li><strong>logický součin</strong> (<em>AND</em>): <code>X a zároveň Y</code></li>
<li><strong>logický součet</strong> (<em>OR</em>): <code>X nebo Y</code></li>
<li><strong>logická negace</strong> (<em>NOT</em>): <code>neplatí X</code></li>
</ul>
<p>Tyto logické operace lze v C použít pomocí následujících operátorů:</p>
<ul>
<li><strong>AND</strong>: <code>&amp;&amp;</code></li>
<li><strong>OR</strong>: <code>||</code></li>
<li><strong>NOT</strong>: <code>~</code></li>
</ul>
<p>Tyto operátory můžete použít mezi dvěmi výrazy datového typu <code>bool</code>. Například:</p>
<pre><code class="language-c">bool je_muz = true;
bool je_zena = false;
bool je_clovek = je_muz || je_zena; // true || false -&gt; true

bool je_rodic = true;
bool je_otec = je_rodic &amp;&amp; je_muz;  // true &amp;&amp; true -&gt; true
bool je_matka = je_rodic &amp;&amp; ~je_otec; // true &amp;&amp; ~true -&gt; true &amp;&amp; false -&gt; false
</code></pre>
<p>Pro připomenutí, zde je pravdivostní tabulka těchto logických operátorů:</p>
<table><thead><tr><th><code>X</code></th><th align="center"><code>Y</code></th><th align="center"><code>X &amp;&amp; Y</code></th><th align="center"><code>X || Y</code></th><th align="center"><code>~X</code></th></tr></thead><tbody>
<tr><td><code>false</code></td><td align="center"><code>false</code></td><td align="center"><code>false</code></td><td align="center"><code>false</code></td><td align="center"><code>true</code></td></tr>
<tr><td><code>false</code></td><td align="center"><code>true</code></td><td align="center"><code>false</code></td><td align="center"><code>true</code></td><td align="center"><code>true</code></td></tr>
<tr><td><code>true</code></td><td align="center"><code>false</code></td><td align="center"><code>false</code></td><td align="center"><code>true</code></td><td align="center"><code>false</code></td></tr>
<tr><td><code>true</code></td><td align="center"><code>true</code></td><td align="center"><code>true</code></td><td align="center"><code>true</code></td><td align="center"><code>false</code></td></tr>
</tbody></table>
<h3><a class="header" href="#porovnávání-hodnot" id="porovnávání-hodnot">Porovnávání hodnot</a></h3>
<p>Při programování často potřebujete porovnat hodnoty mezi sebou:</p>
<ul>
<li><code>Má Jarda více bodů než Kamil?</code></li>
<li><code>Má uživatelovo heslo více než 5 znaků?</code></li>
<li><code>Má Lenka na účtu alespoň 100 dolarů?</code></li>
</ul>
<p>K tomu slouží šest základních porovnávacích operátorů:</p>
<ul>
<li><strong>Rovná se</strong><sup class='margin-toggle sidenote-number'>2</sup>: <code>==</code><span class='sidenote'><p><sup class='number'>2</sup>Zde si dávejte velký pozor na rozdíl mezi <code>=</code> (přiřazení hodnoty) a <code>==</code> (porovnání dvou hodnot).
Záměna těchto dvou operátorů je častou začátečnickou chybou a vede k obtížně nalezitelným chybám.</p>
</span></li>
<li><strong>Nerovná se</strong>: <code>!=</code></li>
<li><strong>Větší</strong>: <code>&gt;</code></li>
<li><strong>Větší nebo rovno</strong>: <code>&gt;=</code></li>
<li><strong>Menší</strong>: <code>&lt;</code></li>
<li><strong>Menší nebo rovno</strong>: <code>&lt;=</code></li>
</ul>
<p>Porovnávat mezi sebou můžete libovolné hodnoty dvou stejných datových typů. Výsledkem porovnání
je výraz datového typu <code>bool</code>:</p>
<pre><code class="language-c">int jarda_body = 10;
int kamil_body = 13;

bool remize = jarda_body == kamil_body; // false
bool vyhra_jardy = jarda_body &gt; kamil_body; // true

int delka_hesla = 8;
bool heslo_moc_kratke = delka_hesla &lt;= 5; // false
</code></pre>
<p>Dávejte si ovšem pozor na to, že pouze operátory <code>==</code> a <code>!=</code> lze použít univerzálně na všechny datové typy.
Například použít <code>&lt;</code> pro porovnání dvou Booleovských hodnot obvykle nedává valný smysl, operátory
<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> a <code>&gt;=</code> jsou obvykle využívány pouze pro porovnávání čísel.</p>
<p>Porovnávání hodnot můžete zkombinovat s logickými operátory pro vyhodnocení komplexních pravdivostních
výrazů:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;

int main() {
    int delka_hesla = 8;
    bool email_overen = false;
    int rok_narozeni = 1994;

    bool uzivatel_validni = delka_hesla &gt;= 9 &amp;&amp; (email_overen || rok_narozeni &gt; 1990); // false
    bool uzivatel_validni2 = delka_hesla &gt;= 9 &amp;&amp; email_overen || rok_narozeni &gt; 1990; // true

    printf(&quot;%d\n&quot;, uzivatel_validni);
    printf(&quot;%d\n&quot;, uzivatel_validni2);

    return 0;
}
</code></pre>
<p>Zde je opět třeba dávat si pozor na <a href="https://en.cppreference.com/w/c/language/operator_precedence">prioritu operátorů</a>
(například <code>&amp;&amp;</code> má větší prioritu než <code>||</code>) a v případě potřeby výrazy uzávorkovat. Pokud si zkusíte
přeložit tento program, tak vás dokonce překladač bude varovat před tím, že jste výraz neuzávorkovali a
může tak vracet jiný výsledek, než očekáváte.</p>
<h3><a class="header" href="#tabulka-logických-operátorů" id="tabulka-logických-operátorů">Tabulka logických operátorů</a></h3>
<p>Zde je pro přehlednost tabulka s logickými operátory.
Datový typ výsledku je u těchto operátorů vždy <code>bool</code>.</p>
<table><thead><tr><th align="center">Operátor</th><th align="center">Popis</th><th align="center">Příklad</th></tr></thead><tbody>
<tr><td align="center"><code>&amp;&amp;</code></td><td align="center">Logický součin (AND)</td><td align="center"><code>a == b &amp;&amp; c &gt;= d</code></td></tr>
<tr><td align="center"><code>||</code></td><td align="center">Logický součet (OR)</td><td align="center"><code>a &lt; b || c == d</code></td></tr>
<tr><td align="center"><code>!</code></td><td align="center">Logická negace (NOT)</td><td align="center"><code>!(a &gt; b &amp;&amp; c &lt; d)</code></td></tr>
<tr><td align="center"><code>==</code></td><td align="center">Rovná se</td><td align="center"><code>a == 5</code></td></tr>
<tr><td align="center"><code>!=</code></td><td align="center">Nerovná se</td><td align="center"><code>a != 5</code></td></tr>
<tr><td align="center"><code>&gt;</code></td><td align="center">Větší než</td><td align="center"><code>a &gt; 5</code></td></tr>
<tr><td align="center"><code>&gt;=</code></td><td align="center">Větší nebo rovno než</td><td align="center"><code>a &gt;= 5</code></td></tr>
<tr><td align="center"><code>&lt;</code></td><td align="center">Menší než</td><td align="center"><code>a &lt; 5</code></td></tr>
<tr><td align="center"><code>&lt;=</code></td><td align="center">Menší nebo rovno než</td><td align="center"><code>a &lt;= 5</code></td></tr>
</tbody></table>
<h3><a class="header" href="#zkrácené-vyhodnocování" id="zkrácené-vyhodnocování">Zkrácené vyhodnocování</a></h3>
<p>Při vyhodnocování Booleovských výrazů s logickými operátory se v C používá tzv. <strong>zkrácené vyhodnocování</strong>
(<em>short-circuit evaluation</em>). Například pokud se vyhodnocuje výraz <code>a || b</code>, tak může dojít k následující
situaci:</p>
<ul>
<li>Počítač vše provádí v sekvenčních krocích, tj. nejprve vyhodnotí <code>a</code>.</li>
<li>Pokud má výraz <code>a</code> hodnotu <code>true</code>, tak už je jasné, že celý výraz <code>a || b</code> bude mít hodnotu <code>true</code>.</li>
<li>K vyhodnocení výrazu <code>b</code> tak už nedojde, protože je to zbytečné.</li>
</ul>
<p>Toto chování může urychlit provádění programu, protože přeskakuje provádění zbytečných příkazů,
nicméně může také způsobit nečekané chyby. Pokud by například vyhodnocení výrazu <code>b</code> obsahovalo nějaké
<a href="c/datove_typy/../prikazy_vyrazy.html#vedlej%C5%A1%C3%AD-efekty">vedlejší efekty</a>, které se projeví při jeho provedení (například
změna hodnoty v paměti), tak může být problematické, pokud se vyhodnocení tohoto výrazu zcela
přeskočí. Pokud si pamatujete na <a href="c/datove_typy/../promenne/slozeny_zapis.html#inkrementace-a-dekrementace">inkrementaci</a>,
tak ta je jedním z případů výrazů, které mají vedlejší efekt (změnu hodnoty proměnné).</p>
<h3><a class="header" href="#konverze" id="konverze">Konverze</a></h3>
<p>Pokud se pokusíte o převod celého či desetinného čísla na <code>bool</code>, tak můžou nastat dvě varianty:</p>
<ul>
<li>Pokud je číslo nenulové, výsledkem bude <code>true</code>.</li>
<li>Pokud je číslo nula, výsledkem bude <code>false</code>.</li>
</ul>
<p>V opačném směru (konverze <code>bool</code> u na číslo) dojde k následující konverzi:</p>
<ul>
<li><code>true</code> se převede na <code>1</code></li>
<li><code>false</code> se převede na <code>0</code></li>
</ul>
<h1><a class="header" href="#Řízení-toku" id="Řízení-toku">Řízení toku</a></h1>
<p>Pokud by počítače program vždy pouze vykonaly od začátku do konce a provedly pokaždé ty stejné
operace, tak by nebyly moc užitečné. Sice by zvládly něco rychle vypočítat, ale už ne se rozhodovat,
jakou operaci mají provést, nebo nějakou operaci provádět opakovaně, což jsou velmi užitečné vlastnosti.</p>
<p>Instrukce programu se běžně vykonávají (&quot;tečou&quot;) jedna po druhé (&quot;odshora dolů&quot;). <em>C</em> obsahuje příkazy
pro tzv. <strong>řízení toku</strong> (<em>control flow</em>), které můžou toto vykonávání instrukcí ovlivnit:</p>
<ul>
<li><a href="c/rizeni_toku/podminky.html">Podmínky</a> umožňují vykonat kus kódu, pouze pokud platí nějaký výraz. Díky tomu se
můžeme rozhodnout, zda nějakou operaci provést, nebo ne, v závislosti na vstupu programu.</li>
<li><a href="c/rizeni_toku/cykly.html">Cykly</a> umožňují vykonávat kus kódu opakovaně. Díky tomu můžeme například provést nějakou
operaci pro všechny prvky ze vstupu programu anebo ji provádět, dokud nedojde ke splnění nějaké podmínky.</li>
</ul>
<p>Ač se to možná nezdá, proměnné, podmínky a cykly bohatě stačí k tomu, abyste byli schopni
napsat libovolný počítačový program. Pomocí těchto tří jednoduchých konstrukcí byste tak teoreticky
mohli vytvořit třeba textový editor, hru nebo i celý operační systém. Nicméně, pokud bychom využívali
pouze tyto konstrukce, tak ve větších programech by bylo složité se zorientovat a byly by také dost
neefektivní. Proto si v příštích sekcích ukážeme několik dalších konstrukcí, které vám můžou
programování usnadnit.</p>
<h1><a class="header" href="#podmínky" id="podmínky">Podmínky</a></h1>
<p>V programech se často potřebujeme rozhodnout, co by se mělo provést, v závislosti na hodnotě nějakého
výrazu:</p>
<ul>
<li>Pokud uživatel nakoupil zboží v posledním týdnu, odešli mu e-mail.</li>
<li>Zadal uživatel správné heslo? Pokud ano, tak ho přesměruj na jeho profil. Pokud ne, tak zobraz chybovou hlášku.</li>
<li>Jaké má uživatel konto? Pokud kladné, tak ho vykresli zelenou barvou, pokud záporné, tak červenou a
pokud nulové, tak černou.</li>
</ul>
<p>V <em>C</em> můžeme provádět takováto rozhodnutí pomocí <strong>podmínek</strong> (<em>conditions</em>). Základním příkazem
pro tzv. <strong>podmíněné vykonání</strong> kódu je podmínka <code>if</code>:</p>
<pre><code class="language-c">if (&lt;výraz typu bool&gt;) {
    // blok kódu
}
</code></pre>
<p>Pokud se výraz předaný <code>if</code>u vyhodnotí jako <code>true</code> (pravda), tak se provede
<a href="c/rizeni_toku/../promenne/promenne.html#definice-a-platnost">blok</a> kódu uvnitř <code>if</code>u tak, jak jste zvyklí, a program dále
bude pokračovat za příkazem <code>if</code>. Pokud se však výraz vyhodnotí jako <code>false</code> (nepravda), tak se blok kódu
uvnitř <code>if</code>u vůbec neprovede. V následujícím programu zkuste změnit výraz uvnitř závorek za <code>if</code> tak,
aby se blok v podmínce vykonal:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int password_length = 5;

    printf(&quot;Checking password...\n&quot;);
    if (password_length &gt; 5) {
        printf(&quot;Password is long enough\n&quot;);
    }
    printf(&quot;Password check completed\n&quot;);

    return 0;
}
</code></pre>
<blockquote>
<p>Anglické slovo <code>if</code> znamená v češtině <code>Jestliže</code>. Všimněte si tak, že kód výše můžete přečíst jako
anglickou větu, která bude mít stejný význam jako uvedený <em>C</em> kód: <code>Jestliže je délka hesla větší než pět, tak (proveď kód v bloku)</code>.</p>
</blockquote>
<h3><a class="header" href="#provádění-alternativ" id="provádění-alternativ">Provádění alternativ</a></h3>
<p>Často v programu chceme provést jednu ze dvou (nebo více) alternativ, opět v závislosti na hodnotě
nějakého výrazu. To sice můžeme provést pomocí několika <code>if</code> příkazů za sebou:</p>
<pre><code class="language-c">if (points &gt; 90) { grade = 1; }
if (points &lt;= 90 &amp;&amp; points &gt; 80) { grade = 2; }
if (points &lt;= 80 &amp;&amp; points &gt; 50) { grade = 3; }
...
</code></pre>
<p>Nicméně to může být často dost zdlouhavé. <em>C</em> tak umožňuje přidat k příkazu <code>if</code> příkaz, který se provede
v případě, že výraz v podmínce <code>if</code> není splněn. Takto lze řetězit více podmínek za sebou, kdy v každé
následující podmínce víme, že žádná z předchozích nebyla splněna. Dosáhneme toho tak, že za blokem podmínky
<code>if</code> použijeme klíčové slovo <code>else</code> (&quot;v opačném případě&quot;):</p>
<pre><code class="language-c">if (&lt;výraz typu bool&gt;) {
    // blok kódu
} else ...
</code></pre>
<p>Pokud za blok podmínky <code>if</code> přidáte <code>else</code>, tak se program začne vykonávat za <code>else</code>, pokud výraz
podmínky není splněn. Za <code>else</code> pak může následovat:</p>
<ul>
<li>
<p>Blok kódu, který se rovnou provede:</p>
<pre><code class="language-c">if (points &gt; 90) {
    // blok A
} else {
    // blok B
}
// X
</code></pre>
<p>Pokud platí <code>points &gt; 90</code>, provede se blok A, pokud ne, tak se provede blok B. V obou případech
bude dále program vykonávat kód od bodu <code>X</code>.</p>
</li>
<li>
<p>Další <code>if</code> podmínka, která je opět vyhodnocena. Takovýchto podmínek může následovat libovolný počet:</p>
<pre><code class="language-c">if (points &gt; 90) {
    // blok A, více než 90 bodů
} else if (points &gt; 80) {
    // blok B, méně než 91 bodů, ale více než 80 bodů
} else if (points &gt; 70) {
    // blok C, méně než 81 bodů, ale více než 70 bodů
}
// X
</code></pre>
<p>Takovéto spojené podmínky se vyhodnocují postupně shora dolů. První podmínka <code>if</code>, jejíž výraz
je vyhodnocen jako <code>true</code>, způsobí, že se provede blok této podmínky, a následně program pokračuje
za celou spojenou podmínkou (bod <code>X</code>).</p>
<p>Na konec spojené podmínky můžete opět vložit i <code>else</code> s blokem bez podmínky. Tento blok se
provede pouze, pokud žádná z předchozích podmínek není splněna:</p>
<pre><code class="language-c">if (points &gt; 90) {
    // blok A, více než 90 bodů
} else if (points &gt; 80) {
    // blok B, méně než 90 bodů, ale více než 80 bodů
} else {
    // blok C, méně než 81 bodů
}
</code></pre>
<p>Všimněte si, že tento kód opět můžeme přečíst jako intuitivní anglickou větu. Pokud je počet
bodů vyšší, než 90, tak proveď A. V opačném případě, pokud je vyšší než 80, tak proveď B. Jinak
proveď C.</p>
</li>
</ul>
<p><strong>Cvičení</strong>: Upravte následující program, aby vypsal:</p>
<ul>
<li><code>Student uspel s vyznamenanim</code>, pokud je hodnota <code>points</code> větší než <code>90</code>.</li>
<li><code>Student uspel</code>, pokud je hodnota <code>points</code> v (uzavřeném) intervalu <code>[51, 90]</code>.</li>
<li><code>Student neuspel</code>, pokud je hodnota <code>points</code> menší než <code>51</code>.</li>
</ul>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int points = 50;

    printf(&quot;Student uspel\n&quot;);

    return 0;
}
</code></pre>
<h3><a class="header" href="#vnořování-podmínek" id="vnořování-podmínek">Vnořování podmínek</a></h3>
<p>Někdy potřebujeme zkontrolovat složitou podmínku (nebo sadu podmínek). Jelikož podmínky jsou <em>příkazy</em>
a bloky kódu můžou obsahovat libovolné příkazy, tak vám nic nebrání v tom podmínky <em>vnořovat</em>:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int password_length = 4;
    int username_length = 3;
    if (password_length &gt; 5) {
        if (username_length &gt; 3) {
            printf(&quot;Uzivatel byl zaregistrovan\n&quot;);
        } else {
            printf(&quot;Uzivatelske jmeno neni dostatecne dlouhe\n&quot;);
        }
    } else {
        printf(&quot;Heslo neni dostatecne dlouhe\n&quot;);
    }

    return 0;
}
</code></pre>
<p><strong>Cvičení</strong>: Upravte hodnotu proměnných v programu výše tak, aby program vypsal <code>Uzivatel byl zaregistrovan</code>.
Neměňte v programu nic jiného.</p>
<h4><a class="header" href="#vynechání-složených-zárovek" id="vynechání-složených-zárovek">Vynechání složených zárovek</a></h4>
<p>Za <code>if</code> nebo <code>else</code> můžete vynechat složené závorky (<code>{</code>, <code>}</code>). V takovém případě se bude podmínka
vztahovat k (jednomu) příkazu následujícímu za <code>if/else</code>:</p>
<pre><code class="language-c">if (points&gt; 80) printf(&quot;Student uspel\n&quot;);
else printf(&quot;Student neuspel\n&quot;);
</code></pre>
<h3><a class="header" href="#ternární-operátor" id="ternární-operátor">Ternární operátor</a></h3>
<p>Občas chcete použít jeden ze dvou výrazů v závislosti na hodnotě nějaké podmínky. Například pokud byste
chtěli přiřadit minimum ze dvou hodnot do proměnné:</p>
<pre><code class="language-c">int a = 1;
int b = 5;

int c = 0;
if (a &lt; b) {
    c = a;
} else {
    c = b;
}
</code></pre>
<p>Toto lze provést zkráceně pomocí výrazu <strong>ternárního operátoru</strong> (<em>ternary operator</em>). Tento výraz
má následující syntaxi:</p>
<pre><code class="language-c">&lt;výraz X typu bool&gt; ? &lt;výraz A&gt; : &lt;výraz B&gt;
</code></pre>
<p>Pokud je výraz <code>X</code> pravdivý, tak se ternární operátor vyhodnotí jako hodnota výrazu <code>A</code>, v opačném
případě se vyhodnotí jako hodnota výrazu <code>B</code>. Uhodnete, co vypíše následující program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int a = 1;
    int b = 5;
    int c = (a &gt;= b) ? a - b : a + b;
    printf(&quot;%d\n&quot;, c);

    return 0;
}
</code></pre>
<h1><a class="header" href="#příkaz-switch" id="příkaz-switch">Příkaz <code>switch</code></a></h1>
<p>V případě, že byste chtěli provést rozlišný kód v závislosti na hodnotě nějakého výrazu,
a tento výrazu (např. proměnná) může nabývat více různých hodnot, tak může být zdlouhavé použít
spoustu <code>if</code>ů:</p>
<pre><code class="language-c">if (a == 0) {
    ...
}
else if (a == 1) {
    ...
}
else if (a == 2) {
    ...
}
...
</code></pre>
<p>Jako jistá zkratka může sloužit příkaz <code>switch</code>. Ten má následující syntaxi:</p>
<pre><code class="language-c">switch (&lt;výraz&gt;) {
    case &lt;hodnota A&gt;: &lt;blok kódu&gt;
    case &lt;hodnota B&gt;: &lt;blok kódu&gt;
    case &lt;hodnota C&gt;: &lt;blok kódu&gt;
    ...
}
</code></pre>
<p>Tento příkaz vyhodnotí předaný výraz, a pokud se ve <code>switch</code>i nachází klíčové slovo <code>case</code> následované
hodnotou odpovídající hodnotě výrazu, tak program skočí na blok, který následuje za <code>case</code>. Dále se program
bude vykonávat sekvenčně až do konce <code>switch</code>e (pak už se <code>case</code> ignoruje).</p>
<p>Tento program vypíše <code>52</code>, protože předaný výraz má hodnotu <code>5</code>, takže program skočí na blok za
<code>case 5</code> a dále pokračuje sekvenčně až do konce bloku <code>switch</code> příkazu.</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    switch (5) {
        case 0: printf(&quot;0&quot;);
        case 1: printf(&quot;1&quot;);
        case 5: printf(&quot;5&quot;);
        case 2: printf(&quot;2&quot;);
    }

    return 0;
}
</code></pre>
<p>Do <code>switch</code>e lze předat i blok pojmenovaný <code>default</code>, na který program skočí v případě, že se
nenalezne žádný <code>case</code> s odpovídající hodnotou:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    switch (10) {
        case 0: printf(&quot;0&quot;);
        case 1: printf(&quot;1&quot;);
        case 5: printf(&quot;5&quot;);
        case 2: printf(&quot;2&quot;);
        default: printf(&quot;nenalezeno&quot;);
    }

    return 0;
}
</code></pre>
<p>Velmi často chcete provést pouze jeden blok kódu u jednoho <code>case</code> a nepokračovat po něm až do konce
celého <code>switch</code> bloku. Běžně se tedy za každým <code>case</code> blokem používá příkaz <code>break</code>, který ukončí
provádějí celého <code>switch</code> příkazu:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    switch (1) {
        case 0: printf(&quot;0&quot;); break;
        case 1: printf(&quot;1&quot;); break;
        case 2: printf(&quot;2&quot;); break;
        default: printf(&quot;nenalezeno&quot;);
    }

    return 0;
}
</code></pre>
<h1><a class="header" href="#cykly" id="cykly">Cykly</a></h1>
<p>V programech chceme často provádět nějakou operaci opakovaně, například:</p>
<ul>
<li>Pro každý záznam v databázi vypiš řádek do souboru.</li>
<li>Pošli zprávu každému účastníkovi chatu.</li>
<li>Načítej řádky ze souboru, dokud nedojdeš na konec souboru.</li>
</ul>
<p>Pokud bychom používali pouze sekvenční zápis příkazů, tak bychom museli neustále kopírovat
(&quot;copy-pastovat&quot;) kód:</p>
<pre><code class="language-c">printf(&quot;0\n&quot;);
printf(&quot;1\n&quot;);
printf(&quot;2\n&quot;);
...
</code></pre>
<p>což by vedlo k nepřehledným programům<sup class='margin-toggle sidenote-number'>1</sup>. Pokud bychom navíc našli v programu chybu, museli bychom ji
opravit na všech místech, kam jsme kód zkopírovali.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Představte si, že chcete na výstup programu nebo do souboru vypsat třeba tisíc různých řádků textu.</p>
</span>
<p>Ani s kopírováním kódu bychom si však nevystačili, pokud bychom potřebovali provádět kód opakovaně
v závislosti na vstupu programu. Představte si situaci, kdy nám uživatel na vstup programu zadá číslo,
kolikrát má náš program vypsat nějaký řádek textu na výstup. Uživatel se při každém spuštění programu
může rozhodnout pro jiné číslo, <code>0</code>, <code>1</code>, <code>42</code>, <code>1000</code>. Program však zůstává stále stejný - při jeho
psaní se musíme rozhodnout, kolik příkazů pro výpis v něm použijeme, a už poté nemůžeme jednoduše
tuto volbu změnit, když program běží. Takovýto program bychom tedy zatím (pouze pomocí proměnných a
podmínek) neměli jak naprogramovat. </p>
<p>Proto programovací jazyky nabízí tzv. <strong>cykly</strong> (<em>loops</em>), pomocí kterých můžeme jednoduše říct
počítači, aby určitý blok kódu opakoval, kolikrát budeme chtít. Díky tomu může program i s pouze
několika málo řádky kódu říct počítači, aby provedl spoustu instrukcí. Jazyk <em>C</em> nabízí dva základní
typy cyklů, <a href="c/rizeni_toku/while.html">while</a> a <a href="c/rizeni_toku/for.html">for</a>.</p>
<blockquote>
<p>Další motivací pro využití cyklů je to, že moderní procesory počítačů mají běžně frekvence od
1 do 4 GHz, takže za vteřinu zvládnou provést několik několik miliard
<a href="https://cs.wikipedia.org/wiki/Hodinov%C3%BD_sign%C3%A1l">taktů</a> a během každého taktu navíc až
<a href="https://cs.wikipedia.org/wiki/Superskal%C3%A1rn%C3%AD_architektura">desítky</a> různých operací.
Jistě si dovedete představit, že s pouze sekvenčním zápisem kódu bychom tento potenciál nemohli
naplno využít. I když jeden řádek <em>C</em> kódu může být přeložen až na desítky procesorových instrukcí,
tak i kdybychom zvládli napsat program se stovkami milionů řádek, pořád bychom takovýmto programem
&quot;zabavili&quot; procesor na pouhou vteřinu. Běžící programy tak obvykle tráví většinu času prováděním
nějakého cyklu.</p>
</blockquote>
<h1><a class="header" href="#cyklus-while" id="cyklus-while">Cyklus <code>while</code></a></h1>
<p>Nejjednodušším cyklem v <em>C</em> je cyklus <code>while</code> (&quot;dokud&quot;):</p>
<pre><code class="language-c">while (&lt;výraz typu bool&gt;) {
    // blok cyklu
}
</code></pre>
<p>Funguje následovně:</p>
<ol>
<li>Nejprve se vyhodnotí (Booleovský) výraz v závorce za <code>while</code>.</li>
<li>Pokud výraz není pravdivý, tak se provede bod 3.
Pokud je výraz pravdivý, tak se provede blok<sup class='margin-toggle sidenote-number'>1</sup> cyklu a dále se pokračuje bodem 1.<span class='sidenote'><p><sup class='number'>1</sup>Blok cyklu se také často nazývá jako <strong>tělo</strong> (<em>body</em>) cyklu.</p>
</span></li>
<li>Program pokračuje za cyklem <code>while</code>.</li>
</ol>
<p>Jinak řečeno, dokud bude splněná podmínka za <code>while</code>, tak se bude opakovaně provádět tělo cyklu.
Vyzkoušejte si to na následujícím příkladu:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int count = 0;
    while (count &lt; 5) {
        printf(&quot;Telo cyklu se provedlo\n&quot;);
        count = count + 1;
    }
    return 0;
}
</code></pre>
<p>Tento kód opět můžeme přečíst jako větu: <code>Dokud je hodnota proměnná menší než pět, prováděj tělo cyklu</code>. Jedno vykonání těla cyklu se nazývá <strong>iterace</strong>. Cyklus v ukázce výše tedy provede pět iterací,
protože se tělo cyklu provede pětkrát.</p>
<p>Pokud výraz za <code>while</code> není splněn, když se <code>while</code> začne vykonávat, tak se tělo cyklu nemusí
provést ani jednou (tj. bude mít nula iterací).</p>
<p>Je důležité dávat si pozor na to, aby cyklus, který použijeme, nebyl nechtěně <strong>nekonečný</strong>
(<em>infinite loop</em>), jinak by náš program nikdy neskončil. Zkuste v kódu výše zakomentovat nebo odstranit
řádek <code>count = count + 1;</code> a zkuste program spustit. Jelikož se hodnota proměnné <code>count</code> nebude nijak
měnit, tak výraz <code>count &lt; 5</code> bude stále pravdivý a cyklus se tak bude provádět neustále dokola.
Této situaci se lidově říká &quot;zacyklení&quot;<sup class='margin-toggle sidenote-number'>2</sup>. Po spuštění nekonečného cyklu v prohlížeči radši
restartujte tuto stránku :)</p>
<span class='sidenote'><p><sup class='number'>2</sup>Pokud program spouštíte v terminálu a zacyklí se, můžete ho přerušit pomocí klávesové zkratky <code>Ctrl + C</code>.</p>
</span>
<h3><a class="header" href="#Řídící-proměnná" id="Řídící-proměnná">Řídící proměnná</a></h3>
<p>Často chceme provést v těle cyklu jinou operaci v závislosti na tom, která iterace se zrovna vykonává.
K tomu obvykle slouží tzv. <strong>řídící proměnná</strong> (<em>index variable</em>), která udává, v jaké iteraci cyklu
se nacházíme, a podle ní se poté provede odpovídající operace. Například pokud bychom chtěli vypsat
na výstup řadu čísel <code>0</code> až <code>4</code>, tak to můžeme provést s <code>while</code> cyklem následovně:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int i = 0;
    while (i &lt; 5) {    
        printf(&quot;%d\n&quot;, i);
        i += 1;
    }
    return 0;
}
</code></pre>
<p>Řídící proměnná je zde <code>i</code> - tento název se pro řídící proměnné pro jednoduchost často používá.</p>
<h3><a class="header" href="#Řízení-toku-cyklu" id="Řízení-toku-cyklu">Řízení toku cyklu</a></h3>
<p>V cyklech můžete využívat dva speciální příkazy, které fungují pouze v těle nějakého cyklu:</p>
<ul>
<li>Příkaz <code>continue;</code> způsobí, že se přestane vykonávat tělo cyklu, a program se vrátí
na začátek cyklu (tedy u <code>while</code> na vyhodnocení výrazu). <code>continue</code> lze chápat jako skok na další
iteraci cyklu. Zkuste uhodnout, co vypíše následující kód:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int count = 0;
    while (count &lt; 10) {
        count = count + 1;

        if (count &lt; 5) continue;

        printf(&quot;Hodnota count: %d\n&quot;, count); 
    }

    return 0;
}
</code></pre>
</li>
<li>Příkaz <code>break;</code> způsobí, že se cyklus přestane vykonávat a program začne vykonávat kód, který
následuje za cyklem. Cyklus se tak zcela přeruší. Zkuste uhodnout, co vypíše následující kód:
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int count = 0;
    while (count &lt; 10) {
        if (count * 2 &gt; 12) break;

        printf(&quot;Hodnota count: %d\n&quot;, count);
        count = count + 1;
    }

    return 0;
}
</code></pre>
</li>
</ul>
<details>
<summary>Tip pro návrh cyklů while</summary>
<p>Příkaz <code>break</code> lze také někdy použít k usnadnění návrhu cyklů. Pokud potřebujete napsat <code>while</code> cyklus
s nějakou složitou podmínkou ukončení, ze které se vám motá hlava, zkuste nejprve vytvořit &quot;nekonečný&quot;
cyklus pomocí <code>while (true) { ... }</code>, dále vytvořte tělo cyklu a až poté přidejte dovnitř cyklu
podmínku, která cyklus ukončí pomocí příkazu <code>break</code>:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int count = 0;
    int count2 = 1;
    while (1) {
        printf(&quot;Hodnota count: %d\n&quot;, count);
        count = count + 1;
        count2 += count;

        if (count &gt; 100) break;
        if (count * 3 + count2 / count &gt; count / 8) break;
    }

    return 0;
}
</code></pre>
<p>Nemusíte tak hned ze začátku vymýšlet výraz pro <code>while</code>, na čemž byste se mohli zaseknout. </p>
<p>Místo <code>while (true)</code> můžete použít také <code>while (1)</code>, protože <code>1</code> se při převodu na <code>bool</code> převede
na <code>true</code>.</p>
</details>
<h3><a class="header" href="#vnořování-cyklů" id="vnořování-cyklů">Vnořování cyklů</a></h3>
<p>Stejně jako podmínky, i cykly jsou příkazy, a můžete je tak používat libovolně v blocích <em>C</em> kódu
a také je <a href="c/rizeni_toku/podminky.html#vno%C5%99ov%C3%A1n%C3%AD-podm%C3%ADnek">vnořovat</a>. Chování vnořených cyklů může být ze začátku
trochu neintuitivní, proto je dobré si je procvičit. Zkuste si pomocí
<a href="c/rizeni_toku/../../prostredi/ladeni.html#krokov%C3%A1n%C3%AD">debuggeru</a> krokovat následující kód, abyste pochopili, jak se
provádí, a zkuste odhadnout, jakých hodnot budou postupně nabývat proměnné <code>i</code> a <code>j</code>. Poté odkomentujte
výpisy <code>printf</code> a ověřte, jestli byl váš odhad správný:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int i = 0;
    while (i &lt; 3) {
        // printf(&quot;i: %d\n&quot;, i);
        int j = 0;
        while (j &lt; 4) {
            // printf(&quot;  j: %d\n&quot;, j);
            j = j + 1;
        }

        i = i + 1;
    }

    return 0;
}
</code></pre>
<p>Pro každou iteraci &quot;vnějšího&quot; <code>while</code> cyklu se provedou čtyři iterace &quot;vnitřního&quot; <code>while</code> cyklu.
Dohromady se tak provede celkem <code>3 * 4</code> iterací.</p>
<h3><a class="header" href="#cyklus-do-while" id="cyklus-do-while">Cyklus <code>do while</code></a></h3>
<p>Cyklus <code>while</code> má také alternativu zvanou <code>do while</code>. Tento cyklus má následující syntaxi:</p>
<pre><code class="language-c">do {
    // tělo cyklu
}
while (&lt;výraz typu bool&gt;);
</code></pre>
<p>Tento kód můžeme číst jako <code>Dělej &lt;tělo cyklu&gt;, dokud platí &lt;výraz&gt;</code>.</p>
<p>Jediný rozdíl mezi <code>while</code> a <code>do while</code> je, že v cyklu <code>do while</code> se výraz, který určuje, jestli se má
provést další iterace cyklu, vyhodnocuje až na konci cyklu. Tělo cyklu tak bude pokaždé provedeno
alespoň jednou (i kdyby byl výraz od začátku nepravdivý).</p>
<p>Pokud pro to nemáte zvláštní důvod, asi není třeba tento typ cyklu používat.</p>
<h1><a class="header" href="#cyklus-for" id="cyklus-for">Cyklus <code>for</code></a></h1>
<p>V programech velmi často potřebujeme vykonat nějaký blok kódu přesně <code>n</code>-krát:</p>
<ul>
<li>Projdi <code>n</code> řádků ze vstupního souboru a sečti jejich hodnoty.</li>
<li>Pošli zprávu všem <code>n</code> účastníkům chatu.</li>
<li>Vystřel přesně třikrát ze zbraně.</li>
</ul>
<p>I když pomocí cyklu <code>while</code> můžeme vyjádřit provedení <code>n</code> iterací, je to relativně zdlouhavé,
protože je k tomu potřeba alespoň tří řádků:</p>
<ul>
<li>Inicializace cyklu: vytvoření řídící proměnné, která se bude kontrolovat v cyklu</li>
<li>Kontrola výrazu: kontrola, jestli už proměnná nabrala požadované hodnoty</li>
<li>Operace na konci cyklu: změna hodnoty řídící proměnné</li>
</ul>
<pre><code class="language-c">int i = 0; // inicializace
while (i &lt; 10) { // kontrola výrazu
    // tělo cyklu
    i += 1; // změna hodnoty řídící proměnné
}
</code></pre>
<p>Cyklus <code>for</code> existuje, aby tuto častou situaci zjednodušil. Kód výše by se dal pomocí cyklu <code>for</code>
přepsat takto:</p>
<pre><code class="language-c">for (int i = 0; i &lt; 10; i += 1) {
    // tělo cyklu
}
</code></pre>
<p>Jak lze vidět, <code>for</code> cyklus v sobě kombinuje inicializaci cyklu, kontrolu výrazu a provedení příkazu
po každé iteraci. Obecná syntaxe tohoto cyklu vypadá takto:</p>
<pre><code class="language-c">for (&lt;příkaz A&gt;; &lt;výraz typu bool&gt;; &lt;příkaz B&gt;) {
    // tělo cyklu
}
</code></pre>
<p>Takovýto cyklus se vykoná následovně:</p>
<ol>
<li>Jakmile se cyklus začne vykonávat, nejprve se provede příkaz <code>A</code>. Zde se typicky vytvoří
řídící proměnná s nějakou počáteční hodnotou.</li>
<li>Zkontroluje se výraz. Pokud není pravdivý, cyklus končí a program pokračuje za cyklem <code>for</code>.
Pokud je pravdivý, provede se tělo cyklu a program pokračuje bodem 3.</li>
<li>Provede se příkaz <code>B</code> a program pokračuje bodem 2.</li>
</ol>
<p><strong>Cvičení</strong>: Napište program, který pomocí cyklu <code>for</code> na výstup vypíše čísla od 0 do 9 (včetně).</p>
<h1><a class="header" href="#funkce" id="funkce">Funkce</a></h1>
<p>Zatím jsme veškerý kód psali pouze na jedno místo v programu, do &quot;mainu&quot;. Jakmile programy začnou
být větší a větší, tak začne také být neustále těžší a těžší se v nich zorientovat a udržet je celé
v hlavě, abychom nad nimi mohli přemýšlet. Zároveň se nám v programu brzy začnou objevovat úseky kódu,
které jsou téměř totožné, ale liší se v drobných detailech. Chtěli bychom tak mít možnost takovýto
kód napsat pouze jednou a tyto měnící se detaily do něj pouze &quot;dosadit&quot;. K rozdělení kódu programu
do sady ucelených částí a jejich parametrizaci slouží <strong>funkce</strong> (<em>functions</em>).</p>
<p>Funkce je pojmenovaný blok kódu, na který se můžeme odkázat v jiné části programu a vykonat tak
kód, který se ve funkci nachází. S jednou funkcí už jsme se setkali. Jedná se o funkci <code>main</code>, jejíž
kód je proveden při spuštění programu. My si nicméně můžeme vytvořit vlastní funkce. Zde je
příklad vytvoření, tj. <strong>definice</strong> (<em>definition</em>) jednoduché funkce s názvem<sup class='margin-toggle sidenote-number'>1</sup> <code>vypis_text</code>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Pravidla pro pojmenovávání funkcí jsou totožná s pravidly pro
<a href="c/funkce/../promenne/pojmenovavani.html">pojmenovávání proměnných</a>.</p>
</span>
<pre><code class="language-c">void vypis_text() {
    printf(&quot;Ahoj\n&quot;);
}
</code></pre>
<p>Před názvem funkce je nutné uvést datový typ (zde je uveden typ <code>void</code>). <a href="c/funkce/funkce.html#n%C3%A1vratov%C3%A1-hodnota-funkc%C3%AD">Níže</a>
bude vysvětleno, k čemu tento typ slouží.</p>
<p>Tento blok<sup class='margin-toggle sidenote-number'>2</sup> kódu se přeloží na instrukce a bude existovat v přeloženém programu stejně jako funkce
<code>main</code>, nicméně sám o sobě se nezačne provádět. Abychom kód této funkce provedli, musíme ji tzv.
<strong>zavolat</strong> (<em>call</em>). To provedeme tak, že napíšeme název této funkce a za něj dáme
závorky (<code>()</code>):</p>
<span class='sidenote'><p><sup class='number'>2</sup>Stejně jako u <a href="c/funkce/../rizeni_toku/while.html">cyklů</a> se bloku kódu funkce často říká <strong>tělo funkce</strong> (<em>function body</em>).</p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

void vypis_text() {
    printf(&quot;Ahoj\n&quot;);
}
int main() {
    vypis_text(); // zavolání funkce vypis_text
    return 0;
}
</code></pre>
<p>Zavolání funkce je výraz, při jehož vyhodnocení dojde k provedení kódu funkce, která se volá.
Když se v programu nahoře ve funkci <code>main</code> vykoná řádek <code>vypis_text();</code>, tak se začne vykonávat kód
funkce <code>vypis_text</code>. Jakmile se příkazy z této funkce vykonají, tak program bude pokračovat ve funkci
<code>main</code>.</p>
<p>Pomocí volání funkcí můžeme mít kus kódu v programu zapsán pouze jednou ve funkci, a poté ho
můžeme spouštět z různých částí programu, podle toho, kdy se nám to zrovna bude hodit.</p>
<h2><a class="header" href="#parametrizace-funkcí" id="parametrizace-funkcí">Parametrizace funkcí</a></h2>
<p>Funkcím lze dávat vstupy zvané <strong>parametry</strong> (<em>parameters</em>). Parametry jsou proměnné uvnitř funkce,
jejichž hodnotu nastavujeme při zavolání dané funkce. Například následující funkce <code>vypis_cislo</code> má
parametr <code>cislo</code> s datovým typem <code>int</code>.</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vypis_cislo(int cislo) {
    printf(&quot;Cislo: %d\n&quot;, cislo);
}
int main() {
    vypis_cislo(5);
    return 0;
}
</code></pre>
<p>Při zavolání funkce musíme pro každý její parametr do závorek dát hodnotu odpovídajícího datového typu.
Zde je jediný parameter typu <code>int</code>, takže při zavolání této funkce musíme do závorek dát jednu hodnotu
datového typu <code>int</code>: <code>vypis_cislo(5)</code>. Před spuštěním příkazů ve funkci dojde k tomu, že hodnota každého
parametru se nastaví na hodnotu předanou ve volání funkce<sup class='margin-toggle sidenote-number'>3</sup>. Při zavolání <code>vypis_cislo(5)</code> si tak můžete
představit, že se vykoná následující kód:</p>
<span class='sidenote'><p><sup class='number'>3</sup>Hodnoty (výrazy) předávané při volání funkce se nazývají <strong>argumenty</strong> (<em>arguments</em>). Při
volání <code>vypis_cislo(5)</code> se tedy do parametru <code>cislo</code> nastaví hodnota argumentu <code>5</code>.</p>
</span>
<pre><code class="language-c">{
    // nastavení hodnot parametrů
    int cislo = 5;

    // tělo funkce
    printf(&quot;Cislo: %d\n&quot;, cislo); 
}
</code></pre>
<p>Parametrů mohou funkce brát libovolný počet, nicméně obvykle se používá maximálně cca 5
parametrů, aby funkce a její používání (volání) nebylo příliš složité. Jednotlivé parametry jsou
odděleny v definici funkce i v jejím volání čárkami:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void vypis_cisla(int a, int b) {
    printf(&quot;Cislo a: %d\n&quot;, a);
    printf(&quot;Cislo b: %d\n&quot;, b);
}
int main() {
    vypis_cisla(5 + 5, 11 * 2);
    return 0;
}
</code></pre>
<p>Pomocí parametrů můžeme vytvořit kód, který není &quot;zadrátovaný&quot; na konkrétní hodnoty, ale umí pracovat
s libovolnou hodnotou vstupu. Díky toho lze takovou funkci využít v různých situacích bez toho, abychom
její kód museli kopírovat. Příklady použití parametrů funkcí:</p>
<ul>
<li>Funkci <code>vypis_ctverec</code>, která přijme jako parametr číslo <code>n</code> a vypíše na výstup čtverec tvořený
znaky <code>x</code> o straně <code>n</code>.</li>
<li>Funkci <code>vykresli_pixel</code>, která přijme jako parametry souřadnici na obrazovce a barvu a vykreslí
na obrazovce na dané pozici pixel s odpovídající barvou.</li>
</ul>
<p><strong>Cvičení</strong>: Zkuste naprogramovat funkci <code>vypis_ctverec</code>.</p>
<h2><a class="header" href="#návratová-hodnota-funkcí" id="návratová-hodnota-funkcí">Návratová hodnota funkcí</a></h2>
<p>Nejenom, že funkce můžou přijímat vstup, ale umí také vracet výstup. Datový typ uvedený před názvem
funkce udává, jakého typu bude tzv. <strong>návratová hodnota</strong> (<em>return value</em>) dané funkce. V příkladech
výše jsme viděli datový typ <code>void</code>. Tento datový typ je speciální, protože říká, že funkce nebude
vracet <em>nic</em>. Pokud funkce má návratový typ <code>void</code>, tak nevrací žádnou hodnotu - pokud zavoláme
takovouto funkci, tak se sice provede její kód, ale výraz zavolání nevrátí žádnou hodnotu:</p>
<pre><code class="language-c editable">void funkce() {}

int main() {
    // chyba při překladu, funkce nic nevrací
    int x = funkce();
    return 0;
}
</code></pre>
<p>Často bychom nicméně chtěli funkci, která přijme nějaké hodnoty (parametry), vypočte nějakou hodnotu
a poté ji vrátí. Toho můžeme dosáhnout pomocí příkazu <code>return &lt;výraz&gt;;</code>. Při provedení tohoto výrazu
se přestane funkce vykonávat a její volání se vyhodnotí hodnotou předaného výrazu. Zde je příklad
funkce, která bere jako vstup jedno číslo a spočítá jeho třetí mocninu:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

int treti_mocnina(int cislo) {
   return cislo * cislo * cislo;
}
int main() {
   printf(&quot;%d\n&quot;, treti_mocnina(5 + 1));
   return 0;
}
</code></pre>
<p>Příkazů <code>return</code> může být ve funkci více:</p>
<pre><code class="language-c">int absolutni_hodnota(int cislo) {
    if (cislo &gt;= 0) {
        return cislo;
    }
    return -cislo;
}
</code></pre>
<p>Nicméně je důležité si uvědomit, že po provedení příkazu <code>return</code> už funkce dále nebude pokračovat:</p>
<pre><code class="language-c">int zvetsi(int cislo) {
    return cislo + 1;
    printf(&quot;Provadi se funkce zvetsi\n&quot;); // tento řádek se nikdy neprovede
}
</code></pre>
<blockquote>
<p>Pokud má funkce jakýkoliv jiný návratový typ než <code>void</code>, tak v ní musí být vždy proveden příkaz
<code>return</code>! Pokud k tomu nedojde, tak program může začít vykazovat <a href="c/funkce/../promenne/promenne.html#v%C5%BEdy-inicializujte-prom%C4%9Bnn%C3%A9">nedefinované chování</a>
💣 a může se tak chovat nepředvídatelně. Například následující funkce je špatně, protože pokud hodnota
parametru <code>cislo</code> bude nezáporná, tak se ve funkci neprovede příkaz <code>return</code>:</p>
<pre><code class="language-c">int absolutni_hodnota(int cislo) {
    if (cislo &lt; 0) {
      return -cislo;
    }
}
</code></pre>
</blockquote>
<p>Pokud má funkce návratový typ <code>void</code>, tak její provádění můžeme ukončit pomocí příkazu <code>return;</code>
(zde nepředáváme žádný výraz, protože funkce nic nevrací).</p>
<h2><a class="header" href="#syntaxe" id="syntaxe">Syntaxe</a></h2>
<p>Syntaxe funkcí v <em>C</em> vypadá takto:</p>
<pre><code class="language-c">&lt;datový typ&gt; &lt;název funkce&gt;(&lt;dat. typ par. 1&gt; &lt;název par. 1&gt;, &lt;dat. typ par. 2&gt; &lt;název par. 2&gt;, ...) {
    // blok kódu
} 
</code></pre>
<p>Datovému typu, názvu funkce a jejím parametrům se dohromady říká <strong>signatura</strong> (<em>signature</em>) funkce.
Tato informace je důležitá, abychom věděli, jak s danou funkcí pracovat (jak ji volat), k tomu není
nutné znát obsah těla funkce.</p>
<h2><a class="header" href="#výhody-funkcí" id="výhody-funkcí">Výhody funkcí</a></h2>
<p>Zde je pro zopakování uveden přehled výhod používání funkcí:</p>
<ul>
<li>Znovupoužitelnost kódu: pokud chcete stejný kód použít na více místech programu, nemusíte ho
&quot;copy-pastovat&quot;. Stačí ho vložit do funkce a tu poté zavolat.</li>
<li>Parametrizace kódu: pokud chcete spouštět stejný kód nad různými vstupními hodnotami, stačí udělat
funkci, která dané hodnoty přijme jako parametry (a případně vrátí výsledek výpočtu jako svou
návratovou hodnotu).</li>
<li>Abstrakce: když rozdělíte logiku programu do sady funkcí, tak si značně usnadníte přemýšlení nad
celým programem. Jednotlivé funkce budete moct testovat a přemýšlet nad nimi separátně, nezávisle na
zbytku programu. Pomocí používání funkcí také bude mnohem přehlednější čtení programu, protože bude
stačit číst, co se provádí (která funkce se volá) a ne jak se to provádí (jaké příkazy jsou v těle
funkce). Takovýhle kód pak lze číst téměř jako větu v přirozeném jazyce:
<pre><code class="language-c">int health = get_player_health(player_id);
health = health - calculate_enemy_damage(enemy_id);
set_player_health(player_id, health);
</code></pre>
</li>
<li>Sdílení kódu: pokud budete chtít použít kód, který napsal někdo jiný, tak toho dosáhnete právě
používáním funkcí, které vám někdo <a href="c/funkce/../knihovny.html">připraví</a>.</li>
</ul>
<h2><a class="header" href="#umístění-funkcí" id="umístění-funkcí">Umístění funkcí</a></h2>
<p>Funkce v <em>C</em> musíme psát vždy na nejvyšší úrovni souboru. V <em>C</em> tedy například není možné definovat
funkci uvnitř jiné funkce:</p>
<pre><code class="language-c editable readonly">int main() {
    int test() { }
}
</code></pre>
<h2><a class="header" href="#proč-název-funkce" id="proč-název-funkce">Proč název &quot;funkce&quot;?</a></h2>
<p>Možná vás napadlo, že název funkce zní podobně jako <a href="https://matematika.cz/co-je-to-funkce">funkce</a>
v matematice. Není to náhoda, funkce v programech se tak opravdu dají částečně chápat – berou nějaký
vstup (parametry) a vracejí výstup (návratovou hodnotu). Například následující matematickou funkci:</p>
<p>\( f(x) = 2 * x \)</p>
<p>můžeme v <em>C</em> naprogramovat takto:</p>
<pre><code class="language-c">int f(int x) {
    return 2 * x;
}
</code></pre>
<p>Aby ale funkce v <em>C</em> splňovala požadavky matematické funkce, musí být splněno několik vlastností:</p>
<ul>
<li>Funkce nesmí mít žádné <a href="c/funkce/../prikazy_vyrazy.html#vedlej%C5%A1%C3%AD-efekty">vedlejší efekty</a>. To znamená, že by
měla pouze provést výpočet na základě vstupních parametrů a vrátit vypočtenou hodnotu. Neměla by
číst nebo modifikovat <a href="c/funkce/../promenne/globalni_promenne.html">globální proměnné</a> nebo například interagovat se
soubory na disku.</li>
<li>Funkce musí mít návratový typ jiný než <code>void</code>, aby vracela nějakou hodnotu. Z toho také vyplývá,
že funkce s návratovým typem <code>void</code> musí mít nutně nějaké vedlejší efekty, jinak by totiž nemělo
cenu ji volat (protože nic nevrací).</li>
<li>Pokud je funkce zavolána se stejnými hodnotami parametrů, musí vždy vrátit stejnou návratovou
hodnotu. Této vlastnosti se říká <em>idempotence</em>. Jelikož jsou počítače deterministické, tato
vlastnost by měla být triviálně splněna, pokud funkce neobsahuje žádné vedlejší efekty.</li>
</ul>
<p>Funkce splňující tyto vlastnosti se nazývají <em>čisté</em> (<em>pure</em>). S takovýmito funkcemi je jednodušší
pracovat a přemýšlet nad tím, co dělají, protože si můžeme být jistí, že nemodifikují okolní stav
programu a pouze spočítají výsledek v závislosti na svých parametrech. Pokud to tedy jde, snažte se
funkce psát tímto stylem (samozřejmě ne vždy je to možné).</p>
<p>V předmětu
<a href="http://behalek.cs.vsb.cz/wiki/index.php/Functional_programming/cs">Funkcionální programování</a>
budete pracovat s funkcionálními programovacími jazyky, ve kterých je většina funkcí čistých.</p>
<h1><a class="header" href="#rekurze" id="rekurze">Rekurze</a></h1>
<p>Pokud funkce obsahuje volání sama sebe, tak tuto situaci nazýváme <strong>rekurzí</strong> (<em>recursion</em>).
Pro řešení některých problémů může být přirozené rozdělovat je na čím dál tím menší podproblémy,
dokud se nedostaneme k podproblému, který je dostatečně jednoduchý, abychom ho vyřešili rovnou.
Toto můžeme modelovat právě rekurzí, kdy voláme stejnou funkci s jinými parametry, dokud se
nedostaneme k parametrům, pro které umíme problém vyřešit jednoduše, a v ten moment rekurzi ukončíme.</p>
<p>Jedním z jednoduchých problémů, na kterém můžeme rekurzi demonstrovat, je výpočet
<a href="https://cs.wikipedia.org/wiki/Faktori%C3%A1l">faktoriálu</a>. Faktoriál lze nadefinovat například takto:</p>
<p>\(n! = n * (n - 1)!\)</p>
<p>Vidíme, že tato samotná definice je &quot;rekurzivní&quot;: pro výpočet faktoriálu <code>n</code> musíme znát hodnotu
faktoriálu <code>n - 1</code>. Výpočet faktoriálu můžeme provést například následující funkcí:</p>
<pre><code class="language-c editable">int faktorial(int n) {
    if (n &lt; 1) return 1;
    return n * faktorial(n - 1);
}
</code></pre>
<p>Pokud je parametr <code>n</code> menší než <code>1</code>, umíme faktoriál vypočítat triviálně. Pokud ne, tak spočteme
faktoriál <code>n - 1</code> a vynásobíme ho hodnotou <code>n</code>. Je důležité si uvědomit, v jakém pořadí zde probíhá
výpočet. Například při volání <code>factorial(4)</code>:</p>
<ol>
<li>Zavolá se <code>factorial(4)</code>.</li>
<li><code>factorial(4)</code> zavolá <code>factorial(3)</code>.</li>
<li><code>factorial(3)</code> zavolá <code>factorial(2)</code>.</li>
<li><code>factorial(2)</code> zavolá <code>factorial(1)</code>.</li>
<li><code>factorial(1)</code> vrátí <code>1</code>.</li>
<li><code>factorial(2)</code> vrátí <code>2 * 1</code>.</li>
<li><code>factorial(3)</code> vrátí <code>3 * 2 * 1</code>.</li>
<li><code>factorial(4)</code> vrátí <code>4 * 3 * 2 * 1</code>.</li>
</ol>
<p>Nejprve tak dojde k vypočtení <code>factorial(1)</code>, poté <code>factorial(2)</code> atd. Výpočet je tak v jistém
smyslu &quot;otočen&quot;. Zkuste si výpočet faktoriálu <a href="c/funkce/../../prostredi/ladeni.html#krokov%C3%A1n%C3%AD">odkrokovat</a>, abyste
si ujasnili, jak výpočet probíhá.</p>
<h2><a class="header" href="#přetečení-zásobníku" id="přetečení-zásobníku">Přetečení zásobníku</a></h2>
<p>Je důležité dávat si pozor na to, abychom vždy ve funkci měli podmínku, která rekurzi ukončí.
Jinak by se funkce volala &quot;donekonečna&quot;, dokud by nakonec nedošlo k
<a href="c/funkce/../../caste_chyby/pametove_chyby.html#stack-overflow">přetečení zásobníku</a>.</p>
<h1><a class="header" href="#funkce-standardní-knihovny" id="funkce-standardní-knihovny">Funkce standardní knihovny</a></h1>
<p>Když už nyní víme, co jsou to <a href="c/funkce/funkce.html">funkce</a>, tak si můžeme vysvětlit, odkud
se berou některé funkce, které jsme doposud používali, i když jsme je sami nenapsali.</p>
<p>Například příkaz <code>printf(&quot;...&quot;)</code> je volání funkce s názvem <code>printf</code>. Tato funkce pochází ze
<strong>standardní knihovny C</strong> (<em>C standard library</em>). Jedná se o sadu užitečných funkcí, které jsou tak
často využívané, že jsou implicitně překladačem přidány k vašemu programu, abyste je mohli využít
a nemuseli ztrácet čas jejich psaním v každém programu od nuly.</p>
<p>Tyto funkce se starají například o následující oblasti:</p>
<ul>
<li>Čtení ze vstupu programu a zápis na výstup programu (například funkce <code>printf</code>)</li>
<li><a href="c/funkce/../prace_s_pameti/dynamicka_pamet.html">Dynamická alokace</a> paměti</li>
<li>Čtení a zápis <a href="c/funkce/../soubory.html">souborů</a> na disku</li>
<li><a href="c/funkce/../../ruzne/nahodna_cisla.html">Generování náhodných čísel</a></li>
<li><a href="c/funkce/../text/text.html">Práce s textem</a></li>
<li><a href="http://www.cplusplus.com/reference/ctime/">Práce s časem a datem</a></li>
</ul>
<p>a mnoho dalších.</p>
<p>Abychom mohli tyto funkce používat, potřebujeme v našem programu vložit kód, který obsahuje
signatury těchto funkcí. Toho dosáhneme pomocí použití <a href="c/funkce/../preprocesor/preprocesor.html">preprocesoru</a>
– zde se dozvíte, jak funguje příkaz <code>#include &lt;...&gt;</code>, který jsme doposud používali jako &quot;black box&quot;.</p>
<p>Seznam funkcí dostupných v standardní knihovně můžete naleznout například
<a href="https://www.cplusplus.com/reference/clibrary/">zde</a><sup class='margin-toggle sidenote-number'>1</sup>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Dívejte se pouze na funkce pro <code>C99</code>, a ne na funkce <code>C++</code>. Jedná se o jiný jazyk.</p>
</span>
<p>Jak je standardní knihovna <em>C</em> připojena k vašim programům a jak si vytvořit vlastní knihovnu se
dozvíme později v sekci o <a href="c/funkce/../modularizace/knihovny.html">knihovnách</a>.</p>
<h1><a class="header" href="#preprocesor" id="preprocesor">Preprocesor</a></h1>
<p>Než je váš zdrojový soubor přeložen na strojové instrukce, tak jej
<a href="c/preprocesor/../../prostredi/preklad_programu.html">překladač</a> nejprve prožene tzv. <strong>preprocesorem</strong>
(<em>preprocessor</em>). Tento program nedělá nic jiného, než že projde váš zdrojový kód a zpracuje příkazy
začínající na <code>#</code>. V podstatě jediné, co takovéto příkazy dělají, je kopírování ve vašem zdrojovém
kódu.</p>
<p>Ukážeme si dva typy příkazů, které preprocesor umí zpracovávat:</p>
<ul>
<li><a href="c/preprocesor/vkladani_souboru.html">Vkládání souborů</a> do vašeho kódu (<code>#include</code>)</li>
<li>Vytváření <a href="c/preprocesor/makra.html">maker</a> (<code>#define</code>)</li>
</ul>
<p>Pokud si chcete ověřit, jak vypadá váš zdrojový soubor poté, co jej zpracuje preprocesor, ale předtím,
než je přeložen na strojové instrukce, můžete k tomu použít tento příkaz:</p>
<pre><code class="language-bash">$ gcc -P -E main.c
</code></pre>
<h1><a class="header" href="#vkládání-souborů" id="vkládání-souborů">Vkládání souborů</a></h1>
<p>Příkaz <code>#include</code> slouží ke vložení obsahu jiného souboru do vašeho zdrojového kódu. Tento příkaz
existuje ve dvou variantách:</p>
<pre><code class="language-c">#include &lt;cesta k souboru&gt;
#include &quot;cesta k souboru&quot;
</code></pre>
<p>Rozdíl mezi nimi je popsán <a href="c/preprocesor/vkladani_souboru.html#rozd%C3%ADl-mezi-include--a-include-">níže</a>.</p>
<p>Jakmile preprocesor narazí na tento příkaz, tak se pokusí najít soubor na uvedené cestě, zpracuje
jeho obsah (tj. vyhodnotí případné další příkazy jako <code>#include</code>, které v něm mohou být) a poté jeho
obsah vloží na místo, kde je <code>#include</code> použit. Jedná se o prosté textové nahrazení (<code>Ctrl+C -&gt; Ctrl+V</code>).</p>
<p>Tento příkaz slouží k tomu, abychom mohli používat stejný kód ve více souborech bez toho, abychom
jej museli neustále ručně kopírovat. Prozatím budeme vkládat do našeho kódu zejména soubory
obsahující různé funkce <a href="c/preprocesor/../funkce/stdlib.html">standardní knihovny <em>C</em></a>. Později si pak ukážeme,
jak vytvářet <em>C</em> programy sestávající se z <a href="c/preprocesor/../modularizace/modularizace.html">více zdrojových souborů</a>.</p>
<p>Zkuste si například tento zdrojový soubor pojmenovat jako <code>main.c</code> a pomocí příkazu <code>gcc -P -E main.c</code>
v terminálu zjistit, jak vypadá poté, co na něj byl aplikován preprocesor:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main() {
    printf(&quot;Hello world\n&quot;);
    return 0;
}
</code></pre>
<p>Asi je zřejmé, že by nebylo praktické kopírovat ručně všechen tento kód pokaždé, když bychom chtěli
něco vytisknout na výstup programu.</p>
<h2><a class="header" href="#relativní-cesta" id="relativní-cesta">Relativní cesta</a></h2>
<p>Cesta k souboru zadávaná v <code>#include</code> by měla být relativní, tj. není dobrý nápad používat něco
podobného:</p>
<pre><code class="language-c">#include &quot;C:/Users/Kamil/Desktop/upr/muj_soubor.h&quot;
</code></pre>
<p>Takovýto program by totiž jistě nefungoval na jiném než vašem počítači. Z jakého bodu se tato
relativní cesta vyhodnotí je popsáno níže.</p>
<h2><a class="header" href="#rozdíl-mezi-include--a-include-" id="rozdíl-mezi-include--a-include-">Rozdíl mezi <code>#include &lt;...&gt;</code> a <code>#include &quot;...&quot;</code></a></h2>
<p>Rozdíl mezi těmito variantami není pevně definován, nicméně většina preprocesorů (resp. překladačů)
funguje takto:</p>
<ul>
<li>
<p><code>#include &lt;...&gt;</code> nejprve vyhledá zadanou cestu v tzv. systémových cestách. Jedná se o známé složky,
ve kterých jsou uloženy jednak soubory standardní knihovny <em>C</em>, a také dalších knihoven, které máte
v systému nainstalované. Pouze pokud se zde daný soubor nenalezne, tak se cesta vyhodnotí relativně
ke zdrojovému souboru, ve kterém byl <code>#include</code> použit.</p>
<p>Seznam systémových cest si můžete vypsat pomocí příkazu <code>echo | gcc -E -Wp,-v -</code> v Linuxovém
terminálu. Do tohoto seznamu můžete také přidat dodatečné složky, když <code>gcc</code> předáte parametr
<code>-I</code>. Více se dozvíte v sekci o <a href="c/preprocesor/../modularizace/knihovny.html">knihovnách</a>.</p>
<p>Pokud soubor, který chcete do vašeho kódu vložit, se nachází v externí knihovně, která nepatří
do vašeho projektu, je běžné používat právě <code>#include &lt;&gt;</code>.</p>
</li>
<li>
<p><code>#include &quot;...&quot;</code> se nedívá do systémových cest, ale rovnou hledá zadanou cestu relativně k souboru,
ve kterém byl <code>#include</code> použit. Tuto formu používejte, pokud budete vkládat soubory z vašeho
projektu.</p>
</li>
</ul>
<h1><a class="header" href="#makra" id="makra">Makra</a></h1>
<p>Občas můžeme chtít v programech použít stejnou hodnotu na více místech. V takovém případě se hodí
danou hodnotu pojmenovat, aby bylo zřejmé, co reprezentuje. Zároveň by bylo užitečné ji nadefinovat
pouze na jednom místě, abychom její hodnotu mohli jednoduše manuálně změnit bez toho, abychom při tom
museli upravovat všechna místa, kde danou hodnotu používáme.</p>
<p>Pomocí příkazu <code>#define &lt;název&gt; &lt;hodnota&gt;</code> můžeme vytvořit <strong>makro</strong> (<em>macro</em>) s daným názvem a
hodnotou. Pokud preprocesor v kódu od řádku s <code>#define</code> do konce zdrojového kódu narazí na název
makra, tak tento název nahradí hodnotou makra (opět se jedná o prosté textové nahrazení, tedy
<code>Ctrl+C -&gt; Ctrl+V</code>). Zkuste si například, co vypíše tento program:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

#define CENA 25

int main() {
    printf(&quot;Cena je %d\n&quot;, CENA);
    printf(&quot;Dvojnasobek ceny je %d\n&quot;, CENA * 2);

    return 0;
}
</code></pre>
<p>Představte si, že hodnotu tohoto makra používáme v programu na stovkách míst. Pokud bychom ji
potřebovali změnit, tak stačí změnit jeden řádek s <code>#define</code> a preprocesor se poté postará o to,
že se hodnota aktualizuje na všech použitých místech.</p>
<p>Makra jsou dle konvence obvykle pojmenována &quot;caps-lockem&quot;, tedy velkými písmeny (respektive stylem
<a href="c/preprocesor/../promenne/pojmenovavani.html#v%C3%ADceslovn%C3%A9-n%C3%A1zvy">screaming snake case</a>).</p>
<p>Je třeba brát na vědomí, že preprocesor opravdu dělá pouhé textové nahrazení. Například následující
kód tak nedává smysl:</p>
<pre><code class="language-c">#define CENA 25
int main() {
    CENA = 0;
    return 0;
}
</code></pre>
<p>protože po spuštění preprocesoru se z něj stane tento (nesmyslný) kód:</p>
<pre><code class="language-c">int main() {
    25 = 0;
    return 0;
}
</code></pre>
<h2><a class="header" href="#makra-s-parametry" id="makra-s-parametry">Makra s parametry</a></h2>
<p>Makra můžou také obsahovat parametry:</p>
<pre><code class="language-c">#define &lt;název_makra&gt;(&lt;param1&gt;, &lt;param2&gt;, ...) &lt;hodnota_makra&gt;
</code></pre>
<p>Tyto parametry můžete použít pro definici hodnoty. Nicméně je opět třeba dát pozor na to, že
preprocesor pracuje pouze s textem, nerozumí jazyku <em>C</em>. Parametry tak jsou předávány čistě jako
text, je tak potřeba dávat si pozor na několik věcí:</p>
<ul>
<li>
<p>Priorita operátorů - pokud bychom chtěli vytvořit makro pro výpočet druhé mocniny, můžeme
ho napsat například takto:</p>
<pre><code class="language-c">#define MOCNINA(a) a * a
</code></pre>
<p>Pokud však takovéto makro použijeme s nějakým komplexním výrazem, nemusíme dosáhnout kýženého
výsledku kvůli priority operátorů:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

#define MOCNINA(a) a * a

int main() {
    printf(&quot;%d\n&quot;, MOCNINA(1 + 1));
    return 0;
}
</code></pre>
<p>Řádek s <code>printf</code> totiž preprocesor změní na <code>printf(&quot;%d\n&quot;, 1 + 1 * 1 + 1);</code>, což jistě není to,
co jsme chtěli. Proto je dobré při použití maker s parametry obalovat jednotlivé parametry
závorkami:</p>
<pre><code class="language-c">#define MOCNINA(a) (a) * (a)
</code></pre>
<p>Pak by zde již došlo k úpravě na <code>printf(&quot;%d\n&quot;, (1 + 1) * (1 + 1));</code>, což vrátí druhou mocninu
hodnoty <code>1 + 1</code>, tedy <code>4</code>.</p>
</li>
<li>
<p>Vedlejší efekty - pokud mají argumenty předávané do makra nějaké
<a href="c/preprocesor/../prikazy_vyrazy.html#vedlej%C5%A1%C3%AD-efekty">vedlejší efekty</a>, je třeba si dávat pozor na to, že makro může
jednoduše takovýto argument rozkopírovat a tím pádem vedlejší efekt provést vícekrát. Například při
použití makra <code>MOCNINA</code> výše by zde došlo k dvojnásobené inkrementaci proměnné <code>x</code>:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

#define MOCNINA(a) a * a

int main() {
    int x = 0;
    int mocnina = MOCNINA(x++);
    printf(&quot;%d\n&quot;, x); 
    return 0;
}
</code></pre>
<p>Do maker tak radši nedávejte argumenty, které způsobují vedlejší efekty.</p>
</li>
</ul>
<h2><a class="header" href="#makra-vs-globální-proměnné" id="makra-vs-globální-proměnné">Makra vs globální proměnné</a></h2>
<p><a href="c/preprocesor/../promenne/globalni_promenne.html">Globální proměnné</a> jsou také pojmenované hodnoty definované na
jednom místě, proč tedy potřebujeme makra? Je to z několika důvodů:</p>
<ul>
<li>Globální proměnné zabírají místo v paměti programu a zároveň zvyšují velikost spustitelného
souboru, protože v něm musí být uložena jejich iniciální hodnota
(pokud to tedy <a href="c/preprocesor/../promenne/globalni_promenne.html#inici%C3%A1ln%C3%AD-hodnota">není <code>0</code></a>). Makra se pouze textově
nahradí během překladu programu, takže samy o sobě žádnou paměť nezabírají.</li>
<li>Makra s parametry umožňují definici hodnot či textu závislou na použitých parametrech, což
globální proměnné neumožňují.</li>
<li>Konstantní globální proměnné nelze použít například pro určení velikosti statických
<a href="c/preprocesor/../pole/pole.html">polí</a>.</li>
</ul>
<p>Nicméně, makra jsou občas problémová kvůli toho, že se nahrazují čistě jako text. Pokud je to tedy
možné, zkuste raději použít pro definici konstant v kódu konstantní globální proměnné.</p>
<h2><a class="header" href="#podmíněný-překlad" id="podmíněný-překlad">Podmíněný překlad</a></h2>
<p>Makra mohou také být použity k tzv. <strong>podmíněnému překladu</strong> (<em>conditional compilation</em>). Pomocí
příkazů preprocesoru jako <code>#ifdef</code> nebo <code>#if</code> můžete přeložit kus kódu pouze, pokud je nadefinované
určité makro (popřípadě pouze pokud má určitou hodnotu). Toho se běžně využívá například pro tvorbu
programů, které jsou kompatibilní s více operačními systémy (např. funkce může mít jinou implementaci
pro Linux a jinou pro Windows).</p>
<p>V UPR se s podmíněným překladem nesetkáme, více se o něm můžete dozvědět například
<a href="https://docs.microsoft.com/en-us/cpp/preprocessor/hash-if-hash-elif-hash-else-and-hash-endif-directives-c-cpp">zde</a>.</p>
<h1><a class="header" href="#práce-s-pamětí" id="práce-s-pamětí">Práce s pamětí</a></h1>
<p>V sekci o <a href="c/prace_s_pameti/../../uvod/pamet.html">paměti</a> jsme se dozvěděli, že operační paměť počítače lze adresovat
pomocí číselných adres. Prozatím jsme nicméně v našich programech s žádnými adresami explicitně
nepracovali, pouze jsme vytvářeli proměnné, jejichž paměť byla spravována automaticky. V této sekci
se dozvíte základy toho, jak tzv. <strong>správa paměti</strong> (<em>memory management</em>) funguje.</p>
<h2><a class="header" href="#adresní-prostor-programu" id="adresní-prostor-programu">Adresní prostor programu</a></h2>
<p>Když spustíte svůj program, tak pro něj operační systém vytvoří tzv. <strong>adresní prostor</strong>
(<em>address space</em>), což je oblast paměti, se kterou program může pracovat.<sup class='margin-toggle sidenote-number'>1</sup> Tato oblast je typicky
rozdělena na několik částí, z nichž každá slouží pro různé typy dat:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Díky mechanismu
<a href="https://cs.wikipedia.org/wiki/Virtu%C3%A1ln%C3%AD_pam%C4%9B%C5%A5">virtuální paměti</a> je tento
prostor soukromý pro váš běžící program - ostatní běžící programy do něj nemají přístup, pokud jim
to explicitně nepovolíte.</p>
</span>
<p><img src="c/prace_s_pameti/../../static/img/address_space.svg" alt="Adresní prostor běžícího programu" width="90%"
style="max-height: 300px" /></p>
<ul>
<li><strong>Instrukce programu</strong>: do této části paměti se při spuštění programu zkopírují jeho instrukce
ze spustitelného souboru na disku. Procesor poté čte instrukce, které má vykonat, právě z této části
paměti. Tato paměť je obvykle chráněna proti zápisu a slouží pouze pro čtení.</li>
<li><strong>Zásobník</strong>: tato část uchovává automaticky spravovaná data, zejména lokální proměnné a parametry
funkcí. Tuto oblast popisuje sekce o <a href="c/prace_s_pameti/automaticka_pamet.html">automatické paměti</a>.</li>
<li><strong>Halda</strong>: tato část můžete využít k manuální alokaci paměti. To nám umožňují
<a href="c/prace_s_pameti/ukazatele.html">ukazatele</a>, díky kterým můžeme explicitně pracovat s adresami v paměti. Tuto oblast
adresního prostoru popisuje sekce o <a href="c/prace_s_pameti/dynamicka_pamet.html">dynamické paměti</a>.</li>
<li><strong>Globální data</strong>: tato část obsahuje <a href="c/prace_s_pameti/../promenne/globalni_promenne.html">globální proměnné</a>,
které žijí po celou dobu trvání programu.</li>
</ul>
<h1><a class="header" href="#automatická-paměť" id="automatická-paměť">Automatická paměť</a></h1>
<p>Zatím jsme používali (lokální) proměnné, které vznikají a zanikají uvnitř funkcí. Nemuseli jsme se
tedy nijak starat o to, kde existují v paměti. Lokální proměnné se ukládají do oblasti v paměti,
kterou nazýváme <strong>zásobník</strong> (<em>stack</em>). Každý běžící program má vyhrazen určitou oblast
adresovatelné paměti, která je použita právě jako zásobník.</p>
<p>Při každém zavolání funkce vznikne na zásobníku tzv. <strong>zásobníkový rámec</strong> (<em>stack frame</em>).
V tomto rámci je vyhrazena paměť pro lokální proměnné volané funkce a také pro její
<a href="c/prace_s_pameti/../funkce/funkce.html#parametrizace-funkc%C3%AD">parametry</a>. Rámec vzniká při zavolání funkce, v jednu chvíli tak
na zásobníku může existovat více rámců (s různými hodnotami proměnných a parametrů) pro stejnou funkci.
Rámce vznikají v paměti jeden za druhým, a jsou uvolněny v momentě, kdy se jejich funkce dokončí.<sup class='margin-toggle sidenote-number'>1</sup></p>
<span class='sidenote'><p><sup class='number'>1</sup>Rámce tak mohou vznikat nebo zanikat pouze na konci zásobníku, ne uprostřed. Proto se tato
oblast nazývá zásobník, podle
<a href="https://cs.wikipedia.org/wiki/Z%C3%A1sobn%C3%ADk_(datov%C3%A1_struktura)">datové struktury</a>, která
má tuto vlastnost.</p>
</span>
<p>Při zavolání funkce se do paměti určené pro jednotlivé parametry v rámci nakopírují hodnoty argumentů
předaných při volání funkce. Jakmile funkce skončí, tak je rámec, spolu s pamětí lokálních
proměnných, uvolněn<sup class='margin-toggle sidenote-number'>2</sup>.</p>
<span class='sidenote'><p><sup class='number'>2</sup>Uvolnění zde znamená pouze to, že program bude pokládat danou paměť za volnou k dalšímu použití.
Pokud tak například funkce bude mít lokální proměnnou s hodnotou <code>5</code> a vykonání funkce skončí, tato
hodnota v paměti zůstane, dokud nebude přepsána příštím zavoláním funkce.</p>
</span>
<p>V následující animaci můžete vidět sekvenci volání funkcí. Ve sloupci vpravo je zobrazen stav
zásobníku při provádění tohoto programu. Modře jsou v něm znázorněny hodnoty parametrů a červeně
hodnoty lokálních proměnných. Můžete si všimnout, že lokální proměnné mají
<a href="c/prace_s_pameti/../promenne/promenne.html#v%C5%BEdy-inicializujte-prom%C4%9Bnn%C3%A9">nedefinovanou hodnotu</a>, dokud do nich není
nějaká hodnota zapsána, nicméně paměť pro ně již existuje od začátku provádění funkce.</p>
<p><upr-svgs src="../../static/animations/stack/stack-" to="15" height="400"></upr-svgs></p>
<p>V animaci si můžete všimnout, že rámce vždy vznikají a zanikají pouze na konci zásobníku.<sup class='margin-toggle sidenote-number'>3</sup>
Uhodnete, jaké číslo tento program vypíše?</p>
<span class='sidenote'><p><sup class='number'>3</sup>Z <a href="https://stackoverflow.com/questions/2035568/why-do-stacks-typically-grow-downwards">historických</a>
důvodů zásobník roste &quot;dolů&quot;, tj. nové rámce se vytvářejí na nižší adrese v paměti.</p>
</span>
<h2><a class="header" href="#výhody-automatické-paměti" id="výhody-automatické-paměti">Výhody automatické paměti</a></h2>
<p>Používání automatické paměti má značné výhody:</p>
<ul>
<li>Nemusíme se starat o to, jak je paměť alokována a uvolňována, vše za nás řeší překladač, který
generuje instrukce pro vytváření a uvolňování rámců při volání/dokončení provádění funkce.</li>
<li>Alokace i uvolnění paměti je velmi rychlá. Jde v podstatě o provedení jediné instrukce, která si
pamatuje, kde zrovna zásobník &quot;končí&quot; v paměti.</li>
</ul>
<p>Pokud tedy nepotřebujete žádnou složitější funkcionalitu, první volbou by mělo být právě použití
automatické paměti (tedy lokálních proměnných).</p>
<h2><a class="header" href="#nevýhody-automatické-paměti" id="nevýhody-automatické-paměti">Nevýhody automatické paměti</a></h2>
<p>Automatická paměť je sice velmi užitečná, nicméně někdy potřebujeme použít i jiné typy paměti,
protože automatická paměť má i určité nedostatky:</p>
<ul>
<li>Maximální velikost zásobníku je omezena<sup class='margin-toggle sidenote-number'>4</sup>. Nemůžeme tak na něm naalokovat větší množství paměti.<span class='sidenote'><p><sup class='number'>4</sup>Obvykle jde o jednotky KiB/MiB.</p>
</span></li>
<li>Počet a velikost lokálních proměnných je &quot;zadrátována&quot; do programu během jeho překladu. Nemůžeme
tak naalokovat paměť s velikostí závislou na vstupu programu. Například pokud uživatel zadá
číslo <code>n</code> a my bychom chtěli vytvořit paměť pro <code>n</code> čísel, tak nestačí použití zásobníku.</li>
<li>Paměť lokálních proměnných a parametrů je uvolněna při dokončení provádění funkce. Jediným způsobem,
jak předat hodnotu z volání funkce, je pomocí návratového typu, lze takto tedy vrátit pouze jednu
hodnotu. Nelze tak jednoduše sdílet hodnoty mezi funkcemi, protože paměť lokálních proměnných je po
dokončení volání funkce uvolněna a nelze ji tak použít z volající funkce.</li>
<li>Argumenty předávané do funkcí se kopírují do zásobníkového rámce volané funkce a návratová hodnota
se zase kopíruje zpět do rámce volající funkce. Toto kopírování může být zbytečně pomalé pro hodnoty
zabírající velký počet bytů. </li>
</ul>
<p>Abychom mohli alokovat větší množství paměti či jednoduššeji sdílet hodnoty proměnných mezi funkcemi,
tak musíme mít možnost alokovat a uvolňovat paměť <a href="c/prace_s_pameti/dynamicka_pamet.html">manuálně</a>. Nejprve ale
potřebujeme způsob, jak pracovat přímo s adresami v paměti, k čemuž slouží <a href="c/prace_s_pameti/ukazatele.html">ukazatele</a>.</p>
<h1><a class="header" href="#ukazatele" id="ukazatele">Ukazatele</a></h1>
<p>Abychom v <em>C</em> mohli manuálně pracovat s pamětí, potřebujeme mít možnost odkazovat se na jednotlivé
hodnoty v paměti pomocí <a href="c/prace_s_pameti/../../uvod/pamet.html">adres</a>. Adresa je číslo, takže bychom mohli pro popis
adres používat například datový typ <code>unsigned int</code><sup class='margin-toggle sidenote-number'>1</sup>. To by ale nebyl dobrý nápad, protože tento
datový typ neumožňuje provádět operace, které bychom s adresami chtěli dělat (načíst hodnotu z adresy
či zapsat hodnotu na adresu), a naopak umožňuje provádět operace, které s adresami dělat nechceme
(například násobení či dělení adres obvykle nedává valný smysl).</p>
<span class='sidenote'><p><sup class='number'>1</sup>Nejnižší možná adresa je <code>0</code>, takže záporné hodnoty nemá cenu reprezentovat.</p>
</span>
<p>Z tohoto důvodu <em>C</em> obsahuje datový typ, který je interpretován jako adresa v paměti běžícího
programu. Nazývá se <strong>ukazatel</strong> (<em>pointer</em>). Kromě toho, že reprezentuje adresu, tak každý datový
typ ukazatele také obsahuje informaci o tom, jaký typ hodnoty je uložen v paměti na adrese obsažené
v ukazateli. Poté říkáme, že ukazatel &quot;ukazuje na&quot; daný datový typ.</p>
<p>Abychom vytvořili datový typ ukazatele, vezmeme datový typ, na který bude ukazovat, a přidáme za něj
hvezdičku (<code>*</code>). Takto například vypadá proměnná datového typu &quot;ukazatel na <code>int</code>&quot;<sup class='margin-toggle sidenote-number'>2</sup>:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Je jedno, jestli hvězdičku napíšete k datovému typu (<code>int* p</code>) anebo k názvu proměnné
(<code>int *p</code>), bílé znaky jsou zde ignorovány. Pozor však na vytváření více ukazatelů na
<a href="c/prace_s_pameti/definice-v%C3%ADce-ukazatel%C5%AF-najednou">jednom řádku</a>.</p>
</span>
<pre><code class="language-c">int* ukazatel;
</code></pre>
<p>Je důležité si uvědomit, co tato proměnná reprezentuje. Datový typ <code>int*</code> zde říká, že v proměnné
<code>ukazatel</code> bude uloženo číslo, které budeme interpretovat jako adresu. V paměti na této adrese poté
bude ležet číslo, které budeme interpretovat jako datový typ <code>int</code> (celé číslo se znaménkem).</p>
<p>Ukazatele lze libovolně &quot;vnořovat&quot;, tj. můžeme mít například &quot;ukazatel na ukazatel na celé číslo&quot;
(<code>int**</code>). Ukazatel ale i tehdy bude prostě číslo, akorát ho budeme interpretovat jako adresu na
adresu. Pro procvičení je níže uvedeno několik datových typů spolu s tím, jak je interpretujeme.</p>
<ul>
<li><code>int</code> - interpretujeme jako celé číslo</li>
<li><code>int*</code> - interpretujeme jako adresu, na které je uloženo celé číslo</li>
<li><code>float*</code> - interpretujeme jako adresu, na které je uloženo desetinné číslo</li>
<li><code>int**</code> - interpretujeme jako adresu, na které je uložena adresa, na které je uloženo celé číslo</li>
</ul>
<p>Někdy chceme použít &quot;univerzální&quot; ukazatel, který prostě obsahuje adresu, bez toho, abychom striktně
určovali, jaká hodnota na dané adrese bude uložena. V tom případě můžeme použít datový typ <code>void*</code>.</p>
<blockquote>
<p>Velikost všech ukazatelů v programu je stejná a je daná použitým operačním systémem a překladačem.
Ukazatele musí být dostatečně velké, aby zvládli reprezentovat libovolnou adresu, která se v programu
může vyskytnout. Na vašem počítači to bude nejspíše 8 bytů, protože pravděpodobně používáte
64-bitový systém.</p>
</blockquote>
<h2><a class="header" href="#inicializace-ukazatele" id="inicializace-ukazatele">Inicializace ukazatele</a></h2>
<p>Jelikož před spuštěním programu nevíme, na jaké adrese budou uloženy hodnoty, které nás budou
zajímat, tak obvykle nedává smysl inicializovat ukazatel na konkrétní adresu (např. <code>int* p = 5;</code>).
Pro inicializaci ukazatele tak existuje několik standardních možností:</p>
<ul>
<li>
<p><strong>Inicializace na nulu</strong>: Pokud chceme vytvořit &quot;prázdný&quot; ukazatel, který zatím neukazuje na
žádnou validní adresu, tak se dle konvence inicializuje na hodnotu <code>0</code>. Takovému ukazateli se pak
říká <strong>nulový ukazatel</strong> (<em>null pointer</em>). Jelikož datový typ výrazu <code>0</code> je <code>int</code>, tak před
přiřazením této hodnoty do ukazatele jej musíme
<a href="c/prace_s_pameti/../datove_typy/celociselne_typy.html#explicitn%C3%AD-konverze">přetypovat</a> na datový typ cílového
ukazatele:</p>
<pre><code class="language-c">float* p = (float*) 0;
</code></pre>
<p>Jelikož tento typ inicializace je velmi častý, <a href="c/prace_s_pameti/../funkce/stdlib.html">standardní knihovna <em>C</em></a>
obsahuje <a href="c/prace_s_pameti/../preprocesor/makra.html">makro</a> <code>NULL</code>, které konverzi nuly na ukazatel provede za
vás. Můžete jej najít například v souboru <code>stdlib.h</code>:</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
float* p = NULL;
</code></pre>
</li>
<li>
<p><strong>Využití alokační funkce</strong>: Pokud budete alokovat paměť <a href="c/prace_s_pameti/dynamicka_pamet.html">manuálně</a>, tak
použijete funkce, které vám hodnotu ukazatele vrátí jako svou návratovou hodnotu.</p>
</li>
<li>
<p><strong>Využití operátoru adresy</strong>: Pokud chcete ukazatel nastavit na adresu již existující hodnoty v
paměti, můžete použít <strong>operátor adresy</strong> (<em>address-of operator</em>). Ten má syntaxi <code>&amp;&lt;proměnná&gt;</code>.
Tento operátor se vyhodnotí jako adresa předané proměnné<sup class='margin-toggle sidenote-number'>3</sup>:</p>
<span class='sidenote'><p><sup class='number'>3</sup>Všimněte si, že pro výpis ukazatelů ve funkci <code>printf</code> se používá <code>%p</code> místo <code>%d</code>.</p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int x = 1;
    int* p = &amp;x;

    printf(&quot;%d\n&quot;, x);  // hodnota proměnné x
    printf(&quot;%p\n&quot;, p);  // adresa v paměti, kde je uložena proměnná x

    return 0;
}
</code></pre>
<p>Výraz předaný operátoru <code>&amp;</code> se musí vyhodnotit na něco, co má adresu v paměti (většinou to bude
<a href="c/prace_s_pameti/../promenne/promenne.html">proměnná</a>). Nedává smysl použít něco jako <code>&amp;5</code>, protože 5 je číselná
hodnota, která nemá žádnou adresu v paměti.</p>
<p>Při použití tohoto operátoru je také třeba dávat si pozor na to, aby hodnota v paměti, jejíž
adresu použitím <code>&amp;</code> získáme, stále existovala, když se budeme později snažit k této adrese
pomocí ukazatele přistoupit. V opačném případu by mohlo dojít k
<a href="c/prace_s_pameti/../../caste_chyby/pametove_chyby.html#segmentation-fault">paměťové chybě</a> 💣.</p>
</li>
</ul>
<h2><a class="header" href="#přístup-k-paměti-pomocí-ukazatele" id="přístup-k-paměti-pomocí-ukazatele">Přístup k paměti pomocí ukazatele</a></h2>
<p>Když už máme v ukazateli uloženou nějakou (validní) adresu v paměti, tak k této paměti můžeme
přistoupit pomocí operátoru <strong>dereference</strong>. Ten má syntaxi <code>*&lt;výraz typu ukazatel&gt;</code>. Při použití
tohoto operátoru na ukazateli program přečte adresu v ukazateli, podívá se do paměti a načte hodnotu
uloženou na této adrese. Podle toho, na jaký datový typ ukazatel ukazuje, se načte odpovídající
počet bytů z paměti:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int cislo = 1;
    int* ukazatel = &amp;cislo;

    printf(&quot;%p\n&quot;, ukazatel);
    printf(&quot;%d\n&quot;, *ukazatel);
    printf(&quot;%d\n&quot;, cislo);

    return 0;
}
</code></pre>
<p>V tomto programu se do proměnné <code>ukazatel</code> uloží adresa proměnné <code>cislo</code>, a poté dojde k načtení
hodnoty (<code>*ukazatel</code>) této proměnné z paměti přes adresu uloženou v ukazateli.</p>
<p>Pokud chceme do adresy uložené v ukazateli naopak nějakou hodnotu zapsat, tak můžeme operátor
dereference použít také na levé straně operátoru <a href="c/prace_s_pameti/../promenne/promenne.html#z%C3%A1pis">zápisu</a>.
Uhodnete, co vypíše tento program?</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int cislo = 1;
    int* ukazatel = &amp;cislo;
    *ukazatel = 5;

    printf(&quot;%d\n&quot;, cislo);

    return 0;
}
</code></pre>
<p>Pokud provádíte operace s přímo s proměnnou ukazatele, budete vždy pracovat &quot;pouze&quot; s adresou,
která je v něm uložena. Pokud chcete načíst nebo změnit hodnotu, která v paměti leží na adrese
uložené v ukazateli, musíte použít operátor dereference.</p>
<h2><a class="header" href="#aritmetika-s-ukazateli" id="aritmetika-s-ukazateli">Aritmetika s ukazateli</a></h2>
<p>Abychom se mohli v paměti &quot;posouvat&quot; o určitý kus dopředu či dozadu (relativně k nějaké adrese),
můžeme k ukazatelům přičítat či odčítat čísla. Toto se označuje jako <strong>aritmetika s ukazateli</strong>
(<em>pointer arithmetic</em>). Tato aritmetika má důležité pravidlo – pokud k ukazateli na konkrétní datový
typ přičteme hodnotu <code>n</code>, tak se adresa v ukazateli zvýší o <code>n</code>-násobek velikosti datového typu,
na který ukazatel ukazuje. Při aritmetice s ukazateli se tak neposouváme po jednotlivých bytech,
ale po celých hodnotách daného datového typu<sup class='margin-toggle sidenote-number'>4</sup>.</p>
<span class='sidenote'><p><sup class='number'>4</sup>Z toho vyplývá, že aritmetiku nemůžeme provádět nad ukazateli <code>void*</code>, protože ty neukazují
na žádný konkrétní datový typ.</p>
</span>
<p>Například, pokud bychom měli ukazatel <code>int* p</code> s hodnotou <code>16</code> (tj. &quot;ukazuje&quot; na adresu <code>16</code>) a
velikost <code>int</code>u by byla <code>4</code>, tak výraz <code>p + 1</code> bude ukazatel s hodnotou <code>20</code>, výraz <code>p + 2</code> bude
ukazatel s adresou <code>24</code> atd.</p>
<p>Je důležité <a href="c/prace_s_pameti/../../caste_chyby/caste_chyby.html#%C5%A0patn%C3%A1-pr%C3%A1ce-s-ukazatelem">rozlišovat</a>, jestli při
použití sčítání/odčítání pracujeme s hodnotou ukazatele anebo s hodnotou na adrese, která je v
ukazateli uložena:</p>
<pre><code class="language-c">int x = 1;
int* p = &amp;x;

*p += 1;    // zvýšili jsme hodnotu na adrese v `p` (tj. proměnnou `x`) o `1`
p += 1;     // zvýšili jsme adresu v `p` o `4` (tj. p nyní už neukazuje na `x`)
</code></pre>
<blockquote>
<p>K čemu je aritmetika s ukazateli užitečná se dozvíte v sekci o práci s
<a href="c/prace_s_pameti/../pole/staticke_pole.html#p%C5%99%C3%ADstup-k-prvk%C5%AFm-pole">více proměnnými zároveň</a>.</p>
</blockquote>
<p>Kromě dereference a aritmetiky lze s ukazateli provádět také porovnávání (klasicky pomocí operátorů
<code>==</code> nebo <code>&gt;</code>). Díky toho můžeme například zjistit, jestli se dvě adresy rovnají.</p>
<h2><a class="header" href="#využití-ukazatelů" id="využití-ukazatelů">Využití ukazatelů</a></h2>
<p>Jak se dozvíte v <a href="c/prace_s_pameti/dynamicka_pamet.html">následující sekci</a>, ukazatele jsou nezbytné pro
manuální alokaci paměti. Hodí se také při práci s <a href="c/prace_s_pameti/../pole/pole.html">více proměnnými</a> zároveň. Kromě
toho je ale lze použít také například v následujících situacích, které všechny souvisí s předáváním
adres (ukazatelů) do funkcí:</p>
<ul>
<li><strong>Změna vnějších hodnot zevnitř funkce</strong> - hodnoty argumentů předávaných při
<a href="c/prace_s_pameti/../funkce/funkce.html#parametrizace-funkc%C3%AD">volání funkcí</a> se do funkce kopírují, nelze tak jednoduše
zevnitř funkce měnit hodnoty proměnných, které existují mimo danou funkci. To je sice samo o sobě
vhodná vlastnost, protože pokud bude funkce měnit pouze své lokální proměnné, případně parametry,
tak bude jednodušší se v ní vyznat. Nicméně, někdy opravdu chceme ve funkci změnit hodnoty externích
proměnných. Toho můžeme dosáhnout tak, že si do funkce místo hodnoty proměnné pošleme její adresu v
ukazateli, a pomocí této adresy pak hodnotu proměnné změníme. Takto například můžeme vytvořit funkci,
která vezme adresy dvou proměnných a prohodí jejich hodnoty:
<pre><code class="language-c editable">#include &lt;stdio.h&gt;
void swap(int* a, int* b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
int main() {
    int x = 5;
    int y = 10;
    swap(&amp;x, &amp;y);
    printf(&quot;Po prehozeni: x=%d, y=%d\n&quot;, x, y);
    return 0;
}
</code></pre>
</li>
<li><strong>Vrácení více návratových hodnot</strong> - posílání adres proměnných do funkce můžeme využít také k
tomu, abychom z funkce vrátili více než jednu návratovou hodnotu (do adres uložených v parametrech
totiž můžeme zapsat &quot;návratové&quot; hodnoty). Toho bychom však měli využívat pouze, pokud je to opravdu
nezbytné. Takovéto funkce je totiž složitější volat a nejsou
<a href="c/prace_s_pameti/../funkce/funkce.html#pro%C4%8D-n%C3%A1zev-funkce">čisté</a>, protože obsahují vedlejší efekt - mění externí stav
programu.</li>
<li><strong>Sdílení hodnot bez kopírování</strong> - pokud bychom měli proměnné, které v paměti zabírají velké
množství bytů (například <a href="c/prace_s_pameti/../struktury/struktury.html">struktury</a>), a předávali je jako argumenty
funkci, tak může být zbytečně pomalé je pokaždé kopírovat. Pokud do funkce pouze předáme jejich
adresu, tak dojde ke kopii pouze jednoho čísla s adresou, nezávisle na tom, jak velká je proměnná,
která je na dané adrese uložena. Ukazatele tak můžeme použít ke sdílení hodnot v paměti mezi funkcemi
bez toho, abychom je kopírovali.</li>
</ul>
<h2><a class="header" href="#konstantní-ukazatele" id="konstantní-ukazatele">Konstantní ukazatele</a></h2>
<p>Pokud použijeme klíčové slovo <a href="c/prace_s_pameti/../promenne/konstanty.html"><code>const</code></a> v kombinaci s ukazateli, je
potřeba si dávat pozor na to, k čemu se tohle klíčové slovo váže. To závisí na tom, zda je <code>const</code>
v datovém typu před nebo za hvězdičkou. Zde jsou možné kombinace, které můžou vzniknout u
jednoduchého ukazatele:</p>
<ul>
<li><code>int*</code> - ukazatel na celé číslo. Adresu v ukazateli lze měnit, hodnotu čísla na adrese v ukazateli
také lze měnit.</li>
<li><code>const int*</code> - ukazatel na konstantní celé číslo. Adresu v ukazateli lze měnit, hodnotu čísla na
adrese v ukazateli nikoliv.</li>
<li><code>int const *</code> - konstantní ukazatel na celé číslo. Adresu v ukazateli nelze měnit, hodnotu čísla na
adrese v ukazateli lze měnit.</li>
<li><code>const int const *</code> - konstantní ukazatel na konstantní celé číslo. Adresu v ukazateli nelze měnit,
hodnotu čísla na adrese v ukazateli také nelze měnit.</li>
</ul>
<h2><a class="header" href="#definice-více-ukazatelů-najednou" id="definice-více-ukazatelů-najednou">Definice více ukazatelů najednou</a></h2>
<p>Pokud byste chtěli vytvořit více ukazatelů
<a href="c/prace_s_pameti/../promenne/promenne.html#definice-v%C3%ADce-prom%C4%9Bnn%C3%BDch-najednou">najednou</a>, musíte si dát pozor na to, že
v tomto případě se hvězdička vztahuje pouze k jednomu následujícímu názvu proměnné. Tento kód tak
vytvoří ukazatel s názvem <code>x</code>, a dvě celá čísla s názvy <code>y</code> a <code>z</code>:</p>
<pre><code class="language-c">int* x, y, z;
</code></pre>
<p>Pokud byste chtěli vytvořit tři ukazatele, musíte dát hvězdičku před každý název proměnné:</p>
<pre><code class="language-c">int* x, *y, *z;
</code></pre>
<h1><a class="header" href="#dynamická-paměť" id="dynamická-paměť">Dynamická paměť</a></h1>
<p>Už víme, že pomocí <a href="c/prace_s_pameti/automaticka_pamet.html">automatické paměti</a> na zásobníku nemůžeme alokovat
velké množství paměti a nemůžeme ani alokovat paměť s dynamickou velikostí (závislou na velikosti
vstupu programu). Abychom tohoto dosáhli, tak musíme použít jiný mechanismus alokace paměti, ve
kterém paměť alokujeme i uvolňujeme manuálně.</p>
<p>Tento mechanismus se nazývá <strong>dynamická alokace paměti</strong> (<em>dynamic memory allocation</em>). Pomocí několika
funkcí standardní knihovny <em>C</em> můžeme naalokovat paměť s libovolnou velikosti. Tato paměť je
alokována v oblasti paměti zvané <strong>halda</strong> (<em>heap</em>). Narozdíl od zásobníku, prvky na haldě neleží
striktně za sebou, a lze je tak uvolňovat v libovolném pořadí. Můžeme tak naalokovat paměť libovolné
velikosti, která přežije i ukončení vykonávání funkce, díky čemuž tak můžeme sdílet (potenciálně velká)
data mezi funkcemi. Nicméně musíme také tuto paměť ručně uvolňovat, protože (narozdíl od zásobníku)
to za nás nikdo neudělá.</p>
<h2><a class="header" href="#alokace-paměti" id="alokace-paměti">Alokace paměti</a></h2>
<p>K naalokování paměti můžeme použít funkci <a href="https://devdocs.io/c/memory/malloc"><code>malloc</code></a> (<em>memory
alloc</em>), která je dostupná v souboru <code>stdlib.h</code> ze <a href="c/prace_s_pameti/../funkce/stdlib.html">standardní knihovny <em>C</em></a>.
Tato funkce má následující signaturu<sup class='margin-toggle sidenote-number'>1</sup>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Datový typ <a href="https://en.cppreference.com/w/c/types/size_t"><code>size_t</code></a> reprezentuje bezznaménkové
celé číslo, do kterého by měla jít uložit velikost největší možné hodnoty libovolného typu. Často
se používá pro indexaci <a href="c/prace_s_pameti/../pole/pole.html">polí</a>.</p>
</span>
<pre><code class="language-c">void* malloc(size_t size);
</code></pre>
<p>Parametr <code>size</code> udává, kolik bytů paměti se má naalokovat. Tuto velikost můžeme &quot;tipnout&quot;
manuálně, nicméně to není moc dobrý nápad, protože bychom si museli pamatovat velikosti datových
typů (přičemž jejich velikost se může lišit v závislosti na použitém operačním systému či
překladači!). Abychom tomu předešli, tak můžeme použít výraz <code>sizeof</code>, kterému můžeme předat datový
typ<sup class='margin-toggle sidenote-number'>2</sup> a tento výraz se poté vyhodnotí jako velikost daného datového typu:</p>
<span class='sidenote'><p><sup class='number'>2</sup>Případně výraz, v tom případě si <code>sizeof</code> vezme jeho datový typ.</p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;
int main() {
    printf(&quot;Velikost int je: %d\n&quot;, sizeof(int));
    printf(&quot;Velikost int* je: %d\n&quot;, sizeof(int*));
    return 0;
}
</code></pre>
<p>Návratový typ <code>void*</code> reprezentuje ukazatel na libovolná data. Funkce <code>malloc</code> musí fungovat pro
alokaci libovolného datového typu, proto musí mít návratový typ právě univerzální ukazatel <code>void*</code>.
Při zavolání funkce <code>malloc</code> bychom měli tento návratový typ
<a href="c/prace_s_pameti/../datove_typy/celociselne_typy.html#explicitn%C3%AD-konverze">přetypovat</a> na ukazatel na datový typ,
který alokujeme.</p>
<p>Při zavolání <code>malloc</code>u dojde k naalokování <code>size</code> bytů na haldě. Adresa prvního bytu této
naalokované paměti se poté vrátí jako návratová hodnota <code>malloc</code>u. Zde je ukázka programu, který
naalokuje paměť pro jeden <code>int</code> ve funkci, adresu naalokované paměti poté vrátí jako návratovou
hodnotu a naalokovaná paměť je poté přečtena ve funkci <code>main</code>:</p>
<pre><code class="language-c editable">#include &lt;stdlib.h&gt;

int* allocate() {
    int* memory = (int*) malloc(sizeof(int));
    *memory = 5;
    return memory; 
}
int main() {
    int* memory = allocate();
    printf(&quot;%d\n&quot;, *memory);
    return 0;
}
</code></pre>
<h3><a class="header" href="#iniciální-hodnota-paměti" id="iniciální-hodnota-paměti">Iniciální hodnota paměti</a></h3>
<p>Stejně jako u <a href="c/prace_s_pameti/../promenne/promenne.html#v%C5%BEdy-inicializujte-prom%C4%9Bnn%C3%A9">lokálních proměnných</a> platí, že
hodnota naalokované paměti je nedefinovaná. Než se tedy hodnotu dané paměti pokusíte přečíst, musíte
jí nainicializovat zápisem nějaké hodnoty! Jinak bude program obsahovat nedefinované chování 💣.</p>
<p>Pokud byste chtěli, aby naalokovaná paměť byla rovnou při alokaci vynulována (všechny byty
nastavené na hodnotu <code>0</code>), můžete místo funkce <code>malloc</code> použít funkci
<a href="https://devdocs.io/c/memory/calloc"><code>calloc</code></a><sup class='margin-toggle sidenote-number'>3</sup>.</p>
<span class='sidenote'><p><sup class='number'>3</sup>Pozor však na to, že tato funkce má jiné parametry než <code>malloc</code>. Očekává počet hodnot, které
se mají naalokovat, a velikost každé hodnoty.</p>
</span>
<p>Případně můžete použít užitečnou funkci <a href="https://devdocs.io/c/string/byte/memset"><code>memset</code></a>, která
vám vyplní blok paměti zadaným bytem.</p>
<h2><a class="header" href="#uvolnění-paměti" id="uvolnění-paměti">Uvolnění paměti</a></h2>
<p>S velkou mocí přichází i velká <a href="https://citaty.net/citaty/1957976-stan-lee-s-velkou-moci-prichazi-velka-odpovednost/">zodpovědnost</a>,
takže při použití dynamické paměti sice máme více možností než při použití zásobníku, ale zároveň
<strong>MUSÍME</strong> tuto paměť korektně uvolňovat (což se u automatické paměti provádělo automaticky). Pokud
bychom totiž paměť neustále pouze alokovali a neuvolňovali, tak by nám
<a href="c/prace_s_pameti/../../caste_chyby/pametove_chyby.html#memory-leak">brzy došla</a>.</p>
<p>Abychom paměť naalokovanou pomocí funkcí <code>malloc</code> či <code>calloc</code> uvolnili, tak musíme použít funkci
<code>free</code>:</p>
<pre><code class="language-c editable">#include &lt;stdlib.h&gt;

int main() {
    int* p = (int*) malloc(sizeof(int)); // alokace paměti
    *p = 0;                              // použití paměti
    free(p);                             // uvolnění paměti

    return 0;
}
</code></pre>
<p>Jako argument této funkci musíme předat ukazatel navrácený z volání <code>malloc</code>/<code>calloc</code>. Nic jiného
do této funkce nedávejte, uvolňovat můžeme pouze dynamicky alokovanou paměť! Nevolejte <code>free</code> s
adresami např. lokálních proměnných<sup class='margin-toggle sidenote-number'>4</sup>.</p>
<span class='sidenote'><p><sup class='number'>4</sup>Je však bezpečné uvolnit &quot;nulový ukazatel&quot;, tj. <code>free(NULL)</code> je validní (v tomto případě funkce nic neudělá).</p>
</span>
<p>Jakmile se paměť uvolní, tak už k této paměti nesmíte přistupovat! Pokud byste se pokusili přečíst
nebo zapsat uvolněnou paměť, tak dojde k nedefinovanému chování 💣. Nesmíte ani paměť uvolnit více
než jednou.</p>
<p>Při práci s dynamickou (manuální) pamětí tak dbejte zvýšené opatrnosti a ideálně používejte při
vývoji <a href="c/prace_s_pameti/../../prostredi/ladeni.html#address-sanitizer">Address sanitizer</a>. (Neúplný) seznam věcí,
které se můžou pokazit, pokud kombinaci manuální alokace a uvolňování paměti pokazíte, naleznete
<a href="c/prace_s_pameti/../../caste_chyby/pametove_chyby.html">zde</a>.</p>
<h2><a class="header" href="#alokace-více-hodnot-zároveň" id="alokace-více-hodnot-zároveň">Alokace více hodnot zároveň</a></h2>
<p>Jak jste si mohli všimnout ze signatury funkce <code>malloc</code>, můžete jí dát libovolný počet bytů.
Nemusíte se tak omezovat velikostí základních datových typů, můžete například naalokovat paměť pro
5 <code>int</code>ů zároveň, které poté budou ležet za sebou v paměti a bude tak jednoduché k nim přistupovat
v cyklu. Jak tento koncept funguje se dozvíte v sekci o
<a href="c/prace_s_pameti/../pole/dynamicke_pole.html">dynamických polích</a>.</p>
<h1><a class="header" href="#globální-paměť" id="globální-paměť">Globální paměť</a></h1>
<p>Posledním základním typem paměti je tzv. globální (nebo také statická) paměť. Tato paměť je
specifická tím, že vzniká při spuštění programu a zaniká při jeho ukončení, lze ji tak používat
během celé délky běhu programu.</p>
<p><a href="c/prace_s_pameti/../promenne/globalni_promenne.html">Globální proměnné</a> jsou umístěny v globální paměti. Je dobré si
uvědomit, že tyto proměnné zároveň zabírají místo ve spustitelném souboru na disku, protože v něm
musí být uložena jejich iniciální hodnota<sup class='margin-toggle sidenote-number'>1</sup>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Pokud tedy nejsou
<a href="c/prace_s_pameti/../promenne/globalni_promenne.html#inici%C3%A1ln%C3%AD-hodnota">inicializované na nulu</a>).</p>
</span><h1><a class="header" href="#pole" id="pole">Pole</a></h1>
<p>Počítače slouží k (rychlému) zpracování velkého objemu dat, běžně tak v programech potřebujeme
zpracovávat mnoho proměnných najednou. Například:</p>
<ul>
<li>V dokumentu otevřeném ve Wordu můžete mít uložené tisíce různých znaků.</li>
<li>Na server v online hře může v danou chvíli být připojené velké množství hráčů a všem musíme
posílat informace o stavu hry.</li>
<li>Obrázky se běžně v programech reprezentují jako 2D mřížka pixelů. Například černobílý obrázek
s rozměry <code>1024x1024</code> vyžaduje držet v paměti <code>1048576</code> bytů (čísel) reprezentujících jednotlivé
pixely.</li>
</ul>
<p>Asi si dovedete představit, že například pro reprezentaci obrázku bychom si s proměnnými, které jsme
používali doposud, nevystačili. Pokud bychom po jedné vytvářeli proměnné <code>pixel1</code>, <code>pixel2</code>,
<code>pixel3</code>, tak by jednak byl náš zdrojový kód obrovský a nedalo by se v něm vyznat, a také bychom
nemohli mít velikost obrázku závislou na vstupu programu, protože počet proměnných by byl
&quot;zadrátovaný&quot; ve zdrojovém kódu programu. Chtěli bychom tak mít možnost napsat kód, který bude umět
zpracovat 1, 2, 100 nebo 1000 hodnot bez toho, abychom tento kód museli jakkoliv měnit.</p>
<p>Asi nejběžnějším a nejjednodušším způsobem, jak v paměti počítače uchovávat větší množství hodnot,
je uložit všechny hodnoty jednu po druhé za sebou v paměti<sup class='margin-toggle sidenote-number'>1</sup>. Tento koncept uložení dat se nazývá
<strong>pole</strong> (<em>array</em>) a je tak běžný, že ho programovací jazyky obvykle přímo podporují, a jazyk <em>C</em>
není výjimkou.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Způsoby, jak v paměti počítače uchovávat komplexní a rozsáhlá data, se nazývají
<a href="https://cs.wikipedia.org/wiki/Datov%C3%A1_struktura">datové struktury</a>. Pole je jednou z
nejjednodušších datových struktur.</p>
</span>
<p>V následujících sekcích se dozvíte, jak s poli pracovat, jak je vytvořit v
<a href="c/pole/staticke_pole.html">automatické</a> a <a href="c/pole/dynamicke_pole.html">dynamické paměti</a> a jak lze v počítači
reprezentovat <a href="c/pole/vicerozmerne_pole.html">vícerozměrná pole</a>.</p>
<!--
Jedním z důležitých prvků jazyka *C* je práce s poli. Již jsme si v
předchozím odstavci ukázali, jak vytvořit dynamicky alokované pole pro
reprezentaci řetězce. Samozřejmě můžeme vytvořit podobné pole pro
reprezentaci intigerů, floatů, apod. Je také bez problému možné vytvořit
pole na stacku, které nemusíme dealokovat. Jeho platnost je však pouze v
rámci bloku, ve kterém je deklarováno, např. tedy funkce. Takové pole
také nelze z funkce vrátit pomocí klíčového slova `return`. Pojďme si nyní
ukázat, jak je možno s poli pracovat.

<upr-container>
  <upr-array array='["A", "h", "o", "j", "\\0"]' highlight='{"4": "muted"}'></upr-array>
  <upr-arrow src-anchor="north" dst=".index-4" dst-anchor="south" ctrl-distance="-15">
    ukončovací nula
  </upr-arrow>
</upr-container>

```c,editable,mainbody
#include <stdio.h>

int main() {
  char str[] = "Ahoj";
  printf( "%c %c %c %c\n", str[ 0 ], str[ 1 ], str[ 2 ], str[ 3 ] );
  // A h o j
}
```

Z uvedeného příkladu vyplývá, že k jednotlivým prvkům pole se přistupuje
přes operátor hranaté závorky (`[]`).

Pole můžeme též modifikovat. Nejjednodušeji lze modifikovat určitý prvek
pole tak, že jej indexujeme a do takto indexovaného prvku přiřadíme
požadovanou hodnotu. Stávající hodnota se v poli přepíše hodnotou novou.

```c,editable,mainbody
#include <stdio.h>

int main() {
  char str[] = "Ahoj";
  printf( "%s\n", str );  // Ahoj
  str[ 1 ] = 'A';
  printf( "%s\n", str );  // AAoj
}
```

## Příklady
### Suma pole
<upr-array-sum array="[1, 2, 3, 4, 5]"></upr-array-sum>

### Minimální hodnota v poli
<upr-array-min array="[5, 6, 3, 4, 1]"></upr-array-min>

### Převrácení pole
<upr-array-reverse array="[1, 2, 3, 4, 5]"></upr-array-reverse>
-->
<h1><a class="header" href="#statické-pole" id="statické-pole">Statické pole</a></h1>
<p>Pole v <a href="c/pole/../prace_s_pameti/automaticka_pamet.html">automatické paměti</a><sup class='margin-toggle sidenote-number'>1</sup> (na zásobníku) se označují
jako <strong>statická pole</strong> (<em>static arrays</em>). Můžeme je vytvořit tak, že za název proměnné přidáme
hranaté závorky s číslem udávající počet prvků v poli. Takto například vytvoříme pole celých čísel
s třemi prvky:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Pole můžeme tímto způsobem vytvořit také v
<a href="c/pole/../prace_s_pameti/globalni_pamet.html">globální paměti</a>.</p>
</span>
<pre><code class="language-c">int array[3];
</code></pre>
<p>Takováto proměnná bude obsahovat paměť pro 3 celá čísla (tedy nejspíše na vašem počítači dohromady
12 bytů). Počet prvků v poli se označuje jako jeho <strong>velikost</strong> (<em>size</em>).</p>
<blockquote>
<p>Pozor na to, že hranaté závorky se udávají za název proměnné, a ne za název datového typu.
<code>int[3] array;</code> je tedy špatně.</p>
</blockquote>
<p>Čísla takového pole budou v paměti uložena jeden za druhým<sup class='margin-toggle sidenote-number'>2</sup>:
<upr-container>
<upr-array array='[0, 0, 0]'></upr-array>
</upr-container></p>
<span class='sidenote'><p><sup class='number'>2</sup>Každý zelený čtverec na tomto obrázku reprezentuje 4 bytů v paměti (velikost jednoho <code>int</code>u).</p>
</span>
<p>V jistém smyslu je tak pole pouze zobecněním normální proměnné. Pokud totiž vytvoříte pole o
velikosti jedna (<code>int a[1]</code>), tak v paměti bude reprezentováno úplně stejně jako klasická proměnná
(<code>int a</code>).</p>
<blockquote>
<p>Pole lze vytvořit také na haldě pomocí <a href="c/pole/dynamicke_pole.html">dynamické alokace paměti</a>. Všechny níže
popsané koncepty jsou platné i pro dynamická pole, nicméně budeme je demonstrovat na statických
polích, protože ty je jednodušší vytvořit.</p>
</blockquote>
<h2><a class="header" href="#počítání-od-nuly" id="počítání-od-nuly">Počítání od nuly</a></h2>
<p>Pozice jednotlivých prvků v poli se označují jako jejich <strong>indexy</strong> (<em>array indices</em>). Tyto pozice
se číslují od hodnoty <code>0</code> (tedy ne od jedničky, jak můžete být jinak zvyklí). První prvek pole je
tedy ve skutečnosti na nulté pozici (indexu), druhý na první pozici, atd. (viz obrázek nahoře).
<strong>Počítání od nuly</strong> (<em>zero-based indexing</em>) je ve světě programování běžné a budete si na něj
muset zvyknout. Jeden z důvodů, proč se prvky počítají právě od nuly, se dozvíte
<a href="c/pole/staticke_pole.html#p%C5%99%C3%ADstup-k-prvk%C5%AFm-pole">níže</a>.</p>
<p>Z tohoto vyplývá jedna důležitá vlastnost - poslední prvek pole je vždy na indexu
<code>&lt;velikost pole&gt; - 1</code>! Pokud byste se pokusili přistoupit k prvku na indexu <code>&lt;velikost pole&gt;</code>,
budete přistupovat mimo paměť pole, což pravděpodobně způsobí
<a href="c/pole/../../caste_chyby/pametove_chyby.html">paměťovou chybu</a>.</p>
<h3><a class="header" href="#konstantní-velikost-statického-pole" id="konstantní-velikost-statického-pole">Konstantní velikost statického pole</a></h3>
<p>Hodnota zadaná v hranatých závorkách by měla být konstantní (tj. buď přímo číselná hodnota anebo
<a href="c/pole/../promenne/konstanty.html">konstantní proměnná</a>). Pokud budete potřebovat pole dynamické velikosti,
tak byste měli použít <a href="c/pole/dynamicke_pole.html">manuální alokaci paměti</a>.</p>
<p>Jazyk <em>C</em> od verze <a href="https://en.wikipedia.org/wiki/C99"><em>C99</em></a> již sice povoluje dávat do hranatých
závorek i &quot;dynamické hodnoty&quot;:</p>
<pre><code class="language-c">int velikost = ...; // velikost se načte např. ze souboru
int pole[velikost];
</code></pre>
<p>Nicméně tuto <a href="https://en.wikipedia.org/wiki/Variable-length_array">funkcionalitu</a> není vhodné
používat. Zásobník má
<a href="c/pole/../prace_s_pameti/automaticka_pamet.html#nev%C3%BDhody-automatick%C3%A9-pam%C4%9Bti">omezenou velikost</a> a není určen
pro alokaci velkého množství paměti<sup class='margin-toggle sidenote-number'>3</sup>. Pokud navíc velikost takovéhoto pole může ovlivnit uživatel
programu (např. zadáním vstupu), může váš program jednoduše &quot;shodit&quot;, pokud by zadal velké číslo a
došlo by k pokusu o vytvoření velkého pole na zásobníku. Zkuste se tak vyvarovat používání
dynamických hodnot při vytváření polí na zásobníku.</p>
<span class='sidenote'><p><sup class='number'>3</sup>Můžete si například zkusit přeložit následující program:</p>
<pre><code class="language-c">int main() {
    int pole[10000000];
    return 0;
}
</code></pre>
<p>Při spuštění by měl program selhat na
<a href="c/pole/../../caste_chyby/pametove_chyby.html#segmentation-fault">paměťovou chybu</a>, i když váš počítač má
pravděpodobně více než <code>10000000 * 4</code> (cca <code>38</code> MiB) paměti. Pokud chcete alokovat více než několik
stovek bytů, použijte raději <a href="c/pole/dynamicke_pole.html">dynamickou alokaci</a> na haldě.</p>
</span>
<h2><a class="header" href="#inicializace-pole" id="inicializace-pole">Inicializace pole</a></h2>
<p>Stejně jako u normálních lokálních proměnných
<a href="c/pole/../promenne/promenne.html#v%C5%BEdy-inicializujte-prom%C4%9Bnn%C3%A9">platí</a>, že pokud pole nenainicializujete,
tak bude obsahovat nedefinované hodnoty. V takovém případě z pole nesmíte jakkoliv číst, jinak by
došlo k nedefinovanému chování 💣! K inicializaci hodnoty můžete použít složené závorky se seznamem
hodnot (oddělených čárkou), které budou do pole uloženy. Pokud nezadáte dostatek hodnot pro vyplnění
celého pole, tak zbytek hodnot bude nulových.</p>
<pre><code class="language-c">int a[3];               // pole bez definované hodnoty, nepoužívat!
int b[3] = {};          // pole s hodnotami 0, 0, 0
int c[4] = { 1 };       // pole s hodnotami 1, 0, 0, 0
int d[2] = { 2, 3 };    // pole s hodnotami 2, 3
</code></pre>
<p>Hodnot samozřemě nesmíte zadat více, než je velikost pole.</p>
<h2><a class="header" href="#přístup-k-prvkům-pole" id="přístup-k-prvkům-pole">Přístup k prvkům pole</a></h2>
<p>K přístupu k jednotlivým prvkům pole můžeme využít
<a href="c/pole/../prace_s_pameti/ukazatele.html">ukazatelů</a>. Proměnná pole se totiž chová jako ukazatel na první
prvek (prvek na nultém indexu) daného pole, pomocí operátoru
<a href="c/pole/../prace_s_pameti/ukazatele.html#p%C5%99%C3%ADstup-k-pam%C4%9Bti-pomoc%C3%AD-ukazatele">dereference</a> tak můžeme
jednoduše přistoupit k prvnímu prvku pole:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int array[3] = { 1, 2, 3 };
    printf(&quot;%d\n&quot;, *array);
    return 0;
}
</code></pre>
<p>Abychom přistoupili i k dalším prvkům v poli, tak můžeme využít
<a href="c/pole/../prace_s_pameti/ukazatele.html#aritmetika-s-ukazateli">aritmetiky s ukazateli</a>. Pokud chceme
získat adresu prvku na <code>i</code>-tém indexu, stačí k ukazateli na první prvek přičíst <code>i</code><sup class='margin-toggle sidenote-number'>4</sup>:</p>
<span class='sidenote'><p><sup class='number'>4</sup>Všimněte si, že při použití operátoru dereference zde používáme závorky. Je to z důvodu
<a href="https://en.cppreference.com/w/c/language/operator_precedence">priority operátorů</a>. Výraz <code>*array + 2</code>
by se vyhodnotil jako první prvek z pole <code>array</code> plus <code>2</code>, protože <code>*</code> (dereference) má větší
prioritu než sčítání. </p>
</span>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int array[3] = { 1, 2, 3 };
    printf(&quot;%d\n&quot;, *(array + 0));   // první prvek pole
    printf(&quot;%d\n&quot;, *(array + 1));   // druhý prvek pole
    printf(&quot;%d\n&quot;, *(array + 2));   // třetí prvek pole
    return 0;
}
</code></pre>
<p>Nyní už možná tušíte, proč se při práci s poli vyplatí počítat od nuly. Prvek na nultém indexu je
totiž vzdálen nula prvků od začátku pole. Prvek na prvním indexu je vzdálen jeden prvek od začátku
pole atd. Pokud bychom indexovali od jedničky, museli bychom při výpočtu adresy relativně k ukazateli
na začátek pole vždy odečíst jedničku, což by bylo nepraktické.</p>
<h2><a class="header" href="#operátor-přístupu-k-poli" id="operátor-přístupu-k-poli">Operátor přístupu k poli</a></h2>
<p>Jelikož je operace přístupu k poli (&quot;posunutí&quot; ukazatele a jeho dereference) velmi
běžná (a zároveň relativně krkolomná), <em>C</em> obsahuje speciální operátor, který jej zjednodušuje.
Tento operátor se nazývá <em>array subscription operator</em> a má syntaxi <code>&lt;výraz a&gt;[&lt;výraz b&gt;]</code>. Slouží
jako zkratka<sup class='margin-toggle sidenote-number'>5</sup> za <code>*(&lt;výraz a&gt; + &lt;výraz b&gt;)</code>. Například <code>array[0]</code> je ekvivalentní výrazu
<code>*(array + 0)</code>, <code>array[5]</code> je ekvivalentní výrazu <code>*(array + 5)</code> atd:</p>
<span class='sidenote'><p><sup class='number'>5</sup>Takovéto &quot;zkratky&quot;, které v programovacím jazyku nepřináší novou funkcionalitu, pouze zkracují
či zjednoduššují často používané kombinace příkazů, se označují jako
<a href="https://en.wikipedia.org/wiki/Syntactic_sugar"><strong>syntax sugar</strong></a>.</p>
</span>
<pre><code class="language-c">int array[3] = { 1, 2, 3 };
array[0] = 5;       // nastavili jsme první prvek pole na hodnotu `5`
int c = array[2];   // nastavili jsme `c` na hodnotu posledního prvku pole
</code></pre>
<p>Jelikož je používání hranatých závorek přehlednější než používání závorek a hvězdiček, doporučujeme
je používat pro přistupování k prvkům pole, pokud to půjde.</p>
<blockquote>
<p>Pozor na rozdíl mezi tímto operátorem a definicí pole. Obojí sice používá hranaté závorky, ale
jinak spolu tyto dvě věci nesouvisejí. Podobně jako se <code>*</code> používá pro definici datového typu
<a href="c/pole/../prace_s_pameti/ukazatele.html">ukazatele</a> a zároveň jako operátor dereference (navíc i jako
operátor pro násobení). Vždy záleží na kontextu, kde jsou tyto znaky použity.</p>
</blockquote>
<h2><a class="header" href="#použití-polí-s-cykly" id="použití-polí-s-cykly">Použití polí s cykly</a></h2>
<p>Pokud bychom k polím přistupovali po individuálních prvcích, tak bychom nemohli využít jejich plný
potenciál. I když umíme jedním řádkem kódu vytvořit například 100 různých hodnot (<code>int pole[100];</code>),
pokud bychom museli psát <code>pole[0]</code>, <code>pole[1]</code> atd. pro přístup k jednotlivým prvkům, tak bychom
nemohli s polem efektivně pracovat. Smyslem polí je zpracovat velké množství dat jednotným způsobem
pomocí malého množství kódu. Jinak řečeno, chtěli bychom mít stejný kód, který umí zpracovat
pole o velikosti <code>2</code> i <code>1000</code>. K tomu můžeme efektivně využít <a href="c/pole/../rizeni_toku/cykly.html">cykly</a>.</p>
<p>Velmi často je praktické použít řídící proměnnou cyklu k tomu, abychom pomocí ní indexovali pole.
Například, pokud bychom měli pole s velikostí <code>10</code>, tak ho můžeme &quot;projít&quot; pomocí cyklu <code>for</code>:</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
    int array[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    for (int i = 0; i &lt; 10; i++) {
        printf(&quot;%d &quot;, array[i]);
    }
    return 0;
}
</code></pre>
<p>Situace, kdy pomocí cyklu procházíte pole je velmi častý a určitě se s ním mnohokrát setkáte a
použijete jej. Zkuste si to procvičit například pomocí
<a href="c/pole/../../ulohy/ukazatele_a_pole.html#minim%C3%A1ln%C3%AD-hodnota-v-poli">těchto úloh</a>.</p>
<h2><a class="header" href="#předávání-pole-do-funkcí" id="předávání-pole-do-funkcí">Předávání pole do funkcí</a></h2>
<p>Při předávání polí do funkcí si musíme dávat pozor zejména na dvě věci.</p>
<h3><a class="header" href="#převod-pole-na-ukazatel" id="převod-pole-na-ukazatel">Převod pole na ukazatel</a></h3>
<p>Už víme, že když předáváme <a href="c/pole/../funkce/funkce.html#parametrizace-funkc%C3%AD">argumenty</a> do funkcí, tak se
jejich hodnota zkopíruje. U statických polí tomu tak ovšem není, protože pole můžou být potenciálně
velmi velká a provádění kopií polí by tak potenciálně mohlo trvat dlouhou dobu. Když tak použijeme
proměnnou pole jako argument při volání funkce, dojde k tzv. <strong>konverzi pole na ukazatel</strong>
(<em>array to pointer decay</em>). Pole se tak vždy předá jako ukazatel na jeho první prvek:</p>
<pre><code class="language-c editable">#include &lt;stdio.h&gt;

void print_array(int* array) {
    printf(&quot;%d\n&quot;, array[0]);
}

int main() {
    int array[3] = { 1, 2, 3 };
    print_array(array);
    return 0;
}
</code></pre>
<p>Pro parametry sice můžete použít datový typ pole:</p>
<pre><code class="language-c">void print_array(int array[3]) { ... }
</code></pre>
<p>nicméně i v tomto případě se bude takovýto parametr chovat stejně jako ukazatel (v tomto případě
tedy <code>int*</code>). Navíc překladač ani nebude kontrolovat, jestli do takového parametru opravdu dáváme
pole se správnou velikostí. Pro parametry reprezentující pole tak radši používejte ukazatel.</p>
<h3><a class="header" href="#předávání-velikosti-pole" id="předávání-velikosti-pole">Předávání velikosti pole</a></h3>
<p>Když ve funkci přijmeme jako parametr ukazatel na pole, tak nevíme, kolik prvků v tomto poli je.
Tato informace je ale stěžejní, bez ní totiž nevíme, ke kolika prvkům pole si můžeme dovolit
přistupovat. Pokud tedy ukazatel na pole předáváme do funkce, je obvykle potřeba zároveň s ním
předat i délku daného pole:</p>
<pre><code class="language-c">int sum_array(int* array, int count) {
    int sum = 0;
    for (int i = 0; i &lt; count; i++) {
        sum += array[i];
    }
    return sum;
}
</code></pre>
<h1><a class="header" href="#dynamické-pole" id="dynamické-pole">Dynamické pole</a></h1>
<p>Pole alokovaná na zásobníku by měly mít velikost danou při překladu programu, často ale potřebujeme
vytvářet pole v závislosti na vstupu programu (například když načítáme soubor, tak dopředu nevíme,
kolik bude mít řádků). Ze sekce o <a href="c/pole/../prace_s_pameti/dynamicka_pamet.html">dynamické paměti</a> již víme,
jak alokovat libovolné množství paměti na haldě pomocí funkce <code>malloc</code>. Pro vytvoření
<strong>dynamického pole</strong> (<em>dynamic array</em>) tak stačí použít funkci <code>malloc</code>. Například pro vytvoření
dynamického pole pro <code>5</code> celých čísel potřebujeme naalokovat <code>5 * sizeof(int)</code> bytů:</p>
<pre><code class="language-c">int* array = (int*) malloc(5 * sizeof(int));
</code></pre>
<p>S takovouto pamětí pak můžeme pracovat jako s polem <code>int</code>ů o velikosti <code>5</code>. Jakmile již takovéto
pole nepotřebujeme, nesmíme jej samozřejmě zapomenout
<a href="c/pole/../prace_s_pameti/dynamicka_pamet.html#uvoln%C4%9Bn%C3%AD-pam%C4%9Bti">uvolnit</a>.</p>
<h2><a class="header" href="#změna-velikosti-pole" id="změna-velikosti-pole">Změna velikosti pole</a></h2>
<p>Občas potřebujeme velikost dynamického pole změnit (obvykle zvětšit). Například pokud vám
uživatel zadává na vstupu seznam čísel, na začátku můžete vytvořit paměť pro 10 čísel, ale při
zadání 11. čísla musíte tuto paměť zvětšit, jinak byste neměli nové číslo kam zapsat. Tento proces
se nazývá <strong>realokace</strong> (<em>reallocation</em>) a lze jej provést například následujícím způsobem:</p>
<ol>
<li>Naalokujeme nové dynamické pole o požadované velikosti</li>
<li>Zkopírujeme obsah původního pole do nového pole </li>
<li>Uvolníme paměť původního pole</li>
<li>Upravíme odpovídající ukazatel(e) v programu, aby ukazoval(y) na nově naalokované pole</li>
</ol>
<p>Pokud se vám toto nechce programovat ručně, tak můžete také použít funkci
<a href="https://devdocs.io/c/memory/realloc"><code>realloc</code></a> ze standardní knihovny <em>C</em>, která to udělá za vás.
Tato funkce očekává původní adresu alokace z <code>malloc</code>/<code>calloc</code> a počet bytů nové alokace.</p>
<p><strong>Cvičení</strong>: Zkuste si naprogramovat funkci, která obdrží pole a jeho původní velikost
a realokuje ho na novou velikost.</p>
<h1><a class="header" href="#vícerozměrné-pole" id="vícerozměrné-pole">Vícerozměrné pole</a></h1>
<p>Někdy potřebujeme v programech reprezentovat věci, které jsou přirozeně vícerozměrné. Typickým
příkladem jsou obrázky, které lze reprezentovat jako dvourozměrnou mřížku pixelů (jeden rozměr udává
řádek a druhý sloupec).</p>
<p><a href="c/pole/../../uvod/pamet.html">Paměťové adresy</a> však mají pouze jeden rozměr, jelikož jsou reprezentovány
jedním číslem. Jak tedy můžeme do jednorozměrné paměti uložit vícerozměrnou hodnotu? Způsobů je více,
nicméně asi nejjednodušší je prostě &quot;vyskládat&quot; jednotlivé rozměry (dimenze) v paměti za sebou,
jeden rozměr za druhým. Pokud bychom například měli dvojrozměrnou mřížku<sup class='margin-toggle sidenote-number'>1</sup> s rozměry <code>5x5</code>,
můžeme ji reprezentovat tak, že nejprve do paměti uložíme první řádek, poté druhý řádek atd.: </p>
<span class='sidenote'><p><sup class='number'>1</sup>Reprezentující například obrázek či <a href="https://matematika.cz/matice">matici</a>.</p>
</span>
<p><img src="c/pole/../../static/img/2d_array.svg" alt="2D pole" /></p>
<p>Tento koncept se označuje jako <strong>vícerozměrné pole</strong> (<em>multidimensional array</em>).</p>
<h2><a class="header" href="#inicializace-vícerozměrných-polí" id="inicializace-vícerozměrných-polí">Inicializace vícerozměrných polí</a></h2>
<p>Vícerozměrné pole můžete nainicializovat <a href="c/pole/staticke_pole.html#inicializace-pole">stejně</a> jako klasické
pole. Pro zpřehlednění kódu však také můžete použít složené závorky pro oddělení jednotlivých
dimenzí:</p>
<pre><code class="language-c">int pole_2d[3][4] = {  
   {0, 1, 2, 3},    // hodnoty pro první řádek
   {4, 5, 6, 7},    // hodnoty pro druhý řádek
   {8, 9, 10, 11}   // hodnoty pro třetí řádek
};
</code></pre>
<h2><a class="header" href="#způsob-vyskládání-dimenzí" id="způsob-vyskládání-dimenzí">Způsob vyskládání dimenzí</a></h2>
<p>Je na nás, v jakém pořadí jednotlivé dimenze do paměti uložíme. Pokud bychom se bavili o 2D poli,
tak můžeme do paměti uložit řádek po řádku (viz obrázek výše), toto je nazývané jako
<strong>row major ordering</strong>. Můžeme ale také do paměti vyskládat sloupec po sloupci, což se nazývá
<strong>column major ordering</strong>. Je víceméně jedno, který způsob použijeme, je ale důležité se držet
jednoho přístupu, jinak může dojít k záměně indexů. Indexování totiž záleží na tom, jaký způsob
vyskládání použijeme. Níže předpokládáme pořadí <em>row major</em>.</p>
<h2><a class="header" href="#indexování" id="indexování">Indexování</a></h2>
<p>Při práci s dvourozměrným polem bychom chtěli pracovat s dvourozměrným indexem (řádek <code>i</code>, sloupec
<code>j</code>), nicméně při samotném přístupu do paměti pak musíme tento vícerozměrný index převést na 1D
index. A naopak, z 1D indexu bychom chtěli mít možnost získat zpět 2D index. Pro výpočet indexů 2D
pole s <code>rows</code> řádky a <code>cols</code> sloupci můžeme použít tyto jednoduché vzorce:</p>
<ul>
<li><strong>Převod z 2D do 1D</strong> - abychom se dostali na cílovou pozici, musíme přeskočit <code>row</code> řádků, kde
každý řádek má <code>cols</code> prvků, a poté ještě musíme přičíst pozici sloupce (<code>col</code>).
<pre><code class="language-c">int to_1d(int row, int col, int cols) {
    return row * cols + col;
}
</code></pre>
</li>
<li><strong>Převod z 1D do 2D</strong> - pro převod z 1D indexu zpět na 2D index stačí aplikovat opačný postup.
Nejprve vydělíme 1D index počtem sloupců, abychom zjistili, na jakém jsme řádku, a poté použijeme
zbytek po dělení, abychom zjistili, na jakém jsme sloupci.
<pre><code class="language-c">void to_2d(int index, int cols, int* row, int* col) {
    *row = index / cols;
    *col = index % col;
}
</code></pre>
</li>
</ul>
<p>Tento koncept lze zobecnit na libovolně rozměrné pole (3D, 4D, ...).</p>
<h2><a class="header" href="#vícerozměrné-pole-v-c" id="vícerozměrné-pole-v-c">Vícerozměrné pole v <em>C</em></a></h2>
<p><em>C</em> obsahuje základní podporu pro vytváření vícerozměrných <a href="c/pole/staticke_pole.html">statických polí</a>. Při
vytváření pole stačí použít hranaté závorky pro každou dimenzi pole. Například takto lze vytvořit
2D pole s rozměry <code>3x3</code> na zásobníku:</p>
<pre><code class="language-c">int pole[3][3];
</code></pre>
<p>Výhoda takovýchto polí je, že překladač provede převod z 2D indexu na 1D index za vás, a můžete tak
toto pole přímo indexovat vícerozměrným indexem. Například první prvek pole z kódu výše lze nalézt
na pozici <code>pole[0][0]</code>, poslední na pozici <code>pole[2][2]</code>.</p>
<p>Takováto pole jsou v paměti vyskládána postupně dle jednotlivých dimenzí zleva. Nejprve tedy v
paměti leží prvek <code>pole[0][0]</code>, poté <code>pole[0][1]</code>, ..., <code>pole[1][1]</code>, <code>pole[1][2]</code> atd. Pokud
bychom měli 2D pole a první index bychom pokládali za index řádku, tak toto vyskládání odpovídá
<em>row major</em> pořadí.</p>
<p>Vícerozměrná pole v <em>C</em> lze zobecnit do vyšších dimenzí (můžete tak použít například
<code>int pole[3][3][3]</code> atd.), nicméně je dobré to nepřehánět, aby kód zůstal přehledný.</p>
<h2><a class="header" href="#vícerozměrné-dynamické-pole" id="vícerozměrné-dynamické-pole">Vícerozměrné dynamické pole</a></h2>
<p>Pokud potřebujete vícerozměrné pole s <a href="c/pole/dynamicke_pole.html">dynamickou velikostí</a>, stačí při volání
funkce <code>malloc</code> vytvořit dostatek paměti pro všechny rozměry. Pokud bychom například chtěli
naalokovat paměť pro 2D obrázek s <code>rows</code> řádky a <code>cols</code> řádky, můžeme použít následující volání
funkce <code>malloc</code>:</p>
<pre><code class="language-c">int* image_memory = (int*) malloc(rows * cols * sizeof(int)));
</code></pre>
<h1><a class="header" href="#text" id="text">Text</a></h1>
<p>Tato sekce je ve výstavbě 🚧.</p>
<!--## Práce s dynamicky alokovanou pamětí a řetězci znaků (string)

Typická literatura se zabývá prací s dynamicky alokovanou pamětí až v
pozdějších kapitolách. Dovolme si lehký komentář, když vyslovíme
tvrzení, že ,,pak jsou z toho všichni ztraceni”. Zkusme se tedy podívat
na práci s dynamicky alokovanou pamětí hned na začátku, aby nás pak
práce s ní zbytečně nepřekvapovala.

Doposud jsme viděli vytváření celočíselných proměnných, které
reprezentují jedno číslo. Co když ale potřebujeme, aby bylo těchto čísel
více? Odpověď je snadná. Použijeme dynamicky alokované pole čísel. (Ano,
i staticky alokované pole je možnost, ale nesmí být příliš veliké
(dlouhé)). Na druhou stranu, dynamicky alokované pole by zase nemělo být
příliš krátké.

Při programování v jazyce *C* máme k dispozici dva druhy paměti. Jsou to:
**stack** (česky **zásobník**) a **heap** (česky **halda**). Když jsme
definovali celočíselné promenné v předchozí části, jejich obsah
(hodnoty) se ukládal na stacku. Programům je však k dispizici jen
omezený stack (např. 32 MB). Když chceme využívat v našich programech
více paměti, musíme použít heap.

Pro to, abychom si od operačního systému (OS) vyžádali nějakou paměť na
heapu, používáme funkci `malloc`, která nám vrátí pointer (ukazatel) na začátek
takovéto paměti. Zajisté znáte anglické tvrzení: ,,There’s nothing like
a free lunch”. I za takto poskytnutou paměť se nějakým způsobem platí.
Jazyk *C* nemá automatickou správu paměti, a proto ji musíme vlastnoručně
OS vrátit, když ji již nepotřebujeme. K tomu nám slouží funkce `free`
(jak příznačný název).

Pojďme se podívat na příklady použití. Stringy (řetězce znaků) jsou
typickým příkladem, kdy potřebujeme nějaké pole pro reprezentaci více
hodnot (třeba nějakých vět, ale také často textových dat).

```c
char c = 'A';  // umoznuje reprezentaci pouze jednoho znaku
char * str = NULL;
str = (char *)malloc( 20 * sizeof( str[ 0 ] ) );

sprintf( str, "Hello, World!" );

printf( "str: '%s'\n", str ); // str: 'Hello, World!'
printf( "str length: %d\n", strlen( str ) ); // 13

free( str ); // pointer na str jiz nepotrebuji, vracim pamet

str = NULL;  // jsem slusny a pointer nastavim na NULL,
             // aby bylo jasne, ze nikam neukazuje
```

To, že budeme chtít pracovat s dynamicky alokovanou pamětí, musíme
jazyku *C* řící tak, že definice proměnné bude pointerem, který bude
ukazovat na takovou paměť. To zajistíme jednoduše tak, že před název
proměnné napíšeme znak `*`. Funkce `malloc` nám vrací tzv. pointer na úsek paměti o
velikosti, kterou jsme chtěli. Pokud nám OS paměť nepřidělí, vrátí
funkce pointer na tzv. `NULL`. Toto bychom měli řádně zkontrolovat, ale pro
přehlednost příkladu to není uvedeno. Velikost paměti, kterou od OS
požadujeme se uvádí v bytech (česky bajtech). Každý datový typ vyžaduje
pro uložení informace nějaký počet bytů. Nejměnší datový typ `char` požaduje 4
byty. Typ `int`, pro uložení celých čísel, vyžaduje typicky 4 byty. Reálná
čísla uložená v typu `float` vyžadují 4 byty a reálná čísla uložená v typu `double`
vyžadují 8 bytů. Každá platfroma, na které bude náš program přeložen
však může datovým typům přiřadit jiný počet bytů. Abychom si nemuseli
pamatovat, kolik bytů jaký typ zabírá, existuje v jazyce *C* operátor `sizeof`,
který nám vrátí, kolik bytů zadaný typ vyžaduje. Potom již jen toto
číslo stačí přenásobit požadovanou délkou pole. V našem příkladu
požadujeme délku řetězce 20 znaků. Jazyk *C* nebyl zcela jistě konstruován
pro práci se stringy... Pro to, abychom naše pole znaků naplnili nějakým
obsahem, musíme použít funkci `sprintf`. Ta bere jako první parametr ukazatel na
paměť, kde má řetězec uložit, druhým parametrem je pak jaký řetězec se
má vložit. Případný třetí parametr pak může obsahovat proměnné, jejichž
obsah chceme vložit do formátovacího řetězce. Obsah proměnné `str` je pak
tištěn ve funkci `printf`. Délku řetězce je možno zjistit funkcí `strlen`, která vrací
délku řetězce jako celé číslo. Po ukončení práce s dynamicky alokovanou
pamětí je třeba jí vrátit zpět OS. To se provede voláním funkce `free`, která
bere jako argument pointer na dynamicky alokovanou paměť. V našem
případě je to `str`. Bývá ještě dobrým zvykem, abychom takto uvolněný pointer
nastavili na `NULL`. Takto nastavený pointer jasně říká, že neukazuje na
žádnou paměť.
-->
<h1><a class="header" href="#znaky" id="znaky">Znaky</a></h1>
<p>Tato sekce je ve výstavbě 🚧.</p>
<h1><a class="header" href="#Řetězce" id="Řetězce">Řetězce</a></h1>
<p>Tato sekce je ve výstavbě 🚧.</p>
<h1><a class="header" href="#struktury" id="struktury">Struktury</a></h1>
<p>Tato sekce je ve výstavbě 🚧.</p>
<!--Již umíme pracovat s jednoduchými datovými typy, které nám mohou
reprezentovat celá nebo reálná čísla, či řetězce znaků. Práce se
strukturovanými datovými typy můžeme do jisté míry považovat za
předstupeň k objektově orientovanému programování.

## Co jsou struktury

Představme si, že bychom chtěli pomocí jednoduchých datových typů řešit
komplexnější problém. Tento problém by ke svému popisu potřeboval více
proměnných. Jako jednoduchý přiklad můžeme použít reprezentaci obrazu. V
takovém případě potřebujeme reprezentovat alespoň hodnoty v jednotlivých
pixelech a počet řádků (výšku) a počet sloupců (šířku) obrazu. Pro
jednoduchost předpokládejme obrázek ve stupních šedi. Ukažme si, jak by
taková reprezentace v jazyce *C* vypadala.

```c
unsigned char * img_data;
int img_rows;
int img_cols;
```

(**TODO: Pripravit to na TGA header**)

Pointer `unsigned char` na s názvem `img_data` nám bez problému může reprezentovat 8 bitové obrazy
ve stupních šedi, neboť do něj můžeme ukládat hodnoty 0 - 255 (2<sup>8</sup> = 256 různých hodnot).
Představme si dále, že bychom chtěli takovýto obrázek o nějaké velikosti
nastavit na černou barvu (hodnota `0`).

```c
void set_image_to_black( unsigned char * img_data,
                         const int img_rows, const int img_cols )
{
    for ( int y = 0; y < img_rows; y++ ) {
        for ( int x = 0; x < img_cols; x++ ) {
            img_data[ x + y * img_cols ] = 0;
        }
    }
}
```

Jak můžete vidět, do funkce `set_image_to_black` posíláme všechny parametry obrázku, abychom
s ním mohli pracovat. Snadno si lze představit, že se složitějšími
problémy by snadno mohl počet parametrů funkcí značně narůstat.

Pro zefektivnění takové práce nám slouží strukturované datové typy,
jednodušeji struktury (anglicky *structures*). V jazyce *C* je pro definici
datových struktur vyhrazeno klíčové slovo `struct`. Pojďme se podívat, jak by
definice takového obrázku mohla vypadat.

```c
struct ImageStruct {
    unsigned char * data;
    int rows;
    int cols;
};
```

Jak můžete vidět, definice začíná požitím klíčového slova `struct`, které je
následovano jménem struktury. V následném bloku jsou pak definovani
členové struktury, které nazýváme `atributy`, s jejich příslušnými
datovými typy. Na první pohled již není nutné ke jménům členů struktury
obrázku přidávat předponu `img_`, neboť jejich členství v této datové
struktuře je jasně dáno.

Struktura ovšem není datovým typem, proto ji nelze použít přímo jako
definici typu (pokud ovšem nepoužijete C++ překladač). Proto se často
používá definice aliasu na datovou strukturu. K definici takového aliasu
se používá klíčové slovo `typedef`. Toto slovo má následující syntaxi:

```c
typedef struct tag_name struct_alias;
```

Za `tag_name` dosazujeme jméno naší struktury, za `struct_alias` nové jméno, pod kterým chceme
naši strukturu používat jako datový typ. Příklad pro naši strukturu s
obrázkem tedy bude vypadat následovně:

```c
struct ImageStruct {
    unsigned char * data;
    int rows;
    int cols;
};

typedef struct ImageStruct Image;

Image * image;
```


Dále můžeme s pointrem `* image` pracovat tak, že mu naalokujeme dynamickou paměť
tak, jak jsme si již ukázali.

**Cvičení:** Vytvořte si vlastní strukturu pro reprezentaci
osoby (`Person`) s několika atributy.

K jednotlivým atributům struktury přistupujeme pomocí tečkové (`.`) nebo
šipkové (`->`) notace. Tečku používáme, když je struktura vytvořena na
stacku. Šipku pak používáme pro přístup k atributům struktury, která je
alokována na heapu.

Ukažme si tedy příklad, kdy budeme chtít nastavit počet řádků nějakého
obrázku:

```c
struct ImageStruct {
    unsigned char * data;
    int rows;
    int cols;
};

typedef struct ImageStruct Image;

Image * heap_image;
Image   stack_image;

// alokace...

// teckova notace
stack_image.rows = 480;

// sipkova notace
heap_image->rows = 480;
```

Můžeme vidět, že rozdíl je nepatrný, je však nutné na něj dávat pozor,
jinak náš program nepůjde přeložit.
-->
<h1><a class="header" href="#struktury-a-funkce" id="struktury-a-funkce">Struktury a funkce</a></h1>
<p>Tato sekce je ve výstavbě 🚧.</p>
<!--Práce se strukturami ve funkcích nepodléhá nějakým syntaktickým
pravidlům. Zavedeme si však pár pravidel pro nás samotné, abychom se v
našem kódu lépe orientovali.

Pokud budeme pracovat se strukturou ve funkcích, bývá dobrým zvykem, aby
jméno takové funkce začínalo názvem struktury (malými pásmeny) a
následně jsou podtržítky oddělena slova vyjadřující operaci, kterou se
strukturou provádíme.

Ukažme si, jak bychom alokovali strukturu, kterou používíme pod aliasem `Image`.

```c
struct ImageStruct {
    unsigned char * data;
    int rows;
    int cols;
};

typedef struct ImageStruct Image;

Image * heap_image;

// alokuje prazdny obrazek
Image * image_new( const int rows, const int cols ) {
    Image * image = NULL;
    image = (Image *)malloc( sizeof( image[ 0 ] ) );
    image->data = (unisgned char *)malloc( rows * cols * sizeof( image->data[ 0 ] ) );
    image->rows = rows;
    image->cols = cols;
    return image;
}

heap_image = image_new( 640, 480 );
```

Na výpisu kódů uvedeném výše můžeme vidět, že funkce `image_new` vytváří dynamicky
alokovanou datovou strukturu `Image`. Popišme si, co se přesně děje. Návratový
typ funkce `image_new` je pointer na strukturu `Image` (je to tedy `Image *`).
Na řádku 13 si vytvoříme nový
pointer na `Image`, se kterým budeme pracovat (alokovat jej a jeho atributy) a
také jej vrátíme na konci funkce. Pro tento pointer alokujeme paměť o
velikosti struktury `Image` na řádku 15. Dále alokujeme prostor pro jasy jednotlivých
pixelů obrázku na řádku 17. Atributy `rows` a `cols` struktury `Image` nastavujeme na řádcích 19 a 20.
Nakonec vracíme takto vytvořenou strukturu na řádku 22. Volání takové
funkce je ukázáno na řádku 25, kde vytváříme obrázek o velikosti
$640 \times 480$ pixelů.

Ukažme si ještě, jak bychom takto naalokovanou struktury zase uvolnili,
tzn. vrátili bychom alokovanou paměť zpět OS.

```c
// dealokuje strukturu s obrazkem
void image_free( Image * self ) {
    free( image->data );  // uvolnujeme jasy pixelu
    free( image );        // uvolnujeme strukturu
}

image_free( heap_image );
```

Jak můžeme vidět, funkce `image_free` akceptuje jeden argument, který je pointrem na
strukturu `Image`. Ten je předán pod názvem `self`, ale můžeme si jej pojmenovat jak
nám libo. V těle funkce se nácházeji dvě dealokační volání funkce `free`.
První volání uvolňuje pamět pro jasy pixelů. Druhé volání pak uvolňuje
paměť, kterou zabírá samotná datová struktura. Důležité je, v jakém
pořadí jsou jednotlivé atributy a datová struktura samotná uvolňovány.
Platí jednoduché pravidlo, že nejprve uvolňujeme data atributů a až pak
můžeme uvolnit strukturu samotnou. V opačném případě bychom totiž při
uvolnění struktury ztratili pointer na atributy a tím by paměť byla až
do konce běhu programu ztracena.

**Cvičení:** Upravte funkci `image_new` tak, aby data, která
reprezentují pixely byla nastavena na černou barvu (hodnota `0`).

**Cvičení:** Vytvořte funkci, která na zadanou souřadnici
pixelu v obrázku reprezentovaného strukturou `Image` nastaví zadanou hodnotu.

**Cvičení:** Vytvořte funkci, která do obrázku
reprezentovaného strukturou `Image` nakreslí zvoleným jasem obdélník o zadaných
rozměrech.
-->
<h1><a class="header" href="#soubory" id="soubory">Soubory</a></h1>
<p>Tato sekce je ve výstavbě 🚧.</p>
<h1><a class="header" href="#modularizace" id="modularizace">Modularizace</a></h1>
<p>Tato sekce je ve výstavbě 🚧.</p>
<h1><a class="header" href="#knihovny" id="knihovny">Knihovny</a></h1>
<p>Tato sekce je ve výstavbě 🚧.</p>
<!--**Knihovny** (*libraries*) jsou kusy kódu, které lze používat pomocí nadefinovaného rozhraní a díky tomu
je lze sdílet mezi více projekty/programy, aby se stejný kód nemusel psát pokaždé znovu. Existuje obrovské
množství *C* knihoven, které jsou volně dostupné na internetu, například pro [vykreslování grafiky](https://www.libsdl.org/),
[sazbu fontů](https://www.freetype.org/) nebo [kompresi dat](http://zlib.net/). 

Knihovny se obvykle nesdílí čistě jako archiv nebo adresář se zdrojovým kódem. Obvykle se setkáte s tím,
že knihovna poskytuje dvě věci: 

1. **Hlavičkové soubory** (*header files*) s příponou `.h`, které definují rozhraní, jak knihovnu používat.
2. Soubory s příponami `.a` nebo `.so`, které obsahují již přeložené zdrojové soubory knihovny ve formě
spustitelného kódu.

> Více o knihovnách se můžete dozvědět například [zde](https://www.itnetwork.cz/cecko/linux/cecko-a-linux-staticke-a-dynamicke-knihovny).

#### Použití knihoven pomocí `gcc`
Abyste ve vašem programu použili nějakou knihovnu, musíte ji k vašemu programu tzv. **přilinkovat**.
O to se stará tzv. **linker**, který za vás umí spustit překladač `gcc`.

Dejme tomu, že chcete použít knihovnu s názvem `foo`, která obsahuje hlavičkové soubory v adresáři
`/usr/foo/include` and zkompilovaný knihovní soubor v adresáři `/usr/foo/lib/libfoo.so`. Překladači
`gcc` musíte říct, kde jsou umístěny knihovní soubory pomocí přepínače `-L`, které konkrétní soubory chcete
přilinkovat pomocí přepínače `-l` a kde jsou umístěny hlavičkové soubory pomocí přepínače `-I`:

```bash
$ gcc -o program main.c -L/usr/foo/lib/ -lfoo -I/usr/foo/include
```

Používá se konvence, že pokud je název knihovního souboru `lib<nazev>.so`, tak název knihovny je `<nazev>`,
pro `gcc` se tedy zadá pouze `-l<nazev>` a ne `-llib<nazev>.so`. Přepínače `-l` by měly být vpravo (za)
názvy zdrojových souborů. Všechny tři tyto přepínače lze použít vícekrát v rámci jednoho spuštění `gcc`.

Poté ve zdrojovém souboru vložíte hlavičkové soubory knihovny a můžete používat funkce, které nabízí.

Pokud je knihovna statická (knihovní soubor má příponu `.a`), tak už není třeba dělat nic dále. Pokud
je však knihovna dynamická (přípona `.so`), tak k načtení knihovny dojde až při samotném spuštění programu
(ne při jeho překladu). Musíme tak programu při jeho spuštění říct, kde má knihovnu hledat (pokud ji neumí
naleznout automaticky).

Abychom zjistili, které dynamické knihovny náš program vyžaduje, můžeme použít program `ldd`:
```bash
$ ldd program
linux-vdso.so.1 (0x00007ffce73ae000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f193e1af000)
/lib64/ld-linux-x86-64.so.2 (0x00007f193e7a2000)
foo => ...
```

Pokud pro naši knihovnu ve výstupu není uvedena správná cesta, musíme při spuštění programu nastavit
**proměnnou prostředí** `LD_LIBRARY_PATH` a uložit do ní cestu k adresáři, ve které se naše knihovna nachází:

```bash
$ LD_LIBRARY_PATH=/usr/foo/lib ./program
```
-->
<h1><a class="header" href="#Úlohy" id="Úlohy">Úlohy</a></h1>
<p>Tato sekce je ve výstavbě 🚧.</p>
<h1><a class="header" href="#tga" id="tga">TGA</a></h1>
<p>Tato sekce je ve výstavbě 🚧.</p>
<!--## Zápis struktur do souboru

Struktury jsou i dobrým komunikačním nástrojem.
Můžeme je uložit v podobě souboru na disk a přečíst je pak jiným programem, který je může dále zpracovat.
Modelovou situací může být program pro zpracování fotografií.

V první řadě budeme simulovat fotoaparát, který uloží obrázek do souboru.
Existuje mnoho způsobů, jak uložit obraz. Tyto způsoby jsou definovýny různými formáty
(např. `JPG`, `PNG`, `BMP`, `TGA`, apod.).
Asi nejjednodušeji uchopitelným formátem je `TGA`, jehož hlavička vypadá následovně [^1]:

<table>
    <thead>
        <tr>
            <th>Č. položky</th>
            <th>Délka</th>
            <th>Jméno položky</th>
            <th>Popis</th>
        </tr>
    </thead>
    <tbody>
        <tr><td>1</td><td>1 byte	</td><td>ID length</td>                 <td>Length of the image ID field</td>   </tr>
        <tr><td>2</td><td>1 byte	</td><td>Color map type</td>            <td>Whether a color map is included</td></tr>
        <tr><td>3</td><td>1 byte	</td><td>Image type</td>                <td>Compression and color types</td>    </tr>
        <tr><td>4</td><td>5 bytes	</td><td>Color map specification</td>   <td>Describes the color map</td>        </tr>
        <tr><td>5</td><td>10 bytes	</td><td>Image specification</td>       <td>Image dimensions and format</td>    </tr>
    <tbody>
</table>

[^1]: https://en.wikipedia.org/wiki/Truevision_TGA
--><h1><a class="header" href="#sdl" id="sdl">SDL</a></h1>
<p>Tato sekce je ve výstavbě 🚧.</p>
<!--`sudo apt install libsdl2-image-dev libsdl2-dev libsdl2-ttf-dev`-->
<h1><a class="header" href="#co-dál" id="co-dál">Co dál?</a></h1>
<p><em>C</em> je relativně malý jazyk, pokud jste si tedy přečetli předchozí část tohoto textu, tak znáte
většinu důležitých prvků, která jsou v <em>C</em> dostupné. Nicméně neukázali jsme si úplně všechny – zde
je seznam několika vybraných věcí, které byly buď moc pokročilé pro UPR anebo jsme je jednoduše
nepotřebovali použít:</p>
<ul>
<li><a href="https://en.cppreference.com/w/c/variadic"><strong>Variadiacké funkce</strong></a>, které umožňují přijímat
libovolný počet parametrů (takto funguje například i nám známá funkce
<a href="https://devdocs.io/c/io/fprintf"><code>printf</code></a>).</li>
<li><a href="https://www.cprogramming.com/tutorial/function-pointers.html"><strong>Ukazatele na funkce</strong></a>
(<em>function pointers</em>), které umožňují ukládat adresy funkcí do ukazatelů.</li>
<li><a href="https://en.cppreference.com/w/c/language/enum"><strong>Enumerace</strong></a> (<em>enumerations</em>), které umožňují
seskupit pojmenované konstanty.</li>
<li><a href="https://en.cppreference.com/w/c/language/union"><strong>Sjednocené struktury</strong></a> (<em>unions</em>), které
umožňují interpretovat strukturu jako více různých datových typů.</li>
<li><a href="https://en.cppreference.com/w/c/language/bit_field"><strong>Bitová pole</strong></a> (<em>bit fields</em>), která
umožňují rozdělit paměť struktury na úrovni jednotlivých bitů. </li>
</ul>
<p>Pokud si chcete ověřit, jak jste na tom se znalostí jazyka <em>C</em>, projděte si tyto
<a href="https://www.slideshare.net/olvemaudal/deep-c">slidy</a>. Pokud budete umět odpovídat jako blonďatý
kluk, tak znáte základy jazyka <em>C</em>. Pokud budete umět odpovídat jako dívka s růžovými vlasy,
tak už vás v jazyce <em>C</em> téměř nic nepřekvapí.</p>
<p>Se znalostí samotného jazyka <em>C</em> souvisí i spousta dalších konceptů, se kterými se postupně musíte
seznámit, pokud chcete opravdu dopodrobna pochopit, co přesně se v počítači děje, když spustíte
vámi napsaný program. Poté můžete těchto znalostí využít k tvorbě robustnějších a rychlejších
programů. Na následujících odkazech se můžete dozvědět například:</p>
<ul>
<li>Jak fungují <a href="http://poli.cs.vsb.cz/edu/osy/osnova.html">operační systémy</a>.
<ul>
<li>Nebo dokonce jak si nějaký <a href="https://littleosbook.github.io/">napsat od nuly</a>.</li>
</ul>
</li>
<li>Jak komunikovat s jinými programi po <a href="http://www.beej.us/guide/bgnet/">síti</a>.</li>
<li>Jak psát programy pomocí <a href="http://poli.cs.vsb.cz/edu/soj/down/soj-skripta.pdf">instrukcí procesoru</a></li>
<li>Jak urychlit provádění programů:
<ul>
<li>Pomocí <a href="https://computing.llnl.gov/tutorials/pthreads/">vláken</a>, které umí využít potenciál
vícejádrových procesorů.</li>
<li>Pomocí <a href="http://www.cs.uu.nl/docs/vakken/magr/2017-2018/files/SIMD%20Tutorial.pdf">vektorových instrukcí</a>,
které umí pracovat s více než jednou hodnotou najednou.</li>
<li>Pomocí pochopení <a href="https://github.com/Kobzol/hardware-effects">architektury procesoru</a>, která
silně ovlivňuje výkon programů.</li>
</ul>
</li>
<li>Jak si napsat vlastní <a href="https://www3.nd.edu/%7Edthain/compilerbook/compilerbook.pdf">překladač</a> či
<a href="http://www.buildyourownlisp.com/chapter1_introduction">programovací jazyk</a>.</li>
<li>Jak si napsat vlastní <a href="https://cstack.github.io/db_tutorial/">databázi</a>.</li>
<li>Jak funguje <a href="http://mrl.cs.vsb.cz/people/fabian/pg1_course.html">počítačová grafika</a>.</li>
<li>Jak si napsat vlastní <a href="https://learnopengl.com/">3D herní engine</a> pomocí OpenGL.</li>
</ul>
<h1><a class="header" href="#různé" id="různé">Různé</a></h1>
<p>Tato sekce obsahuje různá témata a návody, které nezapadají do zbytku textu, ale je dobré o nich
vědět.</p>
<h1><a class="header" href="#rozklad-problému" id="rozklad-problému">Rozklad problému</a></h1>
<p>Často se setkáte s tím, že dostanete k naprogramování úlohu, se kterou si nevíte rady a netušíte ani
jak začít. Například:</p>
<p><code>Načti obrázek z disku, změň jeho velikost, ulož ho do jiného souboru a vykresli jej na obrazovku.</code></p>
<p>Tato úloha vypadá velmi jednoduše, když je zadaná větou (v češtině), ale obzvláště pro začínající
programátory je obtížné převést takovouto úlohu do programovacího jazyka. Obecným pravidlem k usnadnění
řešení složitých úloh je rozdělovat je na menší a jednodušší podúlohy tak dlouho, dokud se nedostaneme
k podúloze, kterou již umíme vyřešit. Poté z těchto malých kousků, které máme vyřešené, zpětně poskládáme
celý program, který vyřeší původní úlohu.</p>
<p>Například zmíněnou úlohu můžeme rozdělit na následující podúlohy: </p>
<ul>
<li>Načti obrázek z disku
<ul>
<li>Otevři soubor se vstupním obrázkem</li>
<li>Načti hlavičku obrázku</li>
<li>Vytvoř paměť pro pixely obrázku
<ul>
<li>Naalokuj dostatek paměti dle hlavičky (šířka x výška)</li>
</ul>
</li>
</ul>
</li>
<li>Změň velikost obrázku
<ul>
<li>Vytvoř obrázek s novým rozměrem</li>
<li>Překopíruj původní obrázek do nového obrázku
<ul>
<li>Projdi všechny pixely nového obrázku
<ul>
<li>Projdi každý řádek</li>
<li>Pro každý řádek projdi každý sloupec</li>
</ul>
</li>
<li>Pro každý pixel spočítej původní pozici pixelu
<ul>
<li>Pro výpočet použij poměr šířky/výšky nového/starého obrázku</li>
</ul>
</li>
<li>Překopíruj pixel ze starého obrázku do nového</li>
</ul>
</li>
<li>Vrať nový obrázek</li>
</ul>
</li>
<li>Zapiš upravený obrázek
<ul>
<li>Otevři soubor k zápisu</li>
<li>Zapiš hlavičku obrázku do souboru</li>
<li>Zapiš pixely obrázku do souboru</li>
</ul>
</li>
<li>Vykresli upravený obrázek
<ul>
<li>Vytvoř okno pro vykreslení obrázku</li>
<li>Překopíruj pixely obrázku do otevřeného okna</li>
<li>Zobraz okno s obrázkem</li>
</ul>
</li>
</ul>
<p>Pomocí tohoto univerzálního postupu se dříve či později dostanete k (pod)úloze, kterou byste již měli umět
vyřešit (např. otevření souboru). Jakmile danou podúlohu vyřešíte, tak budete o krok blíže k řešení
původní složité úlohy.</p>
<p>Tímto způsobem můžeme programy rovnou od začátku začít psát. Například při řešení výše zmíněné úlohy
můžeme začít nadefinováním hlavní logiky programu pomocí volání funkcí, kde každá funkce bude reprezentovat
jednu podúlohu. I když funkce zatím nebudou naprogramované a později se třeba trochu změní, tak nám
toto rozdělení může pomoct přemýšlet nad problémem abstraktněji, zorientovat se v něm a také
získat naději, že se úlohu podaří vyřešit. Stejný princip opět můžeme použít při implementaci jednotlivých
funkcí. Program (či funkci) pak lze přečíst jako (anglickou) větu a je tak jednodušší pochopit, co má
vlastně dělat.</p>
<pre><code class="language-c">int main() {
    // načti obrázek
    FILE* input_file = open_file(...);
    Img image = load_image(input_file);

    // změň jeho velikost
    Img resized = resize_image(&amp;image);

    // zapiš obrázek
    FILE* output_file = open_file(...);
    write_image(input_file, &amp;resized);

    // vykresli upravený obrázek
    draw_image(&amp;resized);

    return 0;
}
</code></pre>
<h1><a class="header" href="#generování-náhodných-čísel" id="generování-náhodných-čísel">Generování náhodných čísel</a></h1>
<p>Počítače jsou <strong>deterministické</strong> stroje, což znamená, že stejný program vždy na stejný vstup
vrátí stejný výstup. Často ovšem chceme, aby naše programy obsahovaly prvky &quot;náhody&quot;, když chceme
například:</p>
<ul>
<li>Hodit si kostkou v deskové hře</li>
<li>Udělit náhodný počet zranění v rozsahu zbraně</li>
<li>Oživit hráče na náhodné pozici na mapě</li>
</ul>
<p>Počítače samy o sobě opravdovou náhodu vytvořit nemohou, nicméně můžou ji simulovat pomocí tzv.
<strong>pseudo-náhodných generátorů čísel</strong> (<em>pseudo-random number generation</em>).</p>
<p>Vygenerovat (pseudo-)náhodnou sekvenci čísel pomocí deterministických operací můžeme například
následujícím algoritmem:</p>
<ol>
<li>Začneme s číslem <code>S</code>, které se nazývá <strong>počáteční náhodná hodnota</strong> (<em>random seed</em>).</li>
<li>Aplikujeme nějakou matematickou operaci na <code>S</code> a vyjde nám nové číslo <code>N</code>.</li>
<li><code>N</code> použijeme jako vygenerované &quot;náhodné číslo&quot;.</li>
<li>Nastavíme <code>S = N</code>.</li>
<li>Opakujeme postup od bodu 2).</li>
</ol>
<p>Ukázka kódu, který takovýto algoritmus implementuje:</p>
<pre><code class="language-c editable">int S = 5;
int random() {
    int N = S;
    N = (5 * N + 3) % 6323;
    N = (4 * N + 2) % 8127;
    S = N;
    return N;
}
int main() {
    int r1 = random(); // 114
    int r2 = random(); // 2294
    int r3 = random(); // 4348
    int r4 = random(); // 2971
    int r5 = random(); // 723
    return 0;
}
</code></pre>
<p>Takovýto algoritmus bude generovat (nekonečnou) sekvenci čísel, která bude lidem připadat &quot;náhodná&quot;
(bude těžké uhodnout, jaké číslo algoritmus vrátí příště).</p>
<h3><a class="header" href="#volba-počáteční-hodnoty-s" id="volba-počáteční-hodnoty-s">Volba počáteční hodnoty <code>S</code></a></h3>
<p>Určite jste si všimli, že výše zmíněný algoritmus bude pokaždé generovat stejnou sekvenci čísel pro
stejné počáteční <code>S</code>. To se může hodit, chceme-li například mít možnost zpětně přehrát sekvenci
pseudo-náhodných čísel, například pro odladění chyby v programu. Nicméně pokud by sekvence byla pokaždé
stejná, tak o (pseudo-)náhodě nemůže být řeč.</p>
<p>Proto se obvykle hodnota <em>seedu</em> volí tak, aby při každém spuštění programu byla jiná. Přirozenou
volbou pro počáteční hodnotu <code>S</code> je tak například čas<sup class='margin-toggle sidenote-number'>1</sup> při spuštění programu. Lze ale také použít
například pohyby myši nebo stisky kláves, které nedávno na počítači proběhly.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Ve formě <a href="https://en.wikipedia.org/wiki/Unix_time">UNIX časového razítka</a>, tedy počtu vteřin
uběhlých od 1. 1. 1970.</p>
</span>
<h3><a class="header" href="#pseudo-náhodný-generátor-ve-standardní-knihovně-c" id="pseudo-náhodný-generátor-ve-standardní-knihovně-c">Pseudo-náhodný generátor ve standardní knihovně <em>C</em></a></h3>
<p>Při praktickém použití si obvykle nebudete psát generátor pseudo-náhodných sami, ale použijete již
hotové řešení. To nabízí například standardní knihovna <em>C</em> ve formě funkcí <code>srand</code> (nastav hodnotu
<em>seed</em>u) a <code>rand</code> (vygeneruj pseudo-náhodné číslo):</p>
<pre><code class="language-c editable">#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main() {
    int now = (int) time(NULL); // získej současný čas
    srand(now); // nastav S na současný čas

    int num1 = rand(); // pseudo-náhodné číslo z intervalu [0, RAND_MAX]
    int num2 = rand() % 100; // z intervalu [0, 99]
    int num3 = rand() % 100 + 5; // z intervalu [5, 104]
    float num4 = rand() / (float) RAND_MAX; // z intervalu [0.0, 1.0]

    return 0;
}
</code></pre>
<h1><a class="header" href="#funkce-main" id="funkce-main">Funkce <code>main</code></a></h1>
<p>Funkce <code>main</code> je speciální funkce, která se začne vykonávat při spuštění programu. Může vypadat
například takto:</p>
<pre><code class="language-c">int main() {
    return 0;
}
</code></pre>
<p>Proč tato funkce vrací číslo (<code>int</code>) a proč jsme v dosavadních programech z ní vždy vraceli hodnotu
<code>0</code>? Operační systémy mají zavedenou konvenci, že každý spuštěný program by měl po svém vykonání
vrátit číselnou hodnotu, která systému napoví, jestli program proběhl úspěšně nebo ne. Díky tomu
pak lze relativně jednoduše detekovat, jestli v programu nastala chyba, a případně na ni nějak
zareagovat (na Windows možná znáte dialog &quot;Program neproběhl správně...&quot;).</p>
<p>Číslo, které vrátíte z funkce <code>main</code>, se použije právě jako návratová hodnota programu pro operační
systém. Význam navrácených čísel není nijak standardizován, jediné, co platí obecně, je, že hodnota
<code>0</code> značí úspěch a jakákoliv jiná hodnota značí neúspěch. Proto tedy za normálních okolností z
<code>main</code>u vracíme <code>0</code>, abychom dali systému najevo, že program proběhl úspěšně.</p>
<h3><a class="header" href="#vstupní-parametry-funkce-main" id="vstupní-parametry-funkce-main">Vstupní parametry funkce <code>main</code></a></h3>
<p>Funkce <code>main</code> je speciální ve více ohledech. Kromě formy bez parametrů, kterou jste viděli výše,
můžete <code>main</code> použít také takto, s dvěma parametry:</p>
<pre><code class="language-c">int main(int argc, char** argv) {
    return 0;
}
</code></pre>
<p>První parametr je typu <code>int</code> a druhý parametr typu <a href="ruzne/../c/prace_s_pameti/ukazatele.html">ukazatel</a> na
<a href="ruzne/../c/text/retezce.html">řetězec</a>. Do těchto parametrů se uloží hodnoty zadané při spuštění programu v
terminálu, tzv. <strong>argumenty příkazového řádku</strong> (<em>command line arguments</em>). Parametr <code>argc</code>
(<em>argument count</em>) bude obsahovat počet předaných argumentů a parametr <code>argv</code> obsahuje ukazatel na
první prvek <a href="ruzne/../c/pole/pole.html">pole</a> <em>C</em> <a href="ruzne/../c/text/retezce.html">řetězců</a>, kde každý řetězec bude obsahovat
jeden argument. Prvním argumentem je dle konvence vždy cesta k spustitelnému souboru programu,
který je právě spouštěn, další argumenty se nastaví podle zadaného textu v terminálu (argumenty
jsou oddělené mezerou).</p>
<p>Například, pokud program spustíte takto: <code>./program hello world</code>, tak parametry funkce <code>main</code> budou
mít následující hodnoty:</p>
<ul>
<li><code>argc</code> bude obsahovat celé číslo <code>3</code> </li>
<li><code>argv[0]</code> bude obsahovat řetězec <code>&quot;./program&quot;</code></li>
<li><code>argv[1]</code> bude obsahovat řetězec <code>&quot;hello&quot;</code></li>
<li><code>argv[2]</code> bude obsahovat řetězec <code>&quot;world&quot;</code></li>
</ul>
<h1><a class="header" href="#Úlohy-1" id="Úlohy-1">Úlohy</a></h1>
<p>V této sekci naleznete různé úlohy, které si můžete zkusit naimplementovat, abyste se zlepšili
v programování.</p>
<p>Další úlohy můžete najít také například na těchto odkazech:</p>
<ul>
<li><a href="https://adventofcode.com/2018/events">Advent of Code</a></li>
<li><a href="https://projecteuler.net/archives">Project Euler</a></li>
<li><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=3">Online Judge</a></li>
<li><a href="https://w3resource.com/c-programming-exercises/">W3 C programming exercises</a></li>
</ul>
<h1><a class="header" href="#základy" id="základy">Základy</a></h1>
<h2><a class="header" href="#obvod-a-obsah-obdélníku" id="obvod-a-obsah-obdélníku">Obvod a obsah obdélníku</a></h2>
<p>Program vypočítá a vypíše obvod a obsah obdélníku ze dvou celočíselných velikosti stran \( a \), \( b \) podle známých vzorců.</p>
<div style="display: flex; justify-content: center">
  <svg>
    <rect width=200 height=100 fill=#eee stroke=black />
    <text x=100 y=115 fill=black text-anchor=middle font-style=italic>a</text>
    <text x=210 y=50 fill=black text-anchor=middle font-style=italic>b</text>
  </svg>
  <div>
    $$\begin{aligned}
    o &= 2 \cdot (a + b) \\
    S &= a \cdot b
    \end{aligned}$$
  </div>
</div>
<details>
<summary>Výstup</summary>
<pre><code>a = 200
b = 100
o = 600
S = 20000
</code></pre>
</details>
<h2><a class="header" href="#obsah-vyšrafované-plochy" id="obsah-vyšrafované-plochy">Obsah vyšrafované plochy</a></h2>
<p>Ze zadané délky strany čtverce \( a \) a průměru kružnice \( d \) vypočítáme obsah vyšrafované plochy.
Výpočet budeme provádět pomocí datového typu <code>float</code> s využitím konstanty <code>M_PI</code> z knihovny <code>&lt;math.h&gt;</code>.
Druhou mocninu vypočítáme násobením, ale také pomocí funkce <code>pow</code> .
Při použití matematických funkcí je nutné program <a href="ulohy/../c/knihovny.html">linkovat</a> s knihovnou <code>math</code><sup class='margin-toggle sidenote-number'>10</sup>.
Výsledek zapíšeme na výstup na 4 desetinná místa. </p>
<span class='sidenote'><p><sup class='number'>10</sup> 
<code class="hljs">
$ gcc obsah.c -o obsah -lm
</code>
</p>
</span><div style="display: flex; justify-content: center">
	<svg viewBox="0 0 130 130" width=130 height=130>
		<pattern id="diagonalHatch" patternUnits="userSpaceOnUse" width="4" height="4">
		<path d="M-1,1 l2,-2
		M0,4 l4,-4
		M3,5 l2,-2" 
		style="stroke:black; stroke-width:1" />
		</pattern>
		<rect width=100 height=100 stroke=black fill="url(#diagonalHatch)" />
		<text x=50 y=115 fill=black text-anchor=middle font-style=italic>a</text>
		<text x=110 y=50 fill=black text-anchor=middle font-style=italic>a</text>
		<circle r=50 cx=50 cy=50 fill=#eee stroke=black />
		<text x=75 y=65 fill=black text-anchor=middle font-style=italic>r</text>
		<line x1=50 y1=50 x2=100 y2=50 stroke=black />
	</svg>
	<div>
		$$ S_{kruh} = \frac{\pi \cdot d^2}{4} $$
	</div>
</div>
<details>
<summary>Výstup</summary>
<pre><code>TODO
</code></pre>
</details>
<h2><a class="header" href="#prohození-dvou-čísel" id="prohození-dvou-čísel">Prohození dvou čísel</a></h2>
<p>Pomocí dočasné proměnné provedeme prohození čísel ve dvou proměnných.</p>
<details>
<summary>Výstup</summary>
<pre><code>a = 10
b = 50

a = 50
b = 10
</code></pre>
</details>
<h2><a class="header" href="#maximum-ze-tří-čísel" id="maximum-ze-tří-čísel">Maximum ze tří čísel</a></h2>
<p>Ze tří čísel nalezneme maximum.</p>
<p><img src="ulohy/../mdbook-plantuml-img/d485221c14076d6e9b25b89453fbb420e46b02ed.svg" alt="" /></p>
<details>
<summary>Výstup</summary>
<pre><code>a = 10
b = 40
c = 20

maximum je 40
</code></pre>
</details>
<h2><a class="header" href="#výpis-sudých-čísel" id="výpis-sudých-čísel">Výpis sudých čísel</a></h2>
<p>Vypište sudá čísla od 0 do 100 (včetně).</p>
<h2><a class="header" href="#fizzbuzz" id="fizzbuzz">FizzBuzz</a></h2>
<p>Naimplementujte <a href="https://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a><sup class='margin-toggle sidenote-number'>1</sup>. Vypište čísla 1 až 100 tak, že:</p>
<span class='sidenote'><p><sup class='number'>1</sup>Tento program často bývá obsahem interview programátorů ve firmách.</p>
</span>
<ul>
<li>pokud je číslo násobkem 3, tak vypište místo čísla <code>Fizz</code></li>
<li>pokud je číslo násobkem 5, tak vypište místo čísla <code>Buzz</code></li>
<li>pokud je číslo násobkem 3 i násobkem 5, tak vypíše místo čísla <code>FizzBuzz</code></li>
</ul>
<details>
<summary>Výstup programu</summary>
<pre><code>1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
Fizz Buzz
16
...
</code></pre>
</details>
<h2><a class="header" href="#fibonacciho-číslo" id="fibonacciho-číslo">Fibonacciho číslo</a></h2>
<p>Napište funkci, která vypočte <code>n</code>-té <a href="https://cs.wikipedia.org/wiki/Fibonacciho_posloupnost">Fibonacciho číslo</a>
(<code>n</code> bude parametrem funkce).</p>
<details>
<summary>Výstup funkce</summary>
<pre><code class="language-c">fibonacci(0);   // 0
fibonacci(1);   // 1
fibonacci(2);   // 1
fibonacci(3);   // 2
fibonacci(4);   // 3
fibonacci(5);   // 5
fibonacci(6);   // 8
</code></pre>
</details>
<h2><a class="header" href="#faktoriál" id="faktoriál">Faktoriál</a></h2>
<p>Napište funkci, která vypočte <a href="https://cs.wikipedia.org/wiki/Faktori%C3%A1l">faktoriál</a> předaného
parametru.</p>
<details>
<summary>Výstup funkce</summary>
<pre><code class="language-c">factorial(0);   // 1
factorial(1);   // 1
factorial(4);   // 24
factorial(5);   // 120
</code></pre>
</details>
<h2><a class="header" href="#textové-kreslení-obrazců" id="textové-kreslení-obrazců">Textové kreslení obrazců</a></h2>
<p>Vykreslete následující obrazce. Napište program tak, aby počet řádků, na který se
obrazec vykreslí, byl konfigurovatelný, tj. pro změnu počtu řádků by mělo stačit změnit jediný řádek
(jedinou proměnnou).</p>
<details>
<summary>Vyplněný čtverec</summary>
<pre><code>xxxx
xxxx
xxxx
xxxx
</code></pre>
</details>
<details>
<summary>Nevyplněný čtverec</summary>
<pre><code>xxxx
x  x
x  x
xxxx
</code></pre>
</details>
<details>
<summary>Čtverec vyplněný rostoucími čísly</summary>
<pre><code>xxxxx
x012x
x345x
x678x
xxxxx
</code></pre>
</details>
<details>
<summary>Diagonála</summary>
<pre><code>x
 x
  x
   x
    x
</code></pre>
</details>
<details>
<summary>Trojúhelník</summary>
<pre><code>  x  
 x x 
xxxxx
</code></pre>
</details>
<details>
<summary>Písmeno Z</summary>
<pre><code>xxxxxx
    x 
   x  
  x 
 x
xxxxxx
</code></pre>
</details>
<h2><a class="header" href="#načítání-pinu" id="načítání-pinu">Načítání PINu</a></h2>
<p>Načtěte od uživatele PIN (4 číslice). Poté opakovaně vyzývejte uživatele k zadání PINu. Pokud
uživatel zadá 3x nesprávný PIN, vypište chybovou hlášku a ukončete program.</p>
<h1><a class="header" href="#ukazatele-1" id="ukazatele-1">Ukazatele</a></h1>
<h2><a class="header" href="#nastavení-maxima" id="nastavení-maxima">Nastavení maxima</a></h2>
<p>Vytvořte funkci <code>set_max</code>, která přijme adresu celého čísla (<code>int</code>) pomocí ukazatele a dvě další
čísla a nastaví paměť na dané adrese na větší ze dvou zadaných čísel.</p>
<pre><code class="language-c">int res;
set_max(&amp;res, 5, 6);
// res == 6
</code></pre>
<h2><a class="header" href="#prohození-hodnoty" id="prohození-hodnoty">Prohození hodnoty</a></h2>
<p>Vytvořte funkci <code>swap</code>, která přijme dva ukazatele a prohodí hodnoty proměnných, na které ukazují.</p>
<pre><code class="language-c">int a = 5, b = 6;
swap(&amp;a, &amp;b);
// a == 6, b == 5
</code></pre>
<h2><a class="header" href="#výpočet-kořenů-kvadratické-rovnice" id="výpočet-kořenů-kvadratické-rovnice">Výpočet kořenů kvadratické rovnice</a></h2>
<p>Vytvořte funkci <code>quadratic_roots</code>, která vrátí počet kořenů kvadratické rovnice \( ax^2 + bx + c = 0 \) pomocí <code>return</code> a vypočítané kořeny vrátí pomocí předaných ukazatelů v argumentech funkce.</p>
<pre><code class="language-c">int quadratic_roots(float a, float b, float c, float *x1, float *x2);
</code></pre>
<p>Počet kořenů lze zjistit vypočítáním diskriminantu \( D = b^2 - 4ac \).
Pokud vyjde diskriminant záporný, tak funkce vrátí nulu, protože žádné řešení v \( \mathbb{R} \) neexistuje.
Pro nulový diskriminant funkce vrátí <code>1</code> a uloží dvojnásobný kořen na adresu ukazatelů <code>x1</code>, <code>x2</code>.
Pro kladný diskriminant funkce vrátí <code>2</code> a vypočítá kořeny pomocí:
$$ x_{1, 2} = \frac{-b \pm \sqrt{D}}{2a} $$</p>
<p><upr-parabola></upr-parabola></p>
<h1><a class="header" href="#pole-1" id="pole-1">Pole</a></h1>
<h2><a class="header" href="#naplnění-pole" id="naplnění-pole">Naplnění pole</a></h2>
<p>Vytvořte funkci <code>fill_array</code>, která naplní pole <code>array</code> čísly zvětšujícími se po <code>increment</code> a
začínajícími od <code>start</code>. </p>
<pre><code class="language-c">void fill_array(int* array, int len, int start, int increment);
</code></pre>
<p><upr-array-fill></upr-array-fill></p>
<h2><a class="header" href="#počítání-výskytů-čísla" id="počítání-výskytů-čísla">Počítání výskytů čísla</a></h2>
<p>Vytvořte funkci <code>num_count</code>, která spočítá a vrátí počet výskytů čísla <code>num</code> v poli <code>array</code>.</p>
<pre><code class="language-c">int num_count(int* array, int len, int num);
</code></pre>
<p><upr-array-interval array="[10, 2, 4, 3, 4, 8, 9, 4]" from="4" to="4"></upr-array-interval></p>
<h2><a class="header" href="#počítání-čísel-v-intervalu" id="počítání-čísel-v-intervalu">Počítání čísel v intervalu</a></h2>
<p>Vytvořte funkci <code>in_interval</code>, která spočítá počet čísel z uzavřeného intervalu <code>[from, to]</code> v poli
<code>array</code>.</p>
<pre><code class="language-c">int in_interval(int* array, int len, int from, int to);
</code></pre>
<p><upr-array-interval array="[10, 2, 4, 3, 4, 8, 9, 4]" from="2" to="5"></upr-array-interval></p>
<h2><a class="header" href="#průměrná-hodnota" id="průměrná-hodnota">Průměrná hodnota</a></h2>
<p>Vytvořte funkci <code>average</code>, která spočítá průměr čísel v poli <code>array</code>.</p>
<pre><code class="language-c">double average(int* array, int len);
</code></pre>
<p>Při dělení nezapomeňte přetypovat alespoň jeden operand na typ <code>double</code>, aby nedošlo k
celočíselnému dělení.</p>
<h2><a class="header" href="#minimální-hodnota-v-poli" id="minimální-hodnota-v-poli">Minimální hodnota v poli</a></h2>
<p>Vytvořte funkci, která v poli <code>array</code> nalezne minimální hodnotu.</p>
<pre><code class="language-c">int array_min(int *array, int len);
</code></pre>
<p><upr-array-min array="[3, 5, 2, 8, 7, 1, 3]"></upr-array-min></p>
<p>Následně funkci upravte, aby funkce vrátila pomocí ukazatele první index s minimální hodnotou.</p>
<pre><code class="language-c">int array_min(int *array, int len, int *min_index);
</code></pre>
<h2><a class="header" href="#minimální-a-maximální-hodnota" id="minimální-a-maximální-hodnota">Minimální a maximální hodnota</a></h2>
<p>Předchozí funkci upravte, aby hledala minimum a maximum zároveň.
Nalezené extrémy vraťte pomocí ukazatelů <code>min</code> a <code>max</code>.</p>
<pre><code class="language-c">void min_max(int* array, int len, int *min, int *max);
</code></pre>
<p>Ve funkci si nejprve nastavte index minimální a maximální hodnoty na nultý prvek.
Parametr <code>min</code> je ukazatel, a je tedy nutné přistupovat k jeho hodnotě pomoci dereference - <code>*min</code>,
protože výraz <code>min</code> obsahuje pouze adresu, kde je minimální index uložen. Následně projděte
pole a pokud bude hodnota aktuálního prvku menší než hodnota prvku na dosud nalezeném indexu,
nastavte hodnotu minimálního indexu na aktuální index. Stejný postup aplikujte i pro nalezení
maximálního prvku (stačí udělat jeden průchod polem).</p>
<h2><a class="header" href="#obrácení-pole" id="obrácení-pole">Obrácení pole</a></h2>
<p>Vytvořte funkci <code>array_reverse</code>, která obrátí prvky v poli.</p>
<pre><code class="language-c">void array_reverse(int* array, int len);
</code></pre>
<p>Pole projděte pomoci cyklu do jeho půlky a vždy prohazujte prvky z obou konců.</p>
<p><upr-array-reverse array="[10, 20, 30, 40, 50, 60]"></upr-array-reverse></p>
<p>Přehození dvou prvků nemůžete udělat najednou. Uložte si například prvek z levého konce do proměnné
a následně do tohoto prvku zapište hodnotu z pravého konce. Poté hodnotu z proměnné uložte do pravého
konce. Alternativně také můžete využít dříve naimplementovanou funkci <code>void swap(int* a, int* b)</code>.</p>
<h2><a class="header" href="#skalární-součin" id="skalární-součin">Skalární součin</a></h2>
<p>Vytvořte funkci <code>dot</code>, která spočítá
<a href="https://cs.wikipedia.org/wiki/Skal%C3%A1rn%C3%AD_sou%C4%8Din">skalární součin</a>.</p>
<pre><code class="language-c">int dot(int* a, int* b, int len);
</code></pre>
<h2><a class="header" href="#načtení-dynamického-počtu-hodnot" id="načtení-dynamického-počtu-hodnot">Načtení dynamického počtu hodnot</a></h2>
<p>Načtěte od uživatele číslo <code>n</code>. Poté naalokujte paměť o velikosti <code>n</code> <code>int</code>ů a 
načtěte ze vstupu <code>n</code> čísel, které postupně uložte do vytvořeného pole. Vypište součet načteného
pole.</p>
<h2><a class="header" href="#counting-sort" id="counting-sort">Counting sort</a></h2>
<p>Vygenerujte pole 10 000 000 čísel z intervalu \( \langle 1000, 2000 \rangle \).
Pomocí algoritmu counting sort seřaďte čísla v poli od nejmenšího po největší.</p>
<ol>
<li>vytvořte pole počítadel pro všechny možné hodnoty v poli</li>
<li>vynulujte počitadla na 0</li>
<li>sekvenčně projděte pole čísel a inkrementujte odpovídající počítadlo</li>
<li>projděte pole počítadel a tiskněte hodnotu tolikrát, kolik je hodnota počítadla</li>
</ol>
<p><upr-counting-sort></upr-counting-sort></p>
<h2><a class="header" href="#třízení" id="třízení">Třízení</a></h2>
<p>Naimplementujte funkci, která setřídí pole. Můžete použít například algoritmus
<a href="https://en.wikipedia.org/wiki/Bubble_sort">bubble sort</a>.</p>
<h1><a class="header" href="#dvourozměrné-pole" id="dvourozměrné-pole">Dvourozměrné pole</a></h1>
<h2><a class="header" href="#vytisknutí-matice" id="vytisknutí-matice">Vytisknutí matice</a></h2>
<p>Vytvořte funkci <code>print_matrix</code>, která vypíše obrázek reprezentovaný
<a href="ulohy/../c/pole/vicerozmerne_pole.html">dvourozměrným</a> (2D) polem.</p>
<pre><code class="language-c">void print_matrix(int* matrix, int rows, int cols);
</code></pre>
<p>Projděte matici po řádcích a sloupcích a vypište jednotlivé prvky.</p>
<h2><a class="header" href="#vykreslení-hvězdice" id="vykreslení-hvězdice">Vykreslení hvězdice</a></h2>
<p>Vytvořte funkci <code>draw_star</code>, která do 2D matice vykreslí hvězdici.</p>
<pre><code class="language-c">void draw_star(int* matrix, int rows, int cols);
</code></pre>
<pre><code>X    X    X
 X   X   X 
  X  X  X  
   X X X   
    XXX    
XXXXXXXXXXX
    XXX    
   X X X   
  X  X  X  
 X   X   X 
X    X    X
</code></pre>
<p>Hvězdici můžete vykreslit do pole pomocí jediného cyklu.
Zkuste vytvořit funkce na vykreslení dalších tvarů (čára, čtverec, kružnice, trojúhelník, ...).</p>
<h2><a class="header" href="#násobení-matice-skalárem" id="násobení-matice-skalárem">Násobení matice skalárem</a></h2>
<p>Vytvořte funkci <code>matrix_mul_scalar</code>, která vynásobí každý prvek matice číslem <code>k</code>. </p>
<pre><code class="language-c">void matrix_mul_scalar(int* matrix, int rows, int cols, int k);
</code></pre>
<p><img src="ulohy/../static/img/matrix_scalar.svg" alt="Násobení matice skalárem" /></p>
<h2><a class="header" href="#násobení-matice-vektorem" id="násobení-matice-vektorem">Násobení matice vektorem</a></h2>
<p>Vytvořte funkci <code>matrix_mul_vector</code>, která vynásobí matici vektorem.</p>
<pre><code class="language-c">int* matrix_mul_vec(int* matrix, int rows, int cols, int *vec, int len);
</code></pre>
<!--
![Násobení matice vektorem](../static/img/matrix_vector.svg)
-->
<p><upr-matrix-mul a="[[1, 2, 3], [4, 5, 6], [7, 8, 9]]" b="[[10], [20], [30]]"></upr-matrix-mul></p>
<h2><a class="header" href="#násobení-matice-maticí" id="násobení-matice-maticí">Násobení matice maticí</a></h2>
<p>Vytvořte funkci pro násobení matice \( A \) o rozměrech \( rows_1 \times cols_1 \) s druhou matici \( B \) o rozměrech \( rows_2 \times cols_2 \).
Funkce vrátí <code>NULL</code> v případě, že matice nepůjdou vynásobit např. v případě, že počet řádků první matice není shodný s počtem sloupců druhé matice.
Výslednou matici o rozměrech \( rows_1 \times cols_1 \) alokujte dynamicky.</p>
<upr-container>
  <upr-matrix-mul a="[[1, 2, 3], [4, 5, 6]]" b="[[10, 20], [30, 40], [50, 60]]"></upr-matrix-mul>
  <!--
  <upr-arrow dst="table" dst-anchor="south" src-anchor="north">a</upr-arrow>
  <upr-arrow dst="table:nth-of-type(2)" dst-anchor="south" src-anchor="north">b</upr-arrow>
  <upr-arrow dst="table:nth-of-type(3)" dst-anchor="south" src-anchor="north">result</upr-arrow>
  -->
</upr-container>
<h1><a class="header" href="#Řetězce-1" id="Řetězce-1">Řetězce</a></h1>
<h3><a class="header" href="#převod-na-velké-znaky" id="převod-na-velké-znaky">Převod na velké znaky</a></h3>
<p>Vytvořte funkci, která převede textový řetězec na velké znaky.</p>
<pre><code class="language-c">char str[] = { &quot;hello&quot; };
uppercase(str);
// str by se zde měl rovnat &quot;HELLO&quot;
</code></pre>
<h3><a class="header" href="#nahrazení-znaku" id="nahrazení-znaku">Nahrazení znaku</a></h3>
<p>Vytvořte funkci, která v řetězci nahradí všechny výskyty daného znaku za znak <code>'X'</code>.</p>
<pre><code class="language-c">char str[] = { &quot;hello&quot; };
replace(str, 'l');
// str by se zde měl rovnat &quot;heXXo&quot;
</code></pre>
<h3><a class="header" href="#Šifrování-řetězce" id="Šifrování-řetězce">Šifrování řetězce</a></h3>
<p>Vytvořte funkci, která &quot;zašifruje&quot; řetězec tím, že ke každému znaku přičte číslo (klíč).
K ní vytvořte funkci, která řetězec opět odšifruje (odečtením klíče).</p>
<pre><code class="language-c">char str[] = { &quot;abc&quot; };
encrypt(str, 1);
// str by se zde měl rovnat &quot;bcd&quot;
decrypt(str, 1);
// str by se zde měl opět rovnat &quot;abc&quot;
</code></pre>
<h3><a class="header" href="#délka-řetězce" id="délka-řetězce">Délka řetězce</a></h3>
<p>Vytvořte funkci <code>my_strlen</code>, která vypočte délku řetězce (obdoba funkce
<a href="https://devdocs.io/c/string/byte/strlen"><code>strlen</code></a> ze standardní knihovny <em>C</em>).</p>
<pre><code class="language-c">my_strlen(&quot;&quot;);          // 0
my_strlen(&quot;abc&quot;);       // 3
my_strlen(&quot;abc 0 asd&quot;); // 9
</code></pre>
<h3><a class="header" href="#porovnávání-řetězců" id="porovnávání-řetězců">Porovnávání řetězců</a></h3>
<p>Vytvořte funkci, která vrátí <code>true</code>, pokud jsou dva předané řetězce stejné.
Vytvořte i variantu funkce, která porovnává řetězce bez ohledu na velikosti znaků.</p>
<pre><code class="language-c">strequal(&quot;ahoj&quot;, &quot;ahoj&quot;);               // 1
strequal(&quot;ahoj&quot;, &quot;aho&quot;);                // 0
strequal_ignorecase(&quot;ahoj&quot;, &quot;AhOj&quot;);    // 1
</code></pre>
<h3><a class="header" href="#palindrom" id="palindrom">Palindrom</a></h3>
<p>Vytvořte funkci, která vrátí <code>true</code>, pokud je předaný řetězec
<a href="https://cs.wikipedia.org/wiki/Palindrom">palindrom</a> (slovo, které se čte stejně zepředu i pozpátku).</p>
<p><img src="ulohy/../static/img/palindrom.svg" alt="palindrom" /></p>
<h3><a class="header" href="#histogram" id="histogram">Histogram</a></h3>
<p>Vytvořte funkci, která vypočte <a href="https://cs.wikipedia.org/wiki/Histogram">histogram</a> znaků v řetězci.
Histogram je pole, ve kterém prvek na pozici <code>x</code> udává, kolikrát se znak <code>x</code> vyskytoval v daném řetězci.</p>
<pre><code class="language-c">int histogram[255] = {};
calc_histogram(&quot;aabacc&quot;, histogram);
// histogram['a'] == 3
// histogram['b'] == 1
// histogram['c'] == 2
// histogram['d'] == 0
</code></pre>
<h3><a class="header" href="#převod-textu-na-číslo" id="převod-textu-na-číslo">Převod textu na číslo</a></h3>
<p>Vytvořte funkci, která převede řetězec na číslo v desítkové soustavě. Pokud číslo nelze převést,
vraťte hodnotu <code>0</code>.</p>
<pre><code class="language-c">convert(&quot;5&quot;);   // vrátí int s hodnotou 5
convert(&quot;123&quot;); // vrátí int s hodnotou 123
</code></pre>
<p>Zkuste přidat i podporu pro záporná čísla.</p>
<h1><a class="header" href="#různé-1" id="různé-1">Různé</a></h1>
<h3><a class="header" href="#hádací-hra-guessing-game" id="hádací-hra-guessing-game">Hádací hra (<em>guessing game</em>)</a></h3>
<p>Vygenerujte <a href="ulohy/../ruzne/nahodna_cisla.html">náhodné číslo</a>. Poté nechte uživatele hádat, jaké číslo
program vygeneroval. Po každém tipu uživateli dejte vědět, jestli uhádl správně nebo jestli jeho
tip byl vyšší či nižší než číslo, které hádá.</p>
<h3><a class="header" href="#odrážející-se-kulička-v-terminálu" id="odrážející-se-kulička-v-terminálu">Odrážející se kulička v terminálu</a></h3>
<p>Vykreslujte do terminálu obdélník spolu s pohybující se kuličkou. Jakmile kulička narazí do stěny
čtverce, zvyšte počítadlo nárazů pro danou zeď. Dodržujte princip
<a href="https://cs.wikipedia.org/wiki/Odraz_vln%C4%9Bn%C3%AD">zákonu odrazu</a>.</p>
<details>
<summary>Přibližný postup řešení</summary>
Kuličku reprezentujte dvěmi proměnými (pozice X a Y). Opakovaně provádějte následující akce:
<ul>
<li>Posuňte kuličku ve směru jejího pohybu.</li>
<li>Pokud kulička narazí do stěny, změňte směr jejího pohybu.</li>
<li>Vyčistěte terminál, aby zmizelo herní pole z minulé iterace. Lze to provést více způsoby:
<ul>
<li>Vytiskněte velké množství prázdných řádků.</li>
<li>Vytiskněte text <code>&quot;\e[1;1H\e[2J&quot;</code>, který terminál bude interpretovat jako vyčistění obrazovky.</li>
</ul>
</li>
<li>Vykreslete kuličku a obdélník.</li>
<li>Uspěte na chvíli program, abyste mohli pozorovat změněný stav hry. Můžete použít například funkci
<code>usleep</code>: <code>usleep(100 * 1000)</code>.</li>
</ul>
</details>
<p>Výsledek by měl vypadat zhruba takto:</p>
<p><img src="ulohy/../static/video/ball_terminal.gif" alt="Odrážející se kulička v terminálu" /></p>
<h3><a class="header" href="#kalkulačka" id="kalkulačka">Kalkulačka</a></h3>
<p>Načtěte ze vstupu programu nebo z <a href="ulohy/../ruzne/funkce_main.html">parametrů příkazového řádku</a> matematický
výraz, který bude obsahovat celá čísla a operátory <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code> a vypište výsledek tohoto
výrazu.</p>
<ul>
<li><em>Varianta 1</em>: Použijte klasický zápis v <a href="https://cs.wikipedia.org/wiki/Infixov%C3%A1_notace">infixové notaci</a>.
Nemusíte řešit prioritu operátorů.</li>
<li><em>Varianta 2</em>: Přidejte podporu pro prioritu operátorů a závorky <code>(</code>, <code>)</code>. Použijte algoritmus
<a href="https://cs.wikipedia.org/wiki/Algoritmus_shunting-yard">Shunting yard</a>.</li>
<li><em>Varianta 3</em>: Použijte <a href="https://cs.wikipedia.org/wiki/Postfixov%C3%A1_notace">postfixovou notaci</a>.
Zde bude fungovat priorita operátorů a &quot;závorkování&quot; bez nutnosti složitého načítání vstupu z
varianty 2.</li>
</ul>
<h1><a class="header" href="#Časté-chyby" id="Časté-chyby">Časté chyby</a></h1>
<p>V této sekci najdete často se vyskytující chyby, na které můžete narazit, spolu s návodem, jak je
vyřešit.</p>
<h3><a class="header" href="#záměna--a-" id="záměna--a-">Záměna <code>=</code> a <code>==</code></a></h3>
<ul>
<li>Operátor <code>=</code> <a href="caste_chyby/../c/promenne/promenne.html#z%C3%A1pis">přiřazuje</a> hodnotu do svého levého operandu a vyhodnotí se s
hodnotou pravého operandu.</li>
<li>Operátor <code>==</code> <a href="caste_chyby/../c/datove_typy/pravdivostni_typy.html#porovn%C3%A1v%C3%A1n%C3%AD-hodnot">porovnává</a> dvě hodnoty a vyhodnotí
se jako pravdivostní hodnota <code>bool</code>.</li>
</ul>
<p>Je důležité tyto operátory nezaměňovat! Oba dva operátory jsou výrazy, takže se v něco vyhodnotí a
i když je použijete špatně, tak často nedostanete chybovou hlášku, což jejich záměnu dělá ještě
nebezpečnější.</p>
<pre><code class="language-c">int a = 0;
a = 5; // nastaví hodnotu `5` do proměnné `a`
a == 5; // porovná `a` s hodnotou `5`, vrátí hodnotu `true`, ale nic se neprovede

// podmínka se provede, pokud se `a` rovná `5`
if (a == 5) {}

// podmínka se provede vždy, výraz `a = 5` se vyhodnotí na `5` (`true`)
// zároveň při provedení podmínky se přepíše hodnota proměnné `a` na `5`
if (a = 5) {}
</code></pre>
<h3><a class="header" href="#záměna--s--nebo--s-" id="záměna--s--nebo--s-">Záměna <code>&amp;</code> s <code>&amp;&amp;</code> nebo <code>|</code> s <code>||</code></a></h3>
<ul>
<li>Operátor <code>&amp;</code> provádí <a href="caste_chyby/../c/datove_typy/celociselne_typy.html#tabulka-aritmetick%C3%BDch-oper%C3%A1tor%C5%AF">bitový součin</a>,
očekává jako operandy celá čísla (např. <code>int</code>) a vrací celé číslo.</li>
<li>Operátor <code>&amp;&amp;</code> provádí <a href="caste_chyby/../c/datove_typy/pravdivostni_typy.html#tabulka-logick%C3%BDch-oper%C3%A1tor%C5%AF">logický součin</a>,
očekává jako operandy pravdivostní hodnoty (<code>bool</code>) a vrací pravdivostní hodnotu.</li>
</ul>
<p>Je důležité tyto operátory nezaměňovat. Jelikož <code>bool</code> lze implicitně převést na celé číslo a naopak,
záměna těchto operátorů opět typicky nepovede k chybě při překladu, nicméně program nejspíše při
jejich záměně nebude fungovat tak, jak má. Operátor <code>&amp;</code> má zároveň větší
<a href="https://en.cppreference.com/w/c/language/operator_precedence">přednost</a> než <code>&amp;&amp;</code>, takže se výraz
s tímto operátorem může vyhodnotit jinak, než očekáváte. Obdobná situace platí i u dvojice
operátorů <code>|</code> (bitový součet) a <code>||</code> (logický součet).</p>
<pre><code class="language-c">int a = 3;
a &amp; 4; // `0` 
a &amp;&amp; 4; // `true`

// stejné jako a &gt; (5 &amp; a) &lt; 6
if (a &gt; 5 &amp; a &lt; 6) {}
</code></pre>
<h3><a class="header" href="#středník-za-for-while-nebo-if" id="středník-za-for-while-nebo-if">Středník za <code>for</code>, <code>while</code> nebo <code>if</code></a></h3>
<p>Příkazy <code>for</code>, <code>while</code> nebo <code>if</code> za svou uzavírací závorkou <code>)</code> očekávají jeden příkaz:</p>
<pre><code class="language-c">if (a &gt; b) printf(&quot;%d&quot;, a);
</code></pre>
<p>nebo blok s příkazy:</p>
<pre><code class="language-c">if (a &gt; b) {
    printf(&quot;%d&quot;, a);
    ...
}
</code></pre>
<p>Pokud však za závorku dáte rovnou středník (<code>;</code>), tak překladač to pochopí jako prázdný příkaz, který nic nedělá.</p>
<p>V následující ukázce se provede 10× prázdné tělo cyklu <code>for</code> a následně se jednou vypíše řetězec <code>&quot;Hello\n&quot;</code>.</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
  for(int i = 0; i &lt; 10; i++); {
    printf(&quot;Hello\n&quot;);
  }
}
</code></pre>
<p>Zde opět středník za <code>if</code> reprezentuje prázdný příkaz, takže blok kódu s příkazem <code>printf</code> se provede vždy, i když je tato podmínka nesplnitelná.</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
  if(0); {
    printf(&quot;Hello\n&quot;);
  }
}
</code></pre>
<p>Je to ekvivalentní, jako byste napsali</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
  if (0) { /* zde není co provést */ }

  // tento blok se provede vždy
  {
      printf(&quot;Hello\n&quot;);
  }
}
</code></pre>
<h3><a class="header" href="#Špatné-volání-funkce" id="Špatné-volání-funkce">Špatné volání funkce</a></h3>
<p>Abychom zavolali funkci (tj. řekli počítači, aby začal vykonávat kód, který v ní je), napíšeme
název funkce, závorky a do nich případně seznam argumentů. Při volání funkce už nezadáváme její
návratový typ, ten se udává pouze u definice funkce.</p>
<pre><code class="language-c">int secti(int a, int b) {
    return a + b;
}
int main() {
    secti(1, 2);        // správně
    int secti(1, 2);    // špatně

    return 0;
}
</code></pre>
<h3><a class="header" href="#záměna--s" id="záměna--s">Záměna <code>'</code> s <code>&quot;</code></a></h3>
<ul>
<li>Apostrof (<code>'</code>) slouží k zapsání (jednoho) <a href="caste_chyby/../c/text/znaky.html">znaku</a>. Neukládejte do něj více znaků či celý text.</li>
<li>Uvozovky (<code>&quot;</code>) slouží k zapsání <a href="caste_chyby/../c/text/text.html">řetězce</a>, tj. pole znaků ukončeného hodnotou <code>0</code>.</li>
</ul>
<pre><code class="language-c">char a = 'asd'; // špatně, více znaků v ''
char a = &quot;asd&quot;; // špatně, ukládáme řetězec do typu `char` (mělo by být `const char*`)

char a = 'x';               // správně
const char* str = &quot;hello&quot;;  // správně
</code></pre>
<h3><a class="header" href="#Špatná-práce-s-ukazatelem" id="Špatná-práce-s-ukazatelem">Špatná práce s ukazatelem</a></h3>
<p><a href="caste_chyby/../c/prace_s_pameti/ukazatele.html">Ukazatele</a> jsou čísla, která interpretujeme jako
<a href="caste_chyby/../uvod/pamet.html">adresy v paměti</a>. Můžete s nimi sice provádět některé aritmetické operace
(například sčítání či odčítání), nicméně v takovém případě provádíte výpočet s adresou, ne s
hodnotou, která je na dané adrese uložena.</p>
<p>Například v této funkci, která by měla přičíst hodnotu <code>x</code> k paměti na adrese <code>ptr</code>, musíte
nejprve přistoupit k hodnotě na dané adrese (<code>*ptr</code>), a až k této hodnotě pak přičíst <code>x</code>:</p>
<pre><code class="language-c">void pricti_hodnotu(int* ptr, int x) {
    ptr += x;   // špatně, přičteme `x` k adrese `ptr`
    *ptr += x;  // správně, přičteme `x` k hodnotě na adrese `ptr` 
}
</code></pre>
<h3><a class="header" href="#vytváření-spousty-proměnných-místo-použití-pole" id="vytváření-spousty-proměnných-místo-použití-pole">Vytváření spousty proměnných místo použití pole</a></h3>
<p>Pokud potřebujete jednotně pracovat s větším počtem hodnot v paměti, použijte <a href="caste_chyby/../c/pole/pole.html">pole</a>.
Signálem, že jste měli použít pole, může být to, že máte ve funkci spoustu proměnných a pro rozlišení
každé proměnné musíte přidat nový řádek kódu:</p>
<pre><code class="language-c">for (a0 = 0, a1 = 0, a2 = 0, a3 = 0, a4 = 0, a5 = 0; i &lt; pocet; i++)
{
    if (hodnota == 1)
    {
        a0++;
    }
    else if (hodnota == 2)
    {
        a1++;
    }
    else if (hodnota == 3)
    {
        a2++;
    }
    ...
}
</code></pre>
<h1><a class="header" href="#paměťové-chyby" id="paměťové-chyby">Paměťové chyby</a></h1>
<p>V <em>C</em> lze s pamětí programu pracovat <a href="caste_chyby/../c/prace_s_pameti/dynamicka_pamet.html">manuálně</a>, což velmi často vede
k různým paměťovým chybám, které můžou způsobit špatné chování či pád programu. Jsou také
nejčastějším zdrojem různých
<a href="https://owasp.org/www-community/attacks/Buffer_overflow_attack">zranitelností</a>, které umožňují
útočníkům převzít kontrolu nad programem nebo celým počítačem.</p>
<p>Pro částečnou prevenci paměťových chyb silně doporučujeme při vývoji <em>C</em> programů používat
nástroj <a href="caste_chyby/../prostredi/ladeni.html#address-sanitizer">Address sanitizer</a>.</p>
<h2><a class="header" href="#stack-overflow" id="stack-overflow">Stack overflow</a></h2>
<p>Pokud bychom vytvořili v zásobníkovém rámci moc proměnných, proměnné, které jsou
<a href="caste_chyby/../c/pole/pole.html">moc velké</a>, anebo bychom měli v jednu chvíli aktivních moc zásobníkových rámců
(například při moc hluboké <a href="caste_chyby/../c/funkce/rekurze.html">rekurzi</a>), tak může dojít paměť určená pro zásobník.
Tato situce se nazývá <strong>přetečení zásobníku</strong> (<em>stack overflow</em>):</p>
<pre><code class="language-c">int funkce(int x) {
    return funkce(x + 1);
}
int main() {
    funkce(0);
    return 0;
}
</code></pre>
<h2><a class="header" href="#segmentation-fault" id="segmentation-fault">Segmentation fault</a></h2>
<p>Tato chyba je způsobena pokusem o zapsání nebo čtení neplatné adresy v paměti. K této chybě často
dochází zejména při těchto situacích:</p>
<ul>
<li>
<p>Zapísujeme nebo čteme z paměti pole mimo jeho rozsah (tj. &quot;před&quot; nebo &quot;za&quot; pamětí pole).
Tato situace se nazývá <a href="https://owasp.org/www-community/vulnerabilities/Buffer_Overflow"><em>buffer overflow</em></a>.
Tato chyba už způsobila nespočet bezpečnostních chyb v různých softwarech.</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int main() {
    int* p = (int*) malloc(sizeof(int));
    p[1] = 5;
    return 0;
}
</code></pre>
</li>
<li>
<p>Pokoušíme se přečíst hodnotu na adrese 0 (<code>NULL</code>), která je používána pro inicializaci
ukazatelů. Tato situace se nazývá
<a href="https://owasp.org/www-community/vulnerabilities/Null_Dereference"><em>null pointer dereference</em></a>.</p>
<pre><code class="language-c">int main() {
    int* p = (void*) 0;
    int a = *p;

    return 0;
}
</code></pre>
</li>
<li>
<p>Snažíme se přistoupit k paměti, která již byla <a href="caste_chyby/../c/prace_s_pameti/dynamicka_pamet.html#uvoln%C4%9Bn%C3%AD-pam%C4%9Bti">uvolněna</a>.
Tato situace se nazývá
<a href="https://owasp.org/www-community/vulnerabilities/Using_freed_memory"><em>use-after-free</em></a>.</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int main() {
    int* p = (int*) malloc(sizeof(int));
    free(p);

    *p = 1;
    return 0;
}
</code></pre>
<p>Přístup k již uvolněné paměti může nastat i bez použití
<a href="caste_chyby/../c/prace_s_pameti/dynamicka_pamet.html">dynamické paměti</a>. Například tento kód není správně:</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int* get_pointer(int x) {
    int y = x + 1;
    return &amp;y;
}

int main() {
    int* p = get_pointer(1);
    *p = 1;
    return 0;
}
</code></pre>
<p>protože jakmile vykonávání funkce <code>get_pointer</code> skončí, tak se
<a href="caste_chyby/../c/prace_s_pameti/automaticka_pamet.html">uvolní</a> paměť jejich lokálních proměnných. Adresa
uložená v <code>p</code> tak obsahuje nevalidní paměť a je chybou k ní přistupovat (ať už číst, tak
zapisovat).</p>
</li>
<li>
<p>Snažíme se uvolnit pamět, která již byla uvolněna. Tato situace se nazývá
<a href="https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory"><em>double free</em></a>.</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int main() {
    int* p = (int*) malloc(sizeof(int));
    free(p);
    free(p);
    return 0;
}
</code></pre>
</li>
</ul>
<h2><a class="header" href="#memory-leak" id="memory-leak">Memory leak</a></h2>
<p>Pokud (opakovaně) alokujeme <a href="caste_chyby/../c/prace_s_pameti/dynamicka_pamet.html">dynamickou paměť</a> a neuvolňujeme ji, tak
dochází k tzv. <a href="https://owasp.org/www-community/vulnerabilities/Memory_leak"><em>memory leaku</em></a>
(úniku paměti). Pokud paměť programu stále roste a není nijak uvolňována, tak postupem času počítači
nutně dojde paměť a program tak bude násilně ukončen.</p>
<pre><code class="language-c">void leak() {
    // adresa alokované paměti je zahozena, nelze ji tedy uvolnit
    malloc(sizeof(int));
}
</code></pre>
<p>Tato chyba je celkem zákeřná, protože pokud paměť roste pomalu, tak může trvat dost dlouho, než se
projeví. K nalezení chyby doporučujeme použít Address sanitizer, který na konci programu zkontroluje,
jestli všechny dynamicky naalokované bloky byly korektně uvolněny.</p>
<blockquote>
<p>Nemusíte se však bát, že by neuvolněná paměť ve vašem programu nějak narušovala chod operačního
systému. I když paměť manuálně neuvolníte, tak moderní operační systémy veškerou paměť vašeho
spuštěného programu uvolní, jakmile program skončí. Dokud však program běží, tak bude neuvolněná
paměť zabírat místo, což může způsobovat problémy.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-177556287-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="theme/mode-c_cpp.min.js"></script>
        
        <script type="text/javascript" src="src/wasm/xterm.min.js"></script>
        
        <script type="text/javascript" src="src/wasm/fit.min.js"></script>
        
        <script type="text/javascript" src="src/wasm/shared.js"></script>
        
        <script type="text/javascript" src="src/wasm/web.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
