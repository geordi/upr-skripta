<!DOCTYPE HTML>
<html lang="cs" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Úvod do programování</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        <link rel="stylesheet" href="wasm/xterm.min.css" />
<script src="wasm/xterm.min.js"></script>
<script src="wasm/fit.min.js"></script>
<script src="wasm/shared.js"></script>
<script src="wasm/web.js"></script>
<style>
.xterm {
  margin-top: 10px;
}
</style>
<script src="https://kelvin.cs.vsb.cz/upr/animations.js"></script>


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/css/tufte.css">
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "rust" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="uvod.html"><strong aria-hidden="true">1.</strong> Úvod</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programovani.html"><strong aria-hidden="true">1.1.</strong> Programování</a></li><li class="chapter-item expanded "><a href="programovaci_jazyky.html"><strong aria-hidden="true">1.2.</strong> Programovací jazyky</a></li><li class="chapter-item expanded "><a href="jazyk_c.html"><strong aria-hidden="true">1.3.</strong> Jazyk C</a></li><li class="chapter-item expanded "><a href="pamet.html"><strong aria-hidden="true">1.4.</strong> Paměť</a></li></ol></li><li class="chapter-item expanded "><a href="nastaveni_prostredi.html"><strong aria-hidden="true">2.</strong> Nastavení prostředí</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="editor.html"><strong aria-hidden="true">2.1.</strong> Editor</a></li><li class="chapter-item expanded "><a href="preklad_programu.html"><strong aria-hidden="true">2.2.</strong> Překlad</a></li><li class="chapter-item expanded "><a href="ladeni.html"><strong aria-hidden="true">2.3.</strong> Ladění</a></li></ol></li><li class="chapter-item expanded "><a href="c_programovani.html"><strong aria-hidden="true">3.</strong> Programování v C</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="c_syntaxe.html"><strong aria-hidden="true">3.1.</strong> Syntaxe</a></li><li class="chapter-item expanded "><a href="c_prikazy_vyrazy.html"><strong aria-hidden="true">3.2.</strong> Příkazy a výrazy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="c_promenne.html"><strong aria-hidden="true">3.2.1.</strong> Proměnné</a></li><li class="chapter-item expanded "><a href="c_datove_typy.html"><strong aria-hidden="true">3.2.2.</strong> Datové typy</a></li></ol></li><li class="chapter-item expanded "><a href="c_rizeni_toku.html"><strong aria-hidden="true">3.3.</strong> Řízení toku</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="c_podminky.html"><strong aria-hidden="true">3.3.1.</strong> Podmínky</a></li><li class="chapter-item expanded "><a href="c_cykly.html"><strong aria-hidden="true">3.3.2.</strong> Cykly</a></li></ol></li><li class="chapter-item expanded "><a href="c_funkce.html"><strong aria-hidden="true">3.4.</strong> Funkce</a></li><li class="chapter-item expanded "><a href="c_ukazatele.html"><strong aria-hidden="true">3.5.</strong> Ukazatele</a></li><li class="chapter-item expanded "><a href="c_retezce.html"><strong aria-hidden="true">3.6.</strong> Řetězce</a></li><li class="chapter-item expanded "><a href="c_pole.html"><strong aria-hidden="true">3.7.</strong> Pole</a></li><li class="chapter-item expanded "><a href="c_struktury.html"><strong aria-hidden="true">3.8.</strong> Struktury</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="c_struktury_funkce.html"><strong aria-hidden="true">3.8.1.</strong> Funkce se strukturami</a></li></ol></li><li class="chapter-item expanded "><a href="c_soubory.html"><strong aria-hidden="true">3.9.</strong> Soubory</a></li><li class="chapter-item expanded "><a href="c_modularizace.html"><strong aria-hidden="true">3.10.</strong> Modularizace</a></li><li class="chapter-item expanded "><a href="c_knihovny.html"><strong aria-hidden="true">3.11.</strong> Knihovny</a></li></ol></li><li class="chapter-item expanded "><a href="ulohy.html"><strong aria-hidden="true">4.</strong> Aplikované úlohy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tga.html"><strong aria-hidden="true">4.1.</strong> TGA</a></li><li class="chapter-item expanded "><a href="sdl.html"><strong aria-hidden="true">4.2.</strong> SDL</a></li></ol></li><li class="chapter-item expanded "><strong aria-hidden="true">5.</strong> Různé</li><li><ol class="section"><li class="chapter-item expanded "><a href="rozklad_problemu.html"><strong aria-hidden="true">5.1.</strong> Rozklad problému</a></li><li class="chapter-item expanded "><strong aria-hidden="true">5.2.</strong> Alokace paměti</li><li class="chapter-item expanded "><strong aria-hidden="true">5.3.</strong> Procesy</li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Úvod do programování</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/geordi/upr-skripta" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1>Úvod</h1>
<p>Tento text vznikl pro potřeby výuky předmětu <a href="https://github.com/geordi/upr-course">Úvod do programování</a> na FEI VŠB-TUO.
Slouží k získání přehledu o základních konceptech programovacího jazyka C.
Není však plnohodnotnou náhradou za poslechy přednášek a návštěvy cvičení a programovat vás (stejně
jako žádný jiný text) nenaučí, toho lze dosáhnout pouze opakovaným zkoušením a řešením různých úloh.
Studentům tedy silně doporučujeme, aby přednášky a cvičení navštěvovali a hlavně aby se věnovali programování
doma, alespoň několik hodin týdně.</p>
<p>V tomto textu naleznete stručný úvod o programování, překladu a ladění programů, nastavení prostředí
k editaci zdrojového kódu, a zejména popis základních konstrukcí jazyka C (proměnné, funkce, podmínky,
cykly, struktury, pole, ukazatele atd.) spolu se sadou úloh k procvičení jednotlivých témat. Pomocí
lupy vlevo nahoře můžete v textu rychle vyhledávat, pokud potřebujete najít informace o konkrétním tématu.</p>
<p>Tento text však neslouží jako kompletní průvodce jazyka C. Pro takovýto účel lze doporučit některý
knižní titul, např. Učebnice jazyka C od Pavla Herouta nebo přímo standard jazyka <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">C99</a>.</p>
<p>Jelikož je předmět UPR zaměřen na vývoj v operačním systému Linux, tak ukázky kódu a příkazů terminálu
v tomto textu předpokládají použití tohoto operačního systému, konkrétně prostředí <code>Ubuntu</code>.</p>
<p>V tomto textu najdete různé ukázky (obvykle C) kódu. Některé z nich můžete sami upravovat a dokonce
i spustit rovnou v prohlížeči pomocí trojúhelníku v pravém horním rohu.</p>
<blockquote>
<p>Tento text je psán česky, nicméně primárním jazykem programování (celosvětově) je angličtina. Přeložené pojmy,
které mají zavedené anglické názvy, budou v tomto textu uvedeny v závorce <em>kurzívou</em>. Zdrojové kódy
silně doporučujeme psát v angličtině.</p>
</blockquote>
<h1>Programování</h1>
<p>Programování je proces tvorby programu, tj. sady příkazů pro počítač, který slouží k vyřešení
nějakého konkrétního <strong>problému</strong>. Problémem se zde myslí nějaká úloha, kterou chceme vyřešit.
Takovéto úlohy obsahují nějaký (počítačem zpracovatelný) vstup:</p>
<ul>
<li>pohyb myši</li>
<li>stisk klávesy</li>
<li>zvuk z mikrofonu</li>
<li>textový soubor na disku</li>
</ul>
<p>a k nim určený výstup:</p>
<ul>
<li>vykreslení obrazce či textu na monitoru</li>
<li>zapsání dat do souboru na disku</li>
<li>odeslání informací přes síť</li>
</ul>
<p>Aby počítačový program korektně řešil nějakou úlohu, tak musí na všechny validní vstupy vrátit
správný výstup. Pokud vstup neodpovídá zadání, tak by měl program vrátit rozumnou chybovou hlášku
(a ne spadnout anebo ještě hůře pracovat s nevalidními daty). Postup pro řešení nějaké úlohy daný
jasně definovanými kroky se nazývá <strong>algoritmus</strong>. Zápisu (algoritmu) v nějakém konkrétním programovacím
jazyce se pak říká <strong>implementace</strong>.</p>
<p>Zde je příklad úloh, které se během semestru naučíte vyřešit pomocí jazyka C:</p>
<p><code>Načti soubor z disku a sečti všechna čísla, která v něm jsou.</code></p>
<p>nebo</p>
<p><code>Načti obrázek z disku, změň jeho velikost a ulož ho do jiného souboru.</code></p>
<p>Řešením podobných úloh si osvojíte základy programování a budete poté moct řešit zajímavější úlohy,
jako je například tvorba počítačové hry nebo aplikace komunikující přes internet.</p>
<h1>Programovací jazyky</h1>
<p>Z pohledu počítače je program sekvence příkazů (nazývaných <strong>instrukce</strong>), které může počítač vykonat
k vyřešení nějakého problému. Abychom mohli počítači říct, co má vykonávat, potřebujeme mu příkazy
zadat ve formě, které bude rozumět. Ač se to možná nezdá, tak počítače umí vykonávat pouze velmi
jednoduché příkazy. V podstatě umí pouze provádět aritmetické a logické operace (sečti/odečti/vynásob/vyděl)
s čísly a manipulovat (ukládat, kopírovat, přesouvat) s těmito čísly v paměti.
Veškeré složitější úkoly, jako třeba vykreslení obrázku na obrazovku, zapsání textu do dokumentu
nebo simulace světa v počítačové hře je výsledkem kombinací tisíců či milionů takovýchto jednoduchých
instrukcí.</p>
<p>Zde je ukázka jednoduchého programu, který zdvojnásobí číslo pomocí příkazů <code>MOV</code> a <code>ADD</code>: </p>
<pre><code class="language-x86asm">MOV EAX, 8
ADD EAX, EAX
</code></pre>
<p>Pokud bychom programy psali pomocí těchto jednoduchých příkazů, tak by bylo složité se v nich vyznat,
obzvláště, pokud by obsahovaly stovky, tisíce, miliony nebo dokonce miliardy takovýchto příkazů.
Ideálně bychom chtěli programy zapisovat v přirozeném jazyce (<code>Vykresli čtverec na obrazovku</code>,
<code>Zapiš text do dokumentu</code>), nicméně tomu počítače nerozumí a je velmi náročné
jej převést na správnou sekvenci příkazů pro počítač, protože jazyky, které používáme,
jsou často nejednoznačné a nemají jednotnou strukturu.</p>
<p>Jako kompromis tak vznikly <strong>programovací jazyky</strong>, které umožňují zápis programů ve formě, která je
lidem srozumitelná, ale zároveň ji lze relativně jednoduše převést na příkazy, které je schopen počítač
provést. Převodu programu zapsaného v programovacím jazyce na počítačové instrukce se říká <strong>překlad</strong>
(<em>compilation</em>) a programy, které tento překlad provádějí, se nazývají <strong>překladače</strong> (<em>compilers</em>).
Později si ukážeme, jak takovýto překladač použít k překladu kódu.</p>
<p>Zde je ukázka programu v jazyce C:</p>
<pre><code class="language-c">while (is_key_pressed(SPACE)) {
    move_up(character);
}
</code></pre>
<p>I někdo, kdo se s jazykem C nikdy nesetkal, může z tohoto programu zhruba odvodit, co asi dělá,
pokud ho přečte jako větu v angličtině. Tento program však může být převeden na stovky až tisíce
počítačových instrukcí a z takového množství příkazů už by bylo složité odvodit, k čemu je program
určen.</p>
<h1>Jazyk C</h1>
<p>Existuje nespočet programovacích jazyků, například Python, Java, C#, PHP či Javascript. Každý z nich
má své výhody a nevýhody a záleží na konkrétním problému, který je třeba vyřešit, pro zvolení
vhodného programovacího jazyka.</p>
<p>V tomto kurzu se budeme zabývat pouze programovacím jazykem <strong>C</strong>. Tento jazyk vytvořili
Dennis Ritchie a Ken Thompson v laboratořích firmy Bell v roce 1972, tedy již před
téměř 50 lety, a za tu dobu nedočkal mnoha výrazných změn.</p>
<p>I když pro něj v dnešní době asi nenaleznete mnoho pracovních nabídek a není primární
volbou pro tvorbu webových či mobilních aplikací, vyplatí se mu rozumět a umět ho používat, a to
hned z několika důvodů:</p>
<ul>
<li>Jazyk C lze použít na téměř všech existujících platformách a je tak
velmi univerzálním jazykem. Téměř veškerý existující software obsahuje kusy kódu v jazyce C. Operační systémy (Linux,
OS X, Windows, Android, iOS), prohlížeče (Chrome, Firefox, Edge), multimediální programy (Photoshop,
Powerpoint, Word, BitTorrent), hry (World of Warcraft, Quake, Doom, Call of Duty, League of Legends,
DOTA 2, Fortnite), vestavěná zařízení (mikročipy, pračky, řídící jednotky vesmírných letadel nebo aut).
Všechny tyto věci jsou buď z části anebo zcela poháněné jazykem C.</li>
<li>Je to jednoduchý jazyk, který neobsahuje velké množství funkcionalit, které lze naleznout ve většině
modernějších jazyků. Díky tomu se dá naučit za jeden semestr.</li>
<li>Jeho úroveň abstrakce není o mnoho výše než základní počítačové instrukce. Při výuce C tak lze zároveň
pochopit, jak funguje počítač a operační systém. Díky tomu lze také při správném zacházení psát velmi
efektivní programy (to ale nicméně není obsahem tohoto kurzu). </li>
<li><strong>Syntaxe</strong> (způsob zápisu) jazyka C ovlivnila velké množství jazyků, které vznikly po něm. Jakmile se
ji naučíte, tak budete schopni rozumět syntaxi většiny současných nejpoužívanějších jazyků (C++, C#,
Java, Kotlin, Javascript, PHP, Rust, ...). </li>
</ul>
<p>Jazyk C má samozřejmě také řadu nevýhod. Vzhledem k jeho stáří a omezené sadě funkcionalit je často
značně pracnější a zdlouhavější pomocí něho dosáhnout stejného výsledku než u modernějších programovacích
jazyků. Nevede také programátory za ručičku – při psaní programu v jazyce C je velmi jednoduché udělat
chybu, která může způsobit v lepším případě pád programu, v horším případě může běžící program poškodit
tak, že začne vydávat chybný výstup nebo se začně chovat nepředvídatelně.</p>
<p>Tyto chyby se můžou projevit jen někdy, nebo jenom na určité kombinaci hardwaru či operačního systému,
a programátor na ně není často nijak upozorněn a musí je najít ručně zkoumáním
zdrojového kódu. Podobný typ chyb je také nejčastějším zdrojem bezpečnostních děr ve všech možných softwarech,
které (jak už víme) téměř vždy obsahují alespoň část kódu napsaného v &quot;Céčku&quot;.</p>
<p>Zde je vybraný seznam populárních programů napsaných v jazyce C, které jsou <strong>open-source</strong>, takže
si jejich zdrojový kód můžete prohlédnout a v případě potřeby i modifikovat:</p>
<ul>
<li><a href="https://github.com/torvalds/linux">Linux</a> (operační systém)</li>
<li><a href="https://github.com/id-Software/Quake-III-Arena">Quake III</a> (počítačová hra)</li>
<li><a href="https://github.com/git/git">git</a> (verzovací systém)</li>
<li><a href="https://github.com/php/php-src">PHP</a> (překladač/interpret jazyka PHP)</li>
<li><a href="https://github.com/obsproject/obs-studio">OBS Studio</a> (streamovací software)</li>
</ul>
<h1>Paměť</h1>
<p>Počítače si potřebují ukládat (mezi)výsledky výpočtů do paměti, aby je později mohly opět
načíst a pracovat s nimi. Je mnoho typů paměti, s kterými lze pracovat, nejběžněji se setkáme
s tzv. operační pamětí (<strong>RAM</strong>). RAM znamená Random-access Memory, tedy paměť s náhodným přístupem.
To znamená, že počítač může do paměti šahat v libovolném pořadí a na libovolném místě, kde je to potřeba.</p>
<p>Počítačová paměť uchovává informace v buňkách, které obsahují jedno číslo, které může obsahovat
256 různých hodnot. To vychází z toho, že informace je reprezentována <strong>bity</strong>, jednotkou informací,
která může nabývat pouze dvě hodnoty - pravda (1, <em>true</em>) nebo nepravda (0, <em>false</em>). Každá buňka
paměti obsahuje jeden <strong>byte</strong>, neboli 8 bitů. Pracuje se zde s dvojkovou (binární) soustavou, pokud
tedy máme k dispozici <em>n</em> bitů, tak pomocí nich můžeme reprezentovat \( 2^n \) hodnot. Např. s dvěma
bity můžeme reprezentovat 4 různé hodnoty (00, 01, 10, 11). Více o binární soustavě a bytech se dozvíte
v předmětu <a href="https://edison.sso.vsb.cz/cz.vsb.edison.edu.study.prepare.web/SubjectVersion.faces?version=440-2104/01&amp;subjectBlockAssignmentId=375761&amp;studyFormId=2&amp;studyPlanId=22001&amp;locale=cs&amp;back=true">Základy číslicových systémů (ZDS)</a>.</p>
<p>I když paměť vždy obsahuje čísla v dvojkové soustavě, je důležité si uvědomit, že význam těmto číslům
přiřazujeme my, tedy programátoři a uživatelé počítače. Pokud je v paměti číslo <strong>65</strong>, tak může
reprezentovat například:</p>
<ul>
<li>počet získaných bodů studenta (interpretujeme jej jako celé nezáporné číslo)</li>
<li>písmeno <code>A</code> v nějakém dokumentu (interpretujeme jej jako znak v kódování <a href="https://www.asciitable.com/">ASCII</a>)</li>
<li>tmavě šedý pixel (interpretujeme jej jako barvu)</li>
</ul>
<p>Dále například číslo <strong>255</strong> můžeme vnímat jako celé nezáporné číslo (<em>unsigned integer</em>) <strong>255</strong>,
anebo jako celé číslo se znaménkem (<em>signed integer</em>) <strong>-1</strong> v <a href="https://cs.wikipedia.org/wiki/Dvojkov%C3%BD_dopln%C4%9Bk">dvojkovém doplňku</a>.</p>
<p>Čísla v paměti sama o sobě nemají žádný význam, záleží pouze na tom, jak je my, a obzvláště naše programy,
interpretují a jaké operace nad nimi provádějí.</p>
<h1>Nastavení prostředí</h1>
<p>Abyste mohli programovat v C, musíte si nainstalovat, nakonfigurovat a naučit se používat
sadu programů. V této kapitole je stručný popis toho, jak si nastavit <a href="editor.html">textový editor</a>
k psaní programů, <a href="preklad_programu.html">překladač</a> pro překlad z jazyka C do spustitelného souboru
a také jak <a href="ladeni.html">řešit chyby</a> při psaní programů.</p>
<h1>Vývojové prostředí</h1>
<p>Abychom mohli přeložit a spustit nějaký program, musíme ho obvykle nejprve zapsat do
jednoho nebo více souborů ve formě tzv. <strong>zdrojového kódu</strong> (<em>source code</em>). K usnadnění tohoto procesu
existují <strong>textové editory</strong> a <strong>vývojová prostředí</strong> jako například <code>MS Visual Studio</code>, <code>QtCreator</code>, <code>JetBrains CLion</code>,
<code>CodeBlocks</code>, <code>Visual Studio Code</code>, <code>vim</code>, <code>emacs</code> apod. Tyto programy usnadňují psaní kódu pomocí zvýrazňování
syntaxe, automatizace překladu, spouštění a testování programů a také správy projektů.</p>
<p>Na cvičeních UPR budeme používat editor <code>Visual Studio Code</code>, který je
<a href="https://code.visualstudio.com/">dostupný zdarma</a>. Níže je stručný návod k jeho použití. Při
programování se hodí detailně znát a efektivně využívat editor, který používáte, ale pro začátek
nám budou stačit naprosté základy.</p>
<h3>Instalace potřebných rozšíření (pomocí terminálu)</h3>
<p>VSCode podporuje programovací jazyky pomocí rozšíření, po první instalaci VSCode
tak nejprve musíme nainstalovat potřebná rozšíření pro jazyk C. V terminálu spusťte tyto příkazy:</p>
<pre><code class="language-bash">$ code --install-extension ms-vscode.cpptools
</code></pre>
<blockquote>
<p>Návod pro práci s terminálem na Linuxu můžete najít např. <a href="https://wiki.ubuntu.cz/syst%C3%A9m/p%C5%99%C3%ADkazov%C3%A1_%C5%99%C3%A1dka/termin%C3%A1l">zde</a>.
Tahák pro příkazy terminálu najdete <a href="https://github.com/geordi/upr-course/blob/master/assets/cheatsheets/linux.pdf">zde</a>.</p>
</blockquote>
<h3>Instalace potřebných rozšíření (pomocí uživatelského rozhraní)</h3>
<ol>
<li>Otevřete obrazovku rozšíření (<code>Ctrl+Shift+X</code> nebo spusťte akci <code>Install Extensions</code>)</li>
<li>Vyhledejte rozšíření C/C++ a nainstalujte ho</li>
</ol>
<h2>Ukázka nastavení projektu</h2>
<p>Jako vzorový projekt můžete použít <a href="https://github.com/geordi/upr-course/tree/master/faq/vscode-template-project">tuto</a>
šablonu.</p>
<img src="https://raw.githubusercontent.com/geordi/upr-course/master/assets/images/vsc_first_run.gif" width="90%"/>
<h3>Užitečné zkratky</h3>
<ul>
<li>Spustit program - <code>F5</code></li>
<li>Naformátovat kód - <code>Ctrl + Shift + I</code></li>
<li>Zobrazit vyhledávač akcí - <code>Ctrl + Shift + P</code></li>
</ul>
<h1>Překlad programu</h1>
<p>Pro překlad programu z jazyka C do <strong>spustitelného</strong> (<em>executable</em>) souboru
budeme používat jiný program, kterému se říká překladač.
Překladačů jazyka C existuje celá řada, my budeme využívat asi nejpoužívanější překladač pro
Linuxové systémy s názvem <a href="https://gcc.gnu.org/"><strong>GCC</strong></a> (GNU Compiler Collection). </p>
<p>Překladač <code>gcc</code>, spolu s dalšími potřebnými nástroji na Ubuntu můžete nainstalovat následujícím
příkazem:</p>
<pre><code class="language-bash">sudo apt install build-essential
</code></pre>
<h2>Překlad prvního programu</h2>
<p>Ještě než si ukážeme, jak vlastně programovací jazyk C funguje, tak zkusíme přeložit velmi jednoduchý
C program do spustitelného souboru a spustit jej.
Vytvořte soubor s názvem <code>main.c</code> a nakopírujte do něj následující C kód (později si vysvětlíme,
jak tento kód funguje):</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    printf(&quot;Hello world!\n&quot;);
}
</code></pre>
<blockquote>
<p>Tento program se nazývá <code>Hello world</code>, jelikož tento text vypíše na obrazovku.
Podobný jednoduchý program je obvykle tím prvním, co programátor v nějakém novém programovacím
jazyce vytvoří.</p>
</blockquote>
<p>Nyní otevřete terminál (<code>Ctrl + Alt + T</code> v Ubuntu) ve složce s tímto souborem, spusťte program
<code>gcc</code> a předejte mu cestu k tomuto souboru:</p>
<pre><code class="language-bash">$ gcc main.c -o program
</code></pre>
<p>Tímto příkazem řeknete &quot;Gécécéčku&quot;, aby přeložil zdrojový soubor <code>main.c</code> a uložil výsledný spustitelný
soubor do souboru <code>program</code>. Pokud byste přepínač <code>-o &lt;nazev souboru&gt;</code> nepoužili, tak se vytvoří spustitelný
soubor s názvem <code>a.out</code>. </p>
<blockquote>
<p>Na Windowsu spustitelné soubory mají obvykle příponu <code>.exe</code>, na Linuxu to však není běžnou praxí
a spustitelné soubory typicky žádnou příponu nemají.</p>
</blockquote>
<p>Pokud chcete nyní program spustit, stačí v terminálu zadat (relativní) cestu k danému spustitelnému souboru.</p>
<pre><code class="language-bash">$ ./program
Hello world!
</code></pre>
<p>Program by měl na výstup vytisknout text <code>Hello world!</code>.</p>
<h1>Ladění programů</h1>
<p>Tato sekce slouží k řešení často se vyskytujících problémů při programování v C. Pokud váš program
padá při běhu nebo se nechová tak, jak má, tak v něm nejspíše máte nějakou chybu (tzv. <strong>bug</strong>).
Proces hledání chyby, která způsobuje pád nebo špatné chování programu se pak nazývá <strong>ladění</strong> (<em>debugging</em>).</p>
<h3>Chyby při překladu programu</h3>
<p>Pokud váš program nelze přeložit a překladač vypisuje nějakou chybovou hlášku, tak máte v zápisu programu
nějakou chybu, obvykle v syntaxi, tedy zápisu kódu. Je dobré si danou chybovou hlášku pořádně přečíst,
obvykle se odkazuje na relativně přesné místo, kde máte kód špatně, a někdy dokonce i nabízí řešení,
jak problém vyřešit.</p>
<p>Při překladu můžete dostat například následující chybovou hlášku:</p>
<pre><code class="language-bash">main.c: In function ‘main’:
main.c:2:2: error: ‘a’ undeclared (first use in this function)
    2 |  a = 0;
</code></pre>
<p>Tato konkrétní chyba byla způsobena tím, že byla použitá proměnná bez její předchozí deklarace. Pokud
chybě nerozumíte, zkuste ji nejprve vygooglit, ideálně pouze část, která není konkrétně závislá na
podobě vašeho projektu. Nemá cenu googlit <code>main.c:2:2</code>, protože tento text je závislý na tom, jak jste
si pojmenovali své soubory, ostatní programátoři nejspíše mají jiné názvy souborů. V případě této chyby
by tedy bylo lepší googlit text <code>error: undeclared (first use in this function)</code>.</p>
<p>Může se stát, že překladač vypíše více chybových hlášek zároveň, i když chyba
v programu je pouze jedna. Zkuste scrollovat výstupem hlášek nahoru, abyste zjistili, která chyba
byla vypsána jako první, zbytek výpisu může být &quot;planý poplach&quot;.</p>
<p>Pokud se vám nedaří chybu vygooglit, tak kontaktujte svého cvičícího.</p>
<p>Při překladu můžete použít dodatečné přepínače, při jejichž použití vydá překladač více varování o
možných problémových místech ve vašem kódu:</p>
<pre><code class="language-bash">$ gcc -Wall -Wextra -pedantic main.c -o program
</code></pre>
<h3>Chyby při běhu programu</h3>
<p>Pokud váš program padá při běhu, můžete zkusit následující způsoby ladění:</p>
<h4>Address sanitizer</h4>
<p>Tento nástroj modifikuje váš program tak, aby dokázal detekovat značné množství chyb při jeho běhu,
a pokud nějakou chybu najde, tak váš program okamžitě ukončí a popíše, k jakému problému došlo. </p>
<pre><code class="language-bash">$ gcc -fsanitize=address main.c -o program
</code></pre>
<p>Jakmile takto přeložený program spustíte a dojde k nějaké chybě, tak bude její popis vypsán na výstup.</p>
<p>Pokud se chyba opraví těsně po svém vzniku, je to mnohem jednodušší, než když se chyba projeví až
později v úplně jiné části kódu. <strong>Doporučujeme tak vždy používat Address Sanitizer při vývoji programů v C</strong>.
Ušetříte si tak spoustu času a námahy při ladění chyb.</p>
<h4>Logování</h4>
<p>Jedním z nejjednodušších způsobů, jak se dozvědět, co se v programu děje, je jednoduše tisknout
hodnoty zajímavých proměnných na výstup programu. Pokud přidáte takovýto výstup na různá místa v kódu,
můžete pak podle výstupu zpětně rekonstruovat, co se při běhu programu dělo.</p>
<h4>Krokování</h4>
<p>Pro interaktivnější zkoumání chování programů je možné je tzv. <strong>krokovat</strong>. K tomu je potřeba nástroj,
který umí program pozastavit při jeho běhu a zobrazit uživateli, co se v něm děje. Takovéto nástroje se nazývají
<strong>debuggery</strong>. Při krokování se program zastaví na určitém místě (řádku) v kódu, a programátor pak může
zkoumat hodnoty proměnných a spouštět program řádek po řádku.</p>
<p>Pro vás je nejjednodušší použít krokování integrované ve VSCode:</p>
<ul>
<li>Klikněte na sloupeček vlevo od čísla řádku, na kterém chcete, aby se program zastavil.
Objeví se tam červené kolečko (tzv. <strong>breakpoint</strong>).</li>
<li>Spusťte program s laděním (<code>F5</code>). Program by se na řádku s breakpointem měl zastavit.</li>
<li>Ve sloupci <code>Variables</code> v levé části VSCode můžete prozkoumat hodnoty proměnných.</li>
<li>Pomocí příkazu <code>Step Over</code> (<code>F10</code>) program vykoná následující řádek a poté se opět zastaví. Pokud
nechcete přeskakovat volání funkcí, použijte <code>Step Into</code> (<code>F11</code>).</li>
</ul>
<blockquote>
<p>VSCode používá pro ladění vašeho programu debugger <code>gdb</code>. Pokud ho chcete použít manuálně, návod
můžete najít například <a href="https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu-pouziti-gdb-a-jeho-nadstaveb/">zde</a>.</p>
</blockquote>
<h1>Programování v C</h1>
<p>V této kapitole naleznete popis základních konstrukcí jazyka C, které jsou základními
stavebními kameny pro tvorbu programů. Ke každému tématu je k dispozici také úloh. Pokud úlohy
zvládnete vypracovat, tak budete mít jistotu, že jste dané téma pochopili a můžete se posunout dále.
Pokud nezvládnete úlohy splnit, tak můžete mít s dalšími koncepty problém. Pokud nebudete stíhat,
tak kontaktujte svého cvičícího.</p>
<p>Zde je přibližný seznam témat, které si během semestru ukážeme. Pořadí témat na cvičení a přednáškách
se může lišit, tento text je určen spíše jako &quot;kuchařka&quot;, ve které se můžete k jednotlivým tématům
vracet, abyste si je připomněli.</p>
<p>Základní témata:</p>
<ul>
<li><a href="">Úvod</a> - popis prázdného C programu</li>
<li><a href="">Výrazy a proměnné</a> - jak něco vypočítat a zapamatovat si to v paměti</li>
<li><a href="">Datové typy</a> - jak pracovat s různými typy dat</li>
<li><a href="">Řízení toku</a> - jak se rozhodovat a provádět akce opakovaně</li>
<li><a href="">Funkce</a> - jak opakovaně využít a parametrizovat opakující se kód</li>
<li><a href="">Ukazatele</a> - jak sdílet data v paměti a pracovat s adresami</li>
<li><a href="">Řetězce</a> - jak v programech reprezentovat text</li>
<li><a href="">Pole</a> - jak jednotně pracovat s velkým množstvím dat</li>
<li><a href="">Struktury</a> - jak seskupit data do logicky souvisejících celků</li>
<li><a href="">Soubory</a> - jak číst a zapisovat soubory</li>
<li><a href="">Modularizace</a> - jak rozdělit program do více zdrojových souborů</li>
<li><a href="">Knihovny</a> - jak využít existující kód od jiných programátorů</li>
</ul>
<p>Všechny tyto koncepty jsou velmi univerzální a v tzv. <a href="https://cs.wikipedia.org/wiki/Imperativn%C3%AD_programov%C3%A1n%C3%AD">imperativních</a>
programovacích jazycích jsou v podstatě všudypřítomné. Jakmile se je jednou naučíte, tak je budete
moct využívat téměř v libovolném populárním programovacím jazyku (Java, C#, Kotlin, Python, PHP,
Javascript, Rust, C++ atd.). </p>
<p>Navazující témata:</p>
<ul>
<li><a href="">TGA</a> - jak pracovat s TGA, jednoduchým formátem pro obrázky</li>
<li><a href="">SDL</a> - jak pracovat s knihovnou SDL tvorbu grafických aplikací a her</li>
</ul>
<h1>Základy syntaxe</h1>
<p>C je (programovací) jazyk a jako každý jazyk má svá pravidla, které je nutno dodržovat.
Například v češtině musíme dodržovat určitá pravidla a zvyklosti, abychom byli schopni výsledný
text pochopit. Věty <code>jsme, M y máma, táta a</code> nebo <code>.o dku  d! ty z, jsi</code> nedávají smysl,
protože obsahují interpunkční znaménka na špatných místech, větné členy jsou ve špatném pořadí
a některá slova obsahují mezery na místech, kam nepatří. Stejně tak v jazyce C můžete velmi jednoduše
napsat program, kterému <a href="preklad_programu.html">překladač</a> nebude rozumět a překlad poté skončí se
syntaktickou chybou (<em>syntax error</em>). Na syntax C si musíte postupně zvyknout, poté už podobné chyby
budete schopni snadno vyřešit.</p>
<p>Zde je asi nejkratší možný program v jazyce C:</p>
<pre><code class="language-c">int main() {
    return 0;
}
</code></pre>
<p>V programu výše je pouze <a href="funkce.html">funkce</a> s názvem <code>main</code>. Funkce si popíšeme později, prozatím
budeme psát kód vždy do funkce <code>main</code> (před <code>return 0;</code>). Jednotlivé prvky programu si postupně vysvětlíme
v následujících sekcích, prozatím si však všimněte, že <strong>bílé znaky</strong> (<em>whitespace</em>)<sup class='margin-toggle sidenote-number'>1</label> jsou obvykle
překladačem ignorovány. Například</p>
<span class='sidenote'><p><sup class='number'>1</sup><a href="https://cs.wikipedia.org/wiki/B%C3%ADl%C3%BD_znak">Bílé znaky</a> jsou (neviditelné) znaky,
které reprezentují mezery v textu, tj. odřádkování, mezerník, tabulátor atd.</p>
</span>
<pre><code class="language-c">int 


main()                 {
    
    
    return         0;
}

</code></pre>
<p>reprezentuje úplně stejný program. Nicméně asi sami uznáte, že pokud bychom s bílými znaky nakládali
takto nerozvážně, tak by zdrojový kód byl pro lidi špatně čitelný. Proto doporučujeme formátování provádět
automaticky ve <a href="editor.html">VSCode</a> pomocí zkratky <code>Ctrl + Shift + I</code>, ať nad ním nemusíte přemýšlet.</p>
<p>Bílé znaky nicméně nejsou ignorovány úplně na všech místech. Například v <a href="c_retezce.html">řetězcích</a>
jsou bílé znaky brány jako součást textu. Nemůžete také rozdělovat mezerami názvy (např. <code>in t</code> nebo
<code>ma in</code> z programu výše by způsobily chybu při překladu).</p>
<h3>Komentáře</h3>
<p>Abychom mohli v následujících sekcích popisovat kusy kódu, ukážeme si teď <strong>komentáře</strong>. Jedná se
o text ve zdrojovém kódu, který je určen pro programátory, ne pro překladač, který je zcela ignoruje.
Bez komentářů bychom nemohli do zdrojového kódu dodávat poznámky, protože překladač by jinak měl snahu
je interpretovat jako C kód. Komentáře v kódu obvykle poznáte snadno, protože je váš editor bude vykreslovat
jinou barvou než zbytek kódu.</p>
<p>V C existují dva typy komentářů:</p>
<ul>
<li>Řádkové komentáře - pokud do kódu napíšete <code>//</code>, tak vše za těmito lomítky až do konce řádku se 
bude brát jako komentář.
<pre><code class="language-c">// komentář 1
int main() {
    // komentář 2
    return 0; // komentář 3
}
</code></pre>
</li>
<li>Blokové komenáře - pokud do kódu napíšete <code>/*</code>, tak bude jako komentář označen všechen následující
text, dokud nedojde k ukončení komentáře pomocí <code>*/</code>.
<pre><code class="language-c">int main() {
    /* zde je komentář
zde taky
a tady taky */
    return 0;
}
</code></pre>
</li>
</ul>
<p>Ze začátku je asi jednodušší používat řádkové komentáře, ve VSCode můžete použít klávesovou zkratku
<code>Ctrl + /</code> pro zakomentování/odkomentování řádku kódu. Pokud vám přijde nějaký kus kódu komplikovaný,
tak si k němu zkuste dopsat komentář, který vysvětlí, co má daný kód dělat. Porozumíte tak kódu snáž,
až se k němu např. za měsíc vrátíte.</p>
<h3>Speciální znaky</h3>
<p>Při programování (jak už v C, tak i v jiných jazycích) budete používat spousty symbolů, které běžně
asi často nevyužíváte (například <code>[</code>, <code>]</code>, <code>{</code>, <code>}</code>, <code>&lt;</code>, <code>&gt;</code>, <code>=</code>, <code>%</code>, <code>#</code>, <code>&amp;</code>, <code>*</code>, <code>;</code>, <code>\</code>,
<code>&quot;</code>, <code>'</code>). Obzvláště pokud pro programování budete používat českou klávesnici, je dobré si ze začátku
najít nějaký tahák (např. <a href="https://github.com/geordi/upr-course/blob/master/assets/cheatsheets/keyboard-cs.pdf">tento</a>),
abyste nemuseli pokaždé zdlouhavě vzpomínat, na které klávese se daný znak nachází. </p>
<h1>Příkazy</h1>
<h1>Výrazy</h1>
<h2>Porovnání, testy, pravdivost</h2>
<p>Pro porovnání hodnot v jazyce C používáme operátory <code>==</code> a <code>!=</code>.</p>
<pre><code class="language-c">int a = 5; int b = 5; int c = 10;

a == b; // pravda

a != b; // nepravda

a == c; // nepravda

a != c; // pravda
</code></pre>
<p>K porovnání pořadí nám slouží operátory <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> a <code>&gt;=</code>.</p>
<h1>Proměnné a datové typy</h1>
<p>V staticky typovaných jazycích jako je C musíme deklarovat typy
použitých proměnných (na rozdíl od jazyků jako Python či PHP).</p>
<p>Proměnnou vytvoříme jednoduše tak, že nadefinujeme její typ a pak její
jméno, případně můžeme na jednom řádku definovat více proměnných jednoho
typu různých jmen oddělených čárkou.</p>
<pre><code class="language-c">int counter;
int sum, no_elements = 0;
</code></pre>
<p>Na výše uvedeném výpisu je použit výsek kódu, který deklaruje na prvním
řádku celočíselnou proměnnou typu <code>int</code>, která reprezentuje integer, což je
datový typ reprezentující celá čísla.
Druhý řádek demonstruje, že je možno
deklarovat více proměnných jednoho datového typu na jednom řádku. Je
deklarována proměnná <code>sum</code> a <code>no_elements</code>, do které je přiřazena
počáteční hodnota <code>0</code> (pokud do proměnné rovnou přiřadíme hodnotu, je to definice proměnné).
Pokud hodnotu do proměnné takto nepřiřadíme na začatku při její deklaraci,
musíme takovou proměnnou před prvním použitím nejříve nastavit na
požadovanou hodnotu. Typicky se toto děje, pokud používáme proměnnou
jako nějaké počítadlo.</p>
<pre><code class="language-c">int counter;

int sum, no_elements = 0;

printf( &quot;sum: %d\n&quot;, sum );                  // muze byt cokoli: sum: 432749
printf( &quot;no_elements: %d\n&quot;, no_elements );  // no_elements: 0
</code></pre>
<p>Na řádku 5 a 6 vidíme použití knihovní funkce <code>printf</code>, která nám bude sloužit pro
tisk obsahu proměnných na konzoli. Můžete vidět, že funkce <code>printf</code> používá
formátovací řetězec, kde celá čísla (<code>int</code>eger) jsou zastoupena znakem <code>%d</code>.
Obecně je formátovácí řetězec uvozen znakem <code>%</code> následovaný formátovacím
znakem. Více o formátování výstupu se můžete dozvědet např. zde:
<sup class='margin-toggle sidenote-number'>1</label>,<sup class='margin-toggle sidenote-number'>2</label>.</p>
<span class='sidenote'><p><sup class='number'>1</sup>Standardní vstup a výstup, <a href="http://www.sallyx.org/sally/c/c07.php">http://www.sallyx.org/sally/c/c07.php</a></p>
</span><span class='sidenote'><p><sup class='number'>2</sup>Dokumentace funkce <code>printf</code>, <a href="http://www.cplusplus.com/reference/cstdio/printf/">http://www.cplusplus.com/reference/cstdio/printf/</a></p>
</span>
<pre><code class="language-c">int a = 5, b = 10;

int c = a + b;

printf( &quot;%d + %d = %d\n&quot;, a, b, c );  // 5 + 10 = 15
</code></pre>
<h2>Jednoduché datové typy</h2>
<p>Nyní si ve stručnosti ukážeme základní datové typy.</p>
<p><strong>Čísla</strong>: <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code></p>
<ul>
<li><code>23</code> <code>2345837934346901268</code> <code>0x17</code> <code>3.4</code></li>
<li>operátory: <code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code> <code>&amp;&amp;</code> <code>||</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code></li>
</ul>
<p><strong>Cvičení:</strong> Napište jednoduchý program pro práci s čísly.
Vyzkoušejte si operátory.</p>
<p><strong>Cvičení:</strong> Napište program pro jednoduché počítání.
Provádějte operace s čísly jako na kalkulátoru. Pokuste se použít
proměnné a závorky.</p>
<h1>Řízení toku</h1>
<h1>Podmínky</h1>
<h1>Řízení toku</h1>
<p>Nejznámější příkaz pro řízení toku <code>if</code>, jsme si již uvedli v kapitole
@ref(sec:syntax). Schématicky si jej proto pouze připomeneme:</p>
<ul>
<li><strong>if ( &lt;výraz&gt; ) { &lt;vnořený blok&gt; }</strong></li>
<li>0+ else if ( &lt;výraz&gt; ) { &lt;vnořený blok&gt; }</li>
<li>volitelně: else { &lt;vnořený blok&gt; }</li>
</ul>
<p>Pro vytvoření cyklů nám v jazyce C slouží dvě konstrukce: <code>while</code> a <code>for</code>.</p>
<h2>Cyklus while</h2>
<p>Cyklus <code>while</code> funguje tak, že na začátku máme dánu podmínku iterace. Je-li
podmínka splněna, je vykonáno tělo cyklu, v opačném případě je cyklus
přeskočen a pokračuje se dále v programu. V těle cyklu můžeme použít
klíčová slova <code>break</code> a <code>continue</code>. Slovo <code>break</code> zapříčiní ukončení cyklu.
Slovo <code>continue</code> zapříčiní
přeskočení zbytku těla cyklu s návratem na počáteční podmínku a tím
pádem vykonání dalšího cyklu za předpokladu, že je splněna tato vstupní
podmínka.</p>
<pre><code class="language-c">int i = 0;

while ( i &lt; 5 ) {
	printf( &quot;%d\n&quot;, i );
	i += 1;
}

// 0
// 1
// 2
// 3
// 4
</code></pre>
<h2>Cyklus for</h2>
<p>Cyklus <code>for</code> typicky používáme pro průchod nějakého pole ať už statického nebo
dynamického. Funkguje tak, že si vytvoříme řídící proměnnou, která
indexuje procházené pole od nuly (0) do jeho konce (n-1). Důležité je
vědět, že řídící proměnná cyklu nenabývá hodnoty prvku pole, ale je
pouze indexem do procházeneho pole. Hodnotu z pole si již musíme pomocí
tohoto indexu zpřístupnit sami.</p>
<p>Ukažme si jednoduchý příklad na součet prvků v poli intů.</p>
<pre><code class="language-c">int len = 5;
int seznam[] = { 1, 2, 5, 10, 100 };
int sum = 0;

for ( int i = 0; i &lt; len; i++ ) {
	int prvek = seznam[ i ];
	sum += prvek;
}
printf( &quot;sum: %d\n&quot;, sum );  //118
</code></pre>
<h1>Funkce a procedury</h1>
<p>Asi bychom byli schopni naše programy psát tak, abychom nepotřebovali
použít funkce. Toto by nám však vystačilo na velmi krátké programy,
poněvadž bychom jinak museli všechen kód psát znovu a znovu. Základní
vlastností funkcí je jejich znovupoužitelnost. Pokud tedy máme úlohu,
kterou víme, že budeme požívat více než jednou, je vhodné ji umístit do
funkce. Takovýto blok kódu by též měl fungovat pokud možno co nejvíce
samostatně.</p>
<h2>Funkce</h2>
<p>V jazyce C je definice funkce do značné míry podobná definici funkce v
jiných jazycích. Uvádíme návratový datový typ a uvádíme datové typy
argumentů funkce. Toto je dáno statickou typovostí jazyka. Uveďme si
jednoduchý příklad pro výpočet mocniny čísla.</p>
<pre><code class="language-c">int sqr( int number ) {
    return number * number;
}
int number = 3;
printf( &quot;sqr( number ): %d\n&quot;, sqr( number ) ); // 9
</code></pre>
<p>Funkce je tedy deklarována tak, že jako první je uveden její návratový
typ. V našem případě tedy <code>int</code> pro celá čísla. Pak je uvedeno jméno funkce. V
tomto případě <code>sqr</code>. Pak je v kulatých závorkách uveden seznam parametrů
(nebo též argumentů), které funkce přijímá, tedy <code>number</code>. Tělo naší funkce <code>sqr</code>
obsahuje pouze jeden řádek, který vypočte druhou mocninu zadaného čísla
a takto spočítanou hodnotu vrátí z funkce ven pomocí klíčového slova <code>return</code>.
Volání funkce je pak provedeno jménem funkce s parametry uvedenými v
kulatých závorkách tak, jak je to uvedeno v příkladu.</p>
<p>Funkce nám také dovolují provádět generalizaci, což je zobecnění
zadaného problému. Vezměme si výpočet mocniny čísla jako jednoduchý
příklad. První ukázka funkce <code>sqr</code> umí vypočítat pouze druhou mocninu zadaného
čísla <code>number</code>. My bychom však chtěli vytvořit obecnou funkci na výpočet
jakékoli mocniny čísla. Taková funkce je v ukázce níže.</p>
<pre><code class="language-c">int pow( int number, int exponent ) {
    int result = number;
    int i = 1;
    while ( i &lt; exponent ) {
        result *= number;
        i++;
    }
    return result;
}

int a = 2, b = 3;
printf( &quot;pow( %d, %d ): %d\n&quot;, pow( a, b ) );  // pow( 2, 3 ): 8
b = 5;
printf( &quot;pow( %d, %d ): %d\n&quot;, pow( a, b ) );  // pow( 2, 5 ): 32
</code></pre>
<p>Funkce <code>pow</code> má nyní 2 parametry s mocněncem <code>number</code> a mocnitelem <code>exponent</code>. Místo natvrdo
nastavené hodnoty <code>2</code> pro výpočet druhé mocniny z předcházejícího příkladu
(realizovaného násobením) je mocnitel zadán parametrem funkce. Máme tak
zobecněný (generalizovaný) kód pro výpočet mocniny.</p>
<h2>Procedury (funkce bez návratového typu)</h2>
<p>V jazyce C máme jeden datový typ, který nemá přesné určení. Je to typ a
může prakticky znamenat cokoli. Nejčastěji jej používáme jako pointer na
nějakou struktury, kterou pak budeme dále přetypovávat. Velmi často je
však používán jako návratový typ funkce. V takovém případě funkce
nevrací žádnou hodnotu. Funkce pouze zpracuje vstupní data a tím její
úloha končí. Takové funkci říkáme procedura.</p>
<h2>Parametry funkcí</h2>
<p>V prvním příkladu pro výpočet druhé mocniny jsme použili parametr tak,
že byl volán tzv. hodnotou. To prakticky znamená, že hodnota uložená v
proměnné <code>number</code> na řádku 5 se nakopíruje do parametru <code>number</code> funkce <code>sqr</code> na řádku 1. Snadno si
lze představit, že pokud bychom chtěli ve funkci pracovat s větším
objemem dat, vyžadovalo by to velké kopírování dat, což by náš program
zpomalovalo. Další problém pak může nastat, když by kopírovaná data byla
větší než velikost stacku, kterou máme přidělenu.</p>
<p>Vyřešit můžeme tyto problémy jednoduše tak, že budeme argument funkce
předávat odkazem. Odkaz bude v kontextu našeho jazyka jednoduše pointer.
Ukažme si, jak upravit funkci pro výpočet druhé mocniny, aby akceptovala
argument předávaný odkazem.</p>
<p>TODO: Co tohle je za kravina... Predelat!!!</p>
<pre><code class="language-c">int sqr( int *number ) {
    return *number * *number;
}
int number = 3;
printf( &quot;sqr( &amp;number ): %d\n&quot;, sqr( &amp;number ) );  // sqr( &amp;number ): 9
</code></pre>
<p>Jak již víme, pointer nám ukazuje na nějaké místo v paměti. Upravili
jsme definici funkce <code>sqr</code> tak, že argument number je nyní pointrem. Každá
proměnná je někde v paměti uložena a stejné je to i pro proměnnou <code>number</code>
dekladovanou na řádku 5. Abychom mohli do argumentu funkce <code>number</code>, který někam
ukazuje předat adresu paměti, musíme ji získat pomocí znaku <code>&amp;</code> (řádek 7).
Tím pádem budeme ve funkci <code>sqr</code> pracovat s úplně stejnou pamětí jako při
definici proměnné <code>number</code> na řádku 5.</p>
<p>Ukažme si ještě, jak pracovat ve funkci s polem. Chtějme naprogramovat
funkci <code>sum</code>, která spočítá součet čísel v poli o zadané délce.</p>
<pre><code class="language-c">int sum( int *array, int len ) {
    int result = 0;
    for ( int i = 0; i &lt; len; i++ ) {
        result += array[ i ];
    }
    return result;
}
int array_len = 5;
int array_of_its[ array_len ] = { 1, 2, 3, 4, 5 };
printf( &quot;sum( array_of_ints, array_len ): %d\n&quot;, sum( array_of_ints, array_len ) );  // 15
</code></pre>
<p>V jazyce C musíme funkcím, které pracují s polem předat samostatně délku
pole, poněvadž z pointeru samotného ji zjístit nemůžeme. Pole samotné
předáváme přes pointer <code>array</code> a jeho délku přes parametr <code>len</code>. Do funkce <code>sum</code> pole
předáme pomocí jeho názvu, protože ten je již adresou prvního prvku
pole. Ve funkci pak k prvkům pole přistupujeme tak, jak jsme zvyklí.</p>
<p>Pokud předáváme do funkce argument odkazem, můžeme obsah takové proměnné
změnit a tato změna se projeví i na datech, která jsme do funkce
poslali. To nám otvírá mnoho možností, jak efektivně manipulovat s daty
v procedurách. Mějme však na paměti, že pak můžeme snadno přijít k
úhoně, nebudeme-li bedlivě sledovat, co a kde měníme.</p>
<p><strong>Cvičení:</strong> Vytvořte proceduru, která nastaví všechny
prvky předaného pole na zadanou hodnotu.</p>
<p><strong>Cvičení:</strong> Vytvořte funkci, která zjistí počet sudých a
lichých čísel předaného pole. Tyto 2 čísla se vrátí pomocí dvou
proměnných, které budou pointery na inty.</p>
<h1>Ukazatele</h1>
<h2>Práce s dynamicky alokovanou pamětí a řetězci znaků (string)</h2>
<p>Typická literatura se zabývá prací s dynamicky alokovanou pamětí až v
pozdějších kapitolách. Dovolme si lehký komentář, když vyslovíme
tvrzení, že ,,pak jsou z toho všichni ztraceni”. Zkusme se tedy podívat
na práci s dynamicky alokovanou pamětí hned na začátku, aby nás pak
práce s ní zbytečně nepřekvapovala.</p>
<p>Doposud jsme viděli vytváření celočíselných proměnných, které
reprezentují jedno číslo. Co když ale potřebujeme, aby bylo těchto čísel
více? Odpověď je snadná. Použijeme dynamicky alokované pole čísel. (Ano,
i staticky alokované pole je možnost, ale nesmí být příliš veliké
(dlouhé)). Na druhou stranu, dynamicky alokované pole by zase nemělo být
příliš krátké.</p>
<p>Při programování v jazyce C máme k dispozici dva druhy paměti. Jsou to:
<strong>stack</strong> (česky <strong>zásobník</strong>) a <strong>heap</strong> (česky <strong>halda</strong>). Když jsme
definovali celočíselné promenné v předchozí části, jejich obsah
(hodnoty) se ukládal na stacku. Programům je však k dispizici jen
omezený stack (např. 32 MB). Když chceme využívat v našich programech
více paměti, musíme použít heap.</p>
<p>Pro to, abychom si od operačního systému (OS) vyžádali nějakou paměť na
heapu, používáme funkci <code>malloc</code>, která nám vrátí pointer (ukazatel) na začátek
takovéto paměti. Zajisté znáte anglické tvrzení: ,,There’s nothing like
a free lunch”. I za takto poskytnutou paměť se nějakým způsobem platí.
Jazyk C nemá automatickou správu paměti, a proto ji musíme vlastnoručně
OS vrátit, když ji již nepotřebujeme. K tomu nám slouží funkce <code>free</code>
(jak příznačný název).</p>
<p>Pojďme se podívat na příklady použití. Stringy (řetězce znaků) jsou
typickým příkladem, kdy potřebujeme nějaké pole pro reprezentaci více
hodnot (třeba nějakých vět, ale také často textových dat).</p>
<pre><code class="language-c">char c = 'A';  // umoznuje reprezentaci pouze jednoho znaku
char * str = NULL;
str = (char *)malloc( 20 * sizeof( str[ 0 ] ) );

sprintf( str, &quot;Hello, World!&quot; );

printf( &quot;str: '%s'\n&quot;, str ); // str: 'Hello, World!'
printf( &quot;str length: %d\n&quot;, strlen( str ) ); // 13

free( str ); // pointer na str jiz nepotrebuji, vracim pamet

str = NULL;  // jsem slusny a pointer nastavim na NULL,
             // aby bylo jasne, ze nikam neukazuje
</code></pre>
<p>To, že budeme chtít pracovat s dynamicky alokovanou pamětí, musíme
jazyku C řící tak, že deklarace proměnné bude pointerem, který bude
ukazovat na takovou paměť. To zajistíme jednoduše tak, že před název
proměnné napíšeme znak <code>*</code>. Funkce <code>malloc</code> nám vrací tzv. pointer na úsek paměti o
velikosti, kterou jsme chtěli. Pokud nám OS paměť nepřidělí, vrátí
funkce pointer na tzv. <code>NULL</code>. Toto bychom měli řádně zkontrolovat, ale pro
přehlednost příkladu to není uvedeno. Velikost paměti, kterou od OS
požadujeme se uvádí v bytech (česky bajtech). Každý datový typ vyžaduje
pro uložení informace nějaký počet bytů. Nejměnší datový typ <code>char</code> požaduje 4
byty. Typ <code>int</code>, pro uložení celých čísel, vyžaduje typicky 4 byty. Reálná
čísla uložená v typu <code>float</code> vyžadují 4 byty a reálná čísla uložená v typu <code>double</code>
vyžadují 8 bytů. Každá platfroma, na které bude náš program přeložen
však může datovým typům přiřadit jiný počet bytů. Abychom si nemuseli
pamatovat, kolik bytů jaký typ zabírá, existuje v jazyce C operátor <code>sizeof</code>,
který nám vrátí, kolik bytů zadaný typ vyžaduje. Potom již jen toto
číslo stačí přenásobit požadovanou délkou pole. V našem příkladu
požadujeme délku řetězce 20 znaků. Jazyk C nebyl zcela jistě konstruován
pro práci se stringy... Pro to, abychom naše pole znaků naplnili nějakým
obsahem, musíme použít funkci <code>sprintf</code>. Ta bere jako první parametr ukazatel na
paměť, kde má řetězec uložit, druhým parametrem je pak jaký řetězec se
má vložit. Případný třetí parametr pak může obsahovat proměnné, jejichž
obsah chceme vložit do formátovacího řetězce. Obsah proměnné <code>str</code> je pak
tištěn ve funkci <code>printf</code>. Délku řetězce je možno zjistit funkcí <code>strlen</code>, která vrací
délku řetězce jako celé číslo. Po ukončení práce s dynamicky alokovanou
pamětí je třeba jí vrátit zpět OS. To se provede voláním funkce <code>free</code>, která
bere jako argument pointer na dynamicky alokovanou paměť. V našem
případě je to <code>str</code>. Bývá ještě dobrým zvykem, abychom takto uvolněný pointer
nastavili na <code>NULL</code>. Takto nastavený pointer jasně říká, že neukazuje na
žádnou paměť.</p>
<h2>Pole</h2>
<p>Jedním z důležitých prvků jazyka C je práce s poli. Již jsme si v
předchozím odstavci ukázali, jak vytvořit dynamicky alokované pole pro
reprezentaci řetězce. Samozřejmě můžeme vytvořit podobné pole pro
reprezentaci intigerů, floatů, apod. Je také bez problému možné vytvořit
pole na stacku, které nemusíme dealokovat. Jeho platnost je však pouze v
rámci bloku, ve kterém je deklarováno, např. tedy funkce. Takové pole
také nelze z funkce vrátit pomocí klíčového slova <code>return</code>. Pojďme si nyní
ukázat, jak je možno s poli pracovat.</p>
<upr-container>
  <upr-array array='["A", "h", "o", "j", "\\0"]' highlight='{"4": "muted"}'></upr-array>
  <upr-arrow src-anchor="north" dst=".index-4" dst-anchor="south" ctrl-distance="-15">
    ukončovací nula
  </upr-arrow>
</upr-container>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
  char str[] = &quot;Ahoj&quot;;
  printf( &quot;%c %c %c %c\n&quot;, str[ 0 ], str[ 1 ], str[ 2 ], str[ 3 ] );
  // A h o j
}
</code></pre>
<p>Z uvedeného příkladu vyplývá, že k jednotlivým prvkům pole se přistupuje
přes operátor hranaté závorky (<code>[]</code>).</p>
<p>Pole můžeme též modifikovat. Nejjednodušeji lze modifikovat určitý prvek
pole tak, že jej indexujeme a do takto indexovaného prvku přiřadíme
požadovanou hodnotu. Stávající hodnota se v poli přepíše hodnotou novou.</p>
<pre><code class="language-c editable mainbody">#include &lt;stdio.h&gt;

int main() {
  char str[] = &quot;Ahoj&quot;;
  printf( &quot;%s\n&quot;, str );  // Ahoj
  str[ 1 ] = 'A';
  printf( &quot;%s\n&quot;, str );  // AAoj
}
</code></pre>
<h2>Příklady</h2>
<h3>Suma pole</h3>
<p><upr-array-sum array="[1, 2, 3, 4, 5]"></upr-array-sum></p>
<h3>Minimální hodnota v poli</h3>
<p><upr-array-min array="[5, 6, 3, 4, 1]"></upr-array-min></p>
<h3>Převrácení pole</h3>
<p><upr-array-reverse array="[1, 2, 3, 4, 5]"></upr-array-reverse></p>
<h1>Struktury</h1>
<p>Již umíme pracovat s jednoduchými datovými typy, které nám mohou
reprezentovat celá nebo reálná čísla, či řetězce znaků. Práce se
strukturovanými datovými typy můžeme do jisté míry považovat za
předstupeň k objektově orientovanému programování.</p>
<h2>Co jsou struktury</h2>
<p>Představme si, že bychom chtěli pomocí jednoduchých datových typů řešit
komplexnější problém. Tento problém by ke svému popisu potřeboval více
proměnných. Jako jednoduchý přiklad můžeme použít reprezentaci obrazu. V
takovém případě potřebujeme reprezentovat alespoň hodnoty v jednotlivých
pixelech a počet řádků (výšku) a počet sloupců (šířku) obrazu. Pro
jednoduchost předpokládejme obrázek ve stupních šedi. Ukažme si, jak by
taková reprezentace v jazyce C vypadala.</p>
<pre><code class="language-c">unsigned char * img_data;
int img_rows;
int img_cols;
</code></pre>
<p>(<strong>TODO: Pripravit to na TGA header</strong>)</p>
<p>Pointer <code>unsigned char</code> na s názvem <code>img_data</code> nám bez problému může reprezentovat 8 bitové obrazy
ve stupních šedi, neboť do něj můžeme ukládat hodnoty 0 - 255 (2<sup>8</sup> = 256 různých hodnot).
Představme si dále, že bychom chtěli takovýto obrázek o nějaké velikosti
nastavit na černou barvu (hodnota <code>0</code>).</p>
<pre><code class="language-c">void set_image_to_black( unsigned char * img_data,
                         const int img_rows, const int img_cols )
{
    for ( int y = 0; y &lt; img_rows; y++ ) {
        for ( int x = 0; x &lt; img_cols; x++ ) {
            img_data[ x + y * img_cols ] = 0;
        }
    }
}
</code></pre>
<p>Jak můžete vidět, do funkce <code>set_image_to_black</code> posíláme všechny parametry obrázku, abychom
s ním mohli pracovat. Snadno si lze představit, že se složitějšími
problémy by snadno mohl počet parametrů funkcí značně narůstat.</p>
<p>Pro zefektivnění takové práce nám slouží strukturované datové typy,
jednodušeji struktury (anglicky <em>structures</em>). V jazyce C je pro definici
datových struktur vyhrazeno klíčové slovo <code>struct</code>. Pojďme se podívat, jak by
definice takového obrázku mohla vypadat.</p>
<pre><code class="language-c">struct ImageStruct {
    unsigned char * data;
    int rows;
    int cols;
};
</code></pre>
<p>Jak můžete vidět, definice začíná požitím klíčového slova <code>struct</code>, které je
následovano jménem struktury. V následném bloku jsou pak definovani
členové struktury, které nazýváme <code>atributy</code>, s jejich příslušnými
datovými typy. Na první pohled již není nutné ke jménům členů struktury
obrázku přidávat předponu <code>img_</code>, neboť jejich členství v této datové
struktuře je jasně dáno.</p>
<p>Struktura ovšem není datovým typem, proto ji nelze použít přímo jako
definici typu (pokud ovšem nepoužijete C++ překladač). Proto se často
používá definice aliasu na datovou strukturu. K definici takového aliasu
se používá klíčové slovo <code>typedef</code>. Toto slovo má následující syntaxi:</p>
<pre><code class="language-c">typedef struct tag_name struct_alias;
</code></pre>
<p>Za <code>tag_name</code> dosazujeme jméno naší struktury, za <code>struct_alias</code> nové jméno, pod kterým chceme
naši strukturu používat jako datový typ. Příklad pro naši strukturu s
obrázkem tedy bude vypadat následovně:</p>
<pre><code class="language-c">struct ImageStruct {
    unsigned char * data;
    int rows;
    int cols;
};

typedef struct ImageStruct Image;

Image * image;
</code></pre>
<p>Dále můžeme s pointrem <code>* image</code> pracovat tak, že mu naalokujeme dynamickou paměť
tak, jak jsme si již ukázali.</p>
<p><strong>Cvičení:</strong> Vytvořte si vlastní strukturu pro reprezentaci
osoby (<code>Person</code>) s několika atributy.</p>
<p>K jednotlivým atributům struktury přistupujeme pomocí tečkové (<code>.</code>) nebo
šipkové (<code>-&gt;</code>) notace. Tečku používáme, když je struktura vytvořena na
stacku. Šipku pak používáme pro přístup k atributům struktury, která je
alokována na heapu.</p>
<p>Ukažme si tedy příklad, kdy budeme chtít nastavit počet řádků nějakého
obrázku:</p>
<pre><code class="language-c">struct ImageStruct {
    unsigned char * data;
    int rows;
    int cols;
};

typedef struct ImageStruct Image;

Image * heap_image;
Image   stack_image;

// alokace...

// teckova notace
stack_image.rows = 480;

// sipkova notace
heap_image-&gt;rows = 480;
</code></pre>
<p>Můžeme vidět, že rozdíl je nepatrný, je však nutné na něj dávat pozor,
jinak náš program nepůjde přeložit.</p>
<h2>Funkce pro práci se strukturami</h2>
<p>Práce se strukturami ve funkcích nepodléhá nějakým syntaktickým
pravidlům. Zavedeme si však pár pravidel pro nás samotné, abychom se v
našem kódu lépe orientovali.</p>
<p>Pokud budeme pracovat se strukturou ve funkcích, bývá dobrým zvykem, aby
jméno takové funkce začínalo názvem struktury (malými pásmeny) a
následně jsou podtržítky oddělena slova vyjadřující operaci, kterou se
strukturou provádíme.</p>
<p>Ukažme si, jak bychom alokovali strukturu, kterou používíme pod aliasem <code>Image</code>.</p>
<pre><code class="language-c">struct ImageStruct {
    unsigned char * data;
    int rows;
    int cols;
};

typedef struct ImageStruct Image;

Image * heap_image;

// alokuje prazdny obrazek
Image * image_new( const int rows, const int cols ) {
    Image * image = NULL;
    image = (Image *)malloc( sizeof( image[ 0 ] ) );
    image-&gt;data = (unisgned char *)malloc( rows * cols * sizeof( image-&gt;data[ 0 ] ) );
    image-&gt;rows = rows;
    image-&gt;cols = cols;
    return image;
}

heap_image = image_new( 640, 480 );
</code></pre>
<p>Na výpisu kódů uvedeném výše můžeme vidět, že funkce <code>image_new</code> vytváří dynamicky
alokovanou datovou strukturu <code>Image</code>. Popišme si, co se přesně děje. Návratový
typ funkce <code>image_new</code> je pointer na strukturu <code>Image</code> (je to tedy <code>Image *</code>).
Na řádku 13 si vytvoříme nový
pointer na <code>Image</code>, se kterým budeme pracovat (alokovat jej a jeho atributy) a
také jej vrátíme na konci funkce. Pro tento pointer alokujeme paměť o
velikosti struktury <code>Image</code> na řádku 15. Dále alokujeme prostor pro jasy jednotlivých
pixelů obrázku na řádku 17. Atributy <code>rows</code> a <code>cols</code> struktury <code>Image</code> nastavujeme na řádcích 19 a 20.
Nakonec vracíme takto vytvořenou strukturu na řádku 22. Volání takové
funkce je ukázáno na řádku 25, kde vytváříme obrázek o velikosti
$640 \times 480$ pixelů.</p>
<p>Ukažme si ještě, jak bychom takto naalokovanou struktury zase uvolnili,
tzn. vrátili bychom alokovanou paměť zpět OS.</p>
<pre><code class="language-c">// dealokuje strukturu s obrazkem
void image_free( Image * self ) {
    free( image-&gt;data );  // uvolnujeme jasy pixelu
    free( image );        // uvolnujeme strukturu
}

image_free( heap_image );
</code></pre>
<p>Jak můžeme vidět, funkce <code>image_free</code> akceptuje jeden argument, který je pointrem na
strukturu <code>Image</code>. Ten je předán pod názvem <code>self</code>, ale můžeme si jej pojmenovat jak
nám libo. V těle funkce se nácházeji dvě dealokační volání funkce <code>free</code>.
První volání uvolňuje pamět pro jasy pixelů. Druhé volání pak uvolňuje
paměť, kterou zabírá samotná datová struktura. Důležité je, v jakém
pořadí jsou jednotlivé atributy a datová struktura samotná uvolňovány.
Platí jednoduché pravidlo, že nejprve uvolňujeme data atributů a až pak
můžeme uvolnit strukturu samotnou. V opačném případě bychom totiž při
uvolnění struktury ztratili pointer na atributy a tím by paměť byla až
do konce běhu programu ztracena.</p>
<p><strong>Cvičení:</strong> Upravte funkci <code>image_new</code> tak, aby data, která
reprezentují pixely byla nastavena na černou barvu (hodnota <code>0</code>).</p>
<p><strong>Cvičení:</strong> Vytvořte funkci, která na zadanou souřadnici
pixelu v obrázku reprezentovaného strukturou <code>Image</code> nastaví zadanou hodnotu.</p>
<p><strong>Cvičení:</strong> Vytvořte funkci, která do obrázku
reprezentovaného strukturou <code>Image</code> nakreslí zvoleným jasem obdélník o zadaných
rozměrech.</p>
<h1>Soubory</h1>
<h1>Modularizace</h1>
<h1>Knihovny</h1>
<p><strong>Knihovny</strong> (<em>libraries</em>) jsou kusy kódu, které lze používat pomocí nadefinovaného rozhraní a díky tomu
je lze sdílet mezi více projekty/programy, aby se stejný kód nemusel psát pokaždé znovu. Existuje obrovské
množství C knihoven, které jsou volně dostupné na internetu, například pro <a href="https://www.libsdl.org/">vykreslování grafiky</a>,
<a href="https://www.freetype.org/">sazbu fontů</a> nebo <a href="http://zlib.net/">kompresi dat</a>. </p>
<p>Knihovny se obvykle nesdílí čistě jako archiv nebo adresář se zdrojovým kódem. Obvykle se setkáte s tím,
že knihovna poskytuje dvě věci: </p>
<ol>
<li><strong>Hlavičkové soubory</strong> (<em>header files</em>) s příponou <code>.h</code>, které definují rozhraní, jak knihovnu používat.</li>
<li>Soubory s příponami <code>.a</code> nebo <code>.so</code>, které obsahují již přeložené zdrojové soubory knihovny ve formě
spustitelného kódu.</li>
</ol>
<blockquote>
<p>Více o knihovnách se můžete dozvědět například <a href="https://www.itnetwork.cz/cecko/linux/cecko-a-linux-staticke-a-dynamicke-knihovny">zde</a>.</p>
</blockquote>
<h4>Použití knihoven pomocí <code>gcc</code></h4>
<p>Abyste ve vašem programu použili nějakou knihovnu, musíte ji k vašemu programu tzv. <strong>přilinkovat</strong>.
O to se stará tzv. <strong>linker</strong>, který za vás umí spustit překladač <code>gcc</code>.</p>
<p>Dejme tomu, že chcete použít knihovnu s názvem <code>foo</code>, která obsahuje hlavičkové soubory v adresáři
<code>/usr/foo/include</code> and zkompilovaný knihovní soubor v adresáři <code>/usr/foo/lib/libfoo.so</code>. Překladači
<code>gcc</code> musíte říct, kde jsou umístěny knihovní soubory pomocí přepínače <code>-L</code>, které konkrétní soubory chcete
přilinkovat pomocí přepínače <code>-l</code> a kde jsou umístěny hlavičkové soubory pomocí přepínače <code>-I</code>:</p>
<pre><code class="language-bash">$ gcc -o program main.c -L/usr/foo/lib/ -lfoo -I/usr/foo/include
</code></pre>
<p>Používá se konvence, že pokud je název knihovního souboru <code>lib&lt;nazev&gt;.so</code>, tak název knihovny je <code>&lt;nazev&gt;</code>,
pro <code>gcc</code> se tedy zadá pouze <code>-l&lt;nazev&gt;</code> a ne <code>-llib&lt;nazev&gt;.so</code>. Přepínače <code>-l</code> by měly být vpravo (za)
názvy zdrojových souborů. Všechny tři tyto přepínače lze použít vícekrát v rámci jednoho spuštění <code>gcc</code>.</p>
<p>Poté ve zdrojovém souboru vložíte hlavičkové soubory knihovny a můžete používat funkce, které nabízí.</p>
<p>Pokud je knihovna statická (knihovní soubor má příponu <code>.a</code>), tak už není třeba dělat nic dále. Pokud
je však knihovna dynamická (přípona <code>.so</code>), tak k načtení knihovny dojde až při samotném spuštění programu
(ne při jeho překladu). Musíme tak programu při jeho spuštění říct, kde má knihovnu hledat (pokud ji neumí
naleznout automaticky).</p>
<p>Abychom zjistili, které dynamické knihovny náš program vyžaduje, můžeme použít program <code>ldd</code>:</p>
<pre><code class="language-bash">$ ldd program
linux-vdso.so.1 (0x00007ffce73ae000)
libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f193e1af000)
/lib64/ld-linux-x86-64.so.2 (0x00007f193e7a2000)
foo =&gt; ...
</code></pre>
<p>Pokud pro naši knihovnu ve výstupu není uvedena správná cesta, musíme při spuštění programu nastavit
<strong>proměnnou prostředí</strong> <code>LD_LIBRARY_PATH</code> a uložit do ní cestu k adresáři, ve které se naše knihovna nachází:</p>
<pre><code class="language-bash">$ LD_LIBRARY_PATH=/usr/foo/lib ./program
</code></pre>
<h1>Úlohy</h1>
<h2>Zápis struktur do souboru</h2>
<p>Struktury jsou i dobrým komunikačním nástrojem.
Můžeme je uložit v podobě souboru na disk a přečíst je pak jiným programem, který je může dále zpracovat.
Modelovou situací může být program pro zpracování fotografií.</p>
<p>V první řadě budeme simulovat fotoaparát, který uloží obrázek do souboru.
Existuje mnoho způsobů, jak uložit obraz. Tyto způsoby jsou definovýny různými formáty
(např. <code>JPG</code>, <code>PNG</code>, <code>BMP</code>, <code>TGA</code>, apod.).
Asi nejjednodušeji uchopitelným formátem je <code>TGA</code>, jehož hlavička vypadá následovně <sup class='margin-toggle sidenote-number'>1</label>:</p>
<span class='sidenote'><p><sup class='number'>1</sup>https://en.wikipedia.org/wiki/Truevision_TGA</p>
</span><table>
    <thead>
        <tr>
            <th>Č. položky</th>
            <th>Délka</th>
            <th>Jméno položky</th>
            <th>Popis</th>
        </tr>
    </thead>
    <tbody>
        <tr><td>1</td><td>1 byte	</td><td>ID length</td>                 <td>Length of the image ID field</td>   </tr>
        <tr><td>2</td><td>1 byte	</td><td>Color map type</td>            <td>Whether a color map is included</td></tr>
        <tr><td>3</td><td>1 byte	</td><td>Image type</td>                <td>Compression and color types</td>    </tr>
        <tr><td>4</td><td>5 bytes	</td><td>Color map specification</td>   <td>Describes the color map</td>        </tr>
        <tr><td>5</td><td>10 bytes	</td><td>Image specification</td>       <td>Image dimensions and format</td>    </tr>
    <tbody>
</table>
<h1>SDL</h1>
<h1>Rozklad problému</h1>
<p>Často se setkáte s tím, že dostanete k naprogramování úlohu, se kterou si nevíte rady a netušíte ani
jak začít. Například:</p>
<p><code>Načti obrázek z disku, změň jeho velikost, ulož ho do jiného souboru a vykresli jej na obrazovku.</code></p>
<p>Tato úloha vypadá velmi jednoduše, když je zadaná větou (v češtině), ale obzvláště pro začínající
programátory je obtížné převést takovouto úlohu do programovacího jazyka. Obecným pravidlem k usnadnění
řešení složitých úloh je rozdělovat je na menší a jednodušší podúlohy tak dlouho, dokud se nedostaneme
k podúloze, kterou již umíme vyřešit. Poté z těchto malých kousků, které máme vyřešené, zpětně poskládáme
celý program, který vyřeší původní úlohu.</p>
<p>Například zmíněnou úlohu můžeme rozdělit na následující podúlohy: </p>
<ul>
<li>Načti obrázek z disku
<ul>
<li>Otevři soubor se vstupním obrázkem</li>
<li>Načti hlavičku obrázku</li>
<li>Vytvoř paměť pro pixely obrázku
<ul>
<li>Naalokuj dostatek paměti dle hlavičky (šířka x výška)</li>
</ul>
</li>
</ul>
</li>
<li>Změň velikost obrázku
<ul>
<li>Vytvoř obrázek s novým rozměrem</li>
<li>Překopíruj původní obrázek do nového obrázku
<ul>
<li>Projdi všechny pixely nového obrázku
<ul>
<li>Projdi každý řádek</li>
<li>Pro každý řádek projdi každý sloupec</li>
</ul>
</li>
<li>Pro každý pixel spočítej původní pozici pixelu
<ul>
<li>Pro výpočet použij poměr šířky/výšky nového/starého obrázku</li>
</ul>
</li>
<li>Překopíruj pixel ze starého obrázku do nového</li>
</ul>
</li>
<li>Vrať nový obrázek</li>
</ul>
</li>
<li>Zapiš upravený obrázek
<ul>
<li>Otevři soubor k zápisu</li>
<li>Zapiš hlavičku obrázku do souboru</li>
<li>Zapiš pixely obrázku do souboru</li>
</ul>
</li>
<li>Vykresli upravený obrázek
<ul>
<li>Vytvoř okno pro vykreslení obrázku</li>
<li>Překopíruj pixely obrázku do otevřeného okna</li>
<li>Zobraz okno s obrázkem</li>
</ul>
</li>
</ul>
<p>Pomocí tohoto univerzálního postupu se dříve či později dostanete k (pod)úloze, kterou byste již měli umět
vyřešit (např. otevření souboru). Jakmile danou podúlohu vyřešíte, tak budete o krok blíže k řešení
původní složité úlohy.</p>
<p>Tímto způsobem můžeme programy rovnou od začátku začít psát. Například při řešení výše zmíněné úlohy
můžeme začít nadefinováním hlavní logiky programu pomocí volání funkcí, kde každá funkce bude reprezentovat
jednu podúlohu. I když funkce zatím nebudou naprogramované a později se třeba trochu změní, tak nám
toto rozdělení může pomoct přemýšlet nad problémem abstraktněji, zorientovat se v něm a také
získat naději, že se úlohu podaří vyřešit. Stejný princip opět můžeme použít při implementaci jednotlivých
funkcí. Program (či funkci) pak lze přečíst jako (anglickou) větu a je tak jednodušší pochopit, co má
vlastně dělat.</p>
<pre><code class="language-c">int main() {
    // načti obrázek
    FILE* input_file = open_file(...);
    Img image = load_image(input_file);

    // změň jeho velikost
    Img resized = resize_image(&amp;image);

    // zapiš obrázek
    FILE* output_file = open_file(...);
    write_image(input_file, &amp;resized);

    // vykresli upravený obrázek
    draw_image(&amp;resized);

    return 0;
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-177556287-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="theme/mode-c_cpp.min.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
